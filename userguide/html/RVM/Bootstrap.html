<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>RVM : Bootstrap</title>
	    <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">	    
    </head>

    <body>
	    <table class="pagecontent" border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#ffffff">
		    <tr>
			    <td valign="top" class="pagebody">
				    <div class="pageheader">
					    <span class="pagetitle">
                            RVM : Bootstrap
                                                    </span>
				    </div>
				    <div class="pagesubheading">
					    This page last changed on May 30, 2009 by <font color="#0050B2">pizlo</font>.
				    </div>

				    <p>The RVM is started up by a boot program written in C. This program is responsible for</p>
<ul>
	<li>registering signal handlers to deal with the hardware errors generated by the RVM</li>
	<li>establishing the initial virtual memory map employed by the RVM</li>
	<li>mapping the RVM image files</li>
	<li>installing the addresses of the C wrapper functions which are invoked by the runtime to interact with the underlying operating system into the boot record of at the start of the RVM image area</li>
	<li>setting up the JTOC and TR registers for its <tt>RVMThread</tt>/pthread</li>
	<li>switching the pthread into the bootstrap Java stack running the bootstrap Java method in the bootstrap Java thread</li>
</ul>


<p>At this point all further initialization of the RVM is done either in Java or by employing the wrapper callbacks located in the boot record.</p>

<p>The initial bootstrap routine is <tt>VM.boot()</tt>. It sets up the initial thread environment so that it looks like any other thread created by a call to Thread.start() then performs a variety of Java boot operations, including initialising the memory manager subsystem, the runtime compiler, the system classloader and the time classes.</p>

<p>The bootstrap routine needs to rerun class initializers for a variety of the runtime and Classpath classes which are already loaded and compiled into the image file. This is necessary because some of the data generated by these initialization routines will not be valid in the RVM runtime. The data may be invalid as the host environment that generated the boot image may differ from the current environment.</p>

<p>The boot process the enables the Java scheduler and locking system, setting up the data structures necessary to launch additional threads.  The scheduler also starts the <tt>FinalizerThread} and multiple garbage collector threads {{CollectorThread</tt>.</p>

<p>Next, the boot routine boots the the JNI subsystem which enables calls to native code to be compiled and executed then re-initialises a few more classes whose init methods require a functional JNI (i.e. <tt>java.io.FileDescriptor</tt>).</p>

<p>Finally, the boot routine loads the boot application class supplied on the rvm command line, creates and schedules a Java main thread to execute this class's main method, then exits, switching execution to the main thread. Execution continues until the application thread and all non-daemon threads have exited. Once there are no runnable threads (other than system threads such as the idle threads, collector threads etc) execution of the RVM runtime terminates and the rvm process exits.</p>

<h2><a name="Bootstrap-MemoryMap"></a>Memory Map</h2>

<p>The RVM divides its available virtual memory space into various segments containing either code, or data or a combination of the two. The basic map is as follows:</p>
<div class="preformatted panel" style="border-width: 1px;"><div class="preformattedContent panelContent">
<pre>                   +--&gt; BOOT_IMAGE_START   MAX_MAPPABLE_ADDRESS &lt;--+
                   |&lt;- SEGMENT_SIZE -&gt;                             |
+-------------------------------------------------------------------------+
+ Platform specific| RVM Image       | RVM Heap                    | Plat +
+ ( booter code/ ) | ( initial code )| ( meta data, immortal data )| spec +
+ ( data, shlibs ) | (  &amp; data      )| ( large &amp; small objects    )|      +
+-------------------------------------------------------------------------+
</pre>
</div></div>

<h3><a name="Bootstrap-BootSegment"></a>Boot Segment</h3>

<p>The bottom segment of the address space is left for the underlying platform to locate the boot program (including statically linked library code) and any dynamically allocated data and library code.</p>

<h3><a name="Bootstrap-RVMImageSegment"></a>RVM Image Segment</h3>

<p>The next area is the one initialized by the boot program to contain the all the initial static data, instance data and compiled method code required in order for the runtime to be able to function. The required memory data is loaded from an image file created by an off line Java program, the boot image writer.</p>

<p>This image file is carefully constructed to contain data which, when loaded at the correct address, will populate the runtime data area with a memory image containing:</p>
<ul>
	<li>a JTOC</li>
	<li>all the TIBs, static method code arrays and static field data directly referenced from the JTOC</li>
	<li>all the dynamic method code arrays indirectly referenced from the TIBS</li>
	<li>all the classloader's internal class and method instances indirectly referenced via the TIBS</li>
	<li>ancillary structures attached to these class and method instances such as class bytecode arrays, compilation records, garbage collection maps etc</li>
	<li>a single bootstrap Java thread instance in which Java execution commences</li>
	<li>a single bootstrap thread stack used by the bootstrap thread.</li>
	<li>a master boot record located at the start of the image load area containing references to all the other key objects in the image (such as the JTOC, the bootstrap thread etc) plus linkage slots in which the booter writes the addresses of its C callback functions.</li>
</ul>


<h3><a name="Bootstrap-RVMHeapSegment"></a>RVM Heap Segment</h3>

<p>The RVM heap segment is used to provide storage for code and data created during Java execution. The RVM can be configured to employ various different allocation managers taken from the <a href="MMTk.html" title="MMTk">MMTk</a> memory management toolkit.</p>

				    
                    			    </td>
		    </tr>
	    </table>
	    <table border="0" cellpadding="0" cellspacing="0" width="100%">
			<tr>
				<td height="12" background="http://docs.codehaus.org/images/border/border_bottom.gif"><img src="images/border/spacer.gif" width="1" height="1" border="0"/></td>
			</tr>
		    <tr>
			    <td align="center"><font color="grey">Document generated by Confluence on Jun 10, 2009 09:12</font></td>
		    </tr>
	    </table>
    </body>
</html>