<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>RVM : JNI</title>
	    <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">	    
    </head>

    <body>
	    <table class="pagecontent" border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#ffffff">
		    <tr>
			    <td valign="top" class="pagebody">
				    <div class="pageheader">
					    <span class="pagetitle">
                            RVM : JNI
                                                    </span>
				    </div>
				    <div class="pagesubheading">
					    This page last changed on Jul 02, 2008 by <font color="#0050B2">dgrove</font>.
				    </div>

				    <h2><a name="JNI-Overview"></a>Overview</h2>

<p>This section describes how Jikes RVM interfaces to native code. There are three major aspects of this support:</p>
<ul>
	<li>JNI Functions: This is the mechanism for transitioning from native code into Java code. Jikes RVM implements the 1.1 through 1.4 JNI specifications.</li>
	<li>Native methods: This is the mechanism for transitioning from Java code to native code. In addition to the normal mechanism used to invoke a native method, Jikes RVM also supports a more restricted syscall mechanism that is used internally by low-level VM code to invoke native code.</li>
	<li>Integration with m-to-n threading: Attempting to get Jikes RVM's cooperative m-to-n threading model to work nicely (at all) with native code is a major challenge. We have gone through several major redesigns of the JNI support code and RVM thread system in the process. This is still a work in progress.Each of these aspects is discussed in more detail in the following sections.</li>
</ul>


<h2><a name="JNI-JNIFunctions"></a>JNI Functions</h2>

<p>All of the 1.1 through 1.4 <tt>JNIEnv</tt> interface functions are implemented.</p>

<p>The functions are defined in the class <tt>JNIFunctions</tt>. Methods of this class are compiled with special prologues/epilogues that translate from native calling conventions to Java calling conventions and handle other details of the transition related to <em>m-to-n</em> threading. Currently the optimizing compiler does not support these specialized prologue/epilogue sequences so all methods in this class are baseline compiled. The prologue/epilogue sequences are actually generated by the platform-specific <tt>JNICompiler</tt>.</p>

<h2><a name="JNI-InvokingNativeMethods"></a>Invoking Native Methods</h2>

<p>There are two mechanisms whereby RVM may transition from Java code to native code.</p>

<p>The first mechanism is when RVM calls a method of the class <tt>SysCall</tt>. The native methods thus invoked are defined in one of the C and C+&#43; files of the <tt>JikesRVM</tt> executable. These native methods are non-blocking system calls or C library services. To implement a syscall, the RVM compilers generate a call sequence consistent with the platform's underlying calling convention. A syscall is not a GC-safe point, so syscalls may modify the Java heap (eg. memcpy()). For more details on the mechanics of adding a new syscall to the system, see the header comments of SysCall.java. Note again that the syscall methods are NOT JNI methods, but an independent (more efficient) interface that is specific to Jikes RVM.</p>

<p>The second mechanism is JNI. Naturally, the user writes JNI code using the JNI interface. RVM implements a call to a native method by using the platform-specific <tt>JNICompiler</tt> to generate a stub routine that manages the transition between Java bytecode and native code. A JNI call is a GC-safe point, since JNI code cannot freely modify the Java heap.</p>

<h2><a name="JNI-InteractionswithmtonThreading"></a>Interactions with <em>m-to-n</em> Threading</h2>

<p>See the <a href="Thread Management.html" title="Thread Management">Thread Management</a> subsection for more details on the thread system and <em>m-to-n</em> threading in Jikes RVM.</p>

<p>There are two ways to execute native code: syscalls and JNI. A Java thread that calls native code by either mechanism will never be preempted by Jikes RVM. As far as Jikes RVM is concerned, a Java thread that enters native code has exclusive access to the underlying <tt>Processor</tt> (pthread) until it returns to Java. Of course the OS may preempt the underlying pthread; this falls beyond Jikes RVM's control.</p>

<p>Some activities (eg. GC) require all threads currently running Java code to halt. So what happens when one Java thread forces a GC while another Java thread is executing native code?</p>

<p>If the native code is a <tt>syscall</tt>, then the VM stalls until the native code returns.  Thus, all syscalls should be non-blocking operations that return fairly soon.  Note that a <tt>syscall</tt> is <em>not</em> a GC-safe point.</p>

<p>On Linux/x86, Jikes RVM "hijacks" certain blocking system calls and reflects them back into the VM. The VM then uses nonblocking equivalents. This handles many of the common cases of blocking native code without requiring the full complexity of the timer-based preemption mechanism that we used to use on AIX. A complete solution would consist of implementing both mechanisms on both platforms. We hope to do this in the future.</p>

<p>We got GNU Classpath's (JNI-based) AWT support to work by adding code to Classpath that tells GTk (the windowing toolkit Classpath uses) to use Jikes RVM's Java threading primitives instead of the pthread-based ones that it uses by default. Jikes RVM automatically tells Classpath to do this by setting the Java system property <tt>gnu.classpath.awt.gtk.portable.native.sync</tt> at boot time.  If your native code uses the <tt>glib</tt> threading primitives, as GTk does, then this will work for you, too.</p>

<h2><a name="JNI-ImplementationDetails"></a>Implementation Details</h2>

<p>Supporting the combination of blocking native code and <em>m-to-n</em> threading is inherently complicated. Unfortunately the Jikes RVM implementation is further complicated by the fact that too much of the control logic for transitions between C and Java code is embedded in the low-level, platform-specific JNICompiler classes. As a result, the code is hard to maintain and the JNI implementations on different platforms tend to diverge.</p>

<p>We have some ideas for a redesign that would enable more of the control logic to be embodied in shared Java code, but there are a few minor issues to be worked out. Hopefully this will happen eventually.</p>

<h2><a name="JNI-MissingFeatures"></a>Missing Features</h2>

<ul>
	<li><b>Native Libraries:</b> JNI 1.2 requires that the VM specially treat native libraries that contain exported functions named JNI_OnLoad and JNI_OnUnload. Only JNI_OnLoad is currently implemented.</li>
	<li><b>JNICompiler:</b> The only known deficiency in JNICompiler is that the prologue and epilogues only handle passing local references to functions that expect a jobject; they will not properly handle a jweak or a regular global reference. This would be fairly easy to implement.</li>
	<li><b>JavaVM interface:</b> The JavaVM interface has GetEnv fully implemented and AttachCurrentThread partly implemented, but DestroyJavaVM, DetachCurrentThread, and AttachCurrentThreadAsDaemon are just stubbed out and return error codes.</li>
	<li><b>Directly-Exported Invocation Interface Functions:</b> These functions (GetDefaultJavaVMInitArgs, JNI_CreateJavaVM, and JNI_GetCreatedJavaVMs) are not implemented. This is because we do not provide a virtual machine library that can be linked against, nor do we support native applications that launch and use an embedded Java VM. There is no inherent reason why this could not be done, but we have not done so yet.</li>
</ul>


<h2><a name="JNI-ThingsJNICan%27tHandle"></a>Things JNI Can't Handle</h2>

<ul>
	<li><b>atexit routines:</b> Calling JNI code via a routine run at exit time means calling back into a VM that has been shutdown. This will cause the Jikes RVM to freeze on Intel architectures.</li>
</ul>


<p>Contributions of any of the missing functionality described here (and associated tests) would be greatly appreciated. </p>

				    
                    			    </td>
		    </tr>
	    </table>
	    <table border="0" cellpadding="0" cellspacing="0" width="100%">
			<tr>
				<td height="12" background="http://docs.codehaus.org/images/border/border_bottom.gif"><img src="images/border/spacer.gif" width="1" height="1" border="0"/></td>
			</tr>
		    <tr>
			    <td align="center"><font color="grey">Document generated by Confluence on Aug 06, 2008 12:40</font></td>
		    </tr>
	    </table>
    </body>
</html>