<?xml version="1.0" encoding="utf8" ?> 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">  
<!--http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd-->  
<html xmlns="http://www.w3.org/1999/xhtml"  
> 
<head><title>6 Experimental Guidelines</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf8" /> 
<meta name="generator" content="TeX4ht (http://www.tug.org/tex4ht/)" /> 
<meta name="originator" content="TeX4ht (http://www.tug.org/tex4ht/)" /> 
<!-- xhtml,charset=utf8,2,html --> 
<meta name="src" content="userguide.tex" /> 
<meta name="date" content="2016-02-18 10:15:00" /> 
<link rel="stylesheet" type="text/css" href="userguide.css" /> 
</head><body 
>
<!--l. 2--><div class="crosslinks"><p class="noindent"></p></div>
<h2 class="chapterHead"><span class="titlemark">Chapter 6</span><br /><a 
 id="x8-620006"></a>Experimental Guidelines</h2>
<!--l. 5--><p class="noindent" >This section provides some tips on collecting performance numbers with Jikes
RVM.
</p>
<h3 class="sectionHead"><span class="titlemark">6.1   </span> <a 
 id="x8-630006.1"></a>Which boot image should I use?</h3>
<!--l. 9--><p class="noindent" >To make a long story short the best performing conﬁguration of Jikes RVM will
almost always be <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">production</span></span></span>. Unless you really know what you are doing,
don&#x2019;t use any other conﬁguration to do a performance evaluation of Jikes
RVM.
</p><!--l. 11--><p class="noindent" >Any boot image you use for performance evaluation must have the following
characteristics for the results to be meaningful: </p>
     <ul class="itemize1">
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">config.assertions=none</span></span></span>.  Unless  this  is  set,  the  runtime  system  and
     optimizing compiler will perform fairly extensive assertion checking. This
     introduces signiﬁcant runtime overhead. By convention, a conﬁguration
     with the <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">Fast</span></span></span> preﬁx disables assertion checking.
     </li>
     <li class="itemize"><span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">config.bootimage.compiler=opt</span></span></span>. Unless this is set, the boot image will
     be compiled with the baseline compiler and virtual machine performance
     will be abysmal. Jikes RVM has been designed under the assumption that
     aggressive inlining and optimization will be applied to the VM source code.</li></ul>
<!--l. 19--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">6.2   </span> <a 
 id="x8-640006.2"></a>Compiler Replay</h3>
<!--l. 21--><p class="noindent" >The compiler-replay methodology is deterministic and eliminates memory allocation
and mutator variations due to non-deterministic application of the adaptive compiler.
We need this latter methodology because the non-determinism of the adaptive
compilation system makes it a diﬃcult platform for detailed performance studies. For
example, we cannot determine if a variation is due to the system change
being studied or just a diﬀerent application of the adaptive compiler. The
information we record and use are hot methods and blocks information. We also
record dynamic call graph with calling frequency on each edge for inlining
decisions.
</p><!--l. 23--><p class="noindent" ><span 
class="cmti-10">Note that in December 2011, compiler replay was signiﬁcantly improved. The notes</span>
<span 
class="cmti-10">below apply to the post December 2011 version of replay.</span>
</p><!--l. 25--><p class="noindent" >Here is how to use it:
</p><!--l. 27--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">6.2.1   </span> <a 
 id="x8-650006.2.1"></a>Generate Advice</h4>
                                                                  

                                                                  
<!--l. 29--><p class="noindent" >There are three kinds of advice used by the replay system, each is workload-speciﬁc
(ie you should generate advice ﬁles for each benchmark): </p>
     <ul class="itemize1">
     <li class="itemize"><span 
class="cmbx-10">Compilation advice (.ca ﬁle). </span>This advice records for every compiled
     method which compiler (base or opt) and if opt, at which optimization
     level it should be compiled. Replay compilation will not work without a
     compilation advice ﬁle.
     </li>
     <li class="itemize"><span 
class="cmbx-10">Edge counts (.ec ﬁle). </span>This advice captures edge counts generated by
     the  execution  of  baseline-compiled  code.  Edge  counts  are  used  by  the
     compiler to understand which edges in the control ﬂow graph are hot. At
     the time of writing, edge counts were measured as contributing about 2
     </li>
     <li class="itemize"><span 
class="cmbx-10">Dynamic callgraph (.dc ﬁle). </span>This advice captures the dynamic call
     graph, which allows the compiler to understand the frequency with which
     particular call chains occur. This is particularly useful in guiding inlining
     decisions. At the time of writing the call graph contributes about 8</li></ul>
<!--l. 37--><p class="noindent" >One way to gather advice is to execute the benchmark multiple times under
controlled settings, producing proﬁles at each execution. Then establish the fastest
execution among the set of runs, and choose the proﬁles associated with that
execution as the advice ﬁles. A common methodology is to invoke each benchmark 20
times (ie take the best invocation from a set of 20 trials), and in each invocation, run
10 iterations of the benchmark (ie the advice will then capture the warmed-up,
steady state of the benchmark). For more advanced methodologies, please refer to
current research papers on this topic.
</p><!--l. 39--><p class="noindent" >When generating the advice, you will need to use the following command line
arguments (typically use all six arguments, so that all three advice ﬁles are generated
at each invocation):
</p>
<!--l. 41-->
<br />
    <div class="caption" 
><span class="id">5cAp1x8-650006.2.1:
    </span><span  
class="content">For
    adaptive
    compilation
    proﬁle</span></div><!--tex4ht:label?: x8-650006.2 --><div class="lstlisting" id="listing-41"><span class="label"><a 
 id="x8-65001r1"></a></span>-X:aos:enable_advice_generation=true -X:aos:cafo=my_compiler_advice_file.ca
</div>
<!--l. 45-->
<br />
    <div class="caption" 
><span class="id">5cAp2x8-650006.2.1:
    </span><span  
class="content">For
    edge
    count
    proﬁle</span></div><!--tex4ht:label?: x8-650006.2 --><div class="lstlisting" id="listing-42"><span class="label"><a 
 id="x8-65002r1"></a></span>-X:base:profile_edge_counters=true -X:base:profile_edge_counter_file=my_edge_counter_file.ec
                                                                  

                                                                  
</div>
<!--l. 49-->
<br />
    <div class="caption" 
><span class="id">5cAp3x8-650006.2.1:
    </span><span  
class="content">For
    dynamic
    call
    graph
    proﬁle</span></div><!--tex4ht:label?: x8-650006.2 --><div class="lstlisting" id="listing-43"><span class="label"><a 
 id="x8-65003r1"></a></span>-X:aos:dcfo=my_dynamic_call_graph_file.dc -X:aos:final_report_level=2
</div>
<!--l. 55--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">6.2.2   </span> <a 
 id="x8-660006.2.2"></a>Executing with advice</h4>
<!--l. 57--><p class="noindent" >The basic model is simple. At a nominated time in the execution of a program,
all methods speciﬁed in the .ca advice ﬁle will be (re)compiled with the
compiler and optimization level nominated in the advice ﬁle. Broadly, there
are two ways of initiating bulk compilation: a) by calling the method
<span 
class="cmtt-10">org.jikesrvm.adaptive.recompilation.BulkCompile.compileAllMethods()</span>
during execution, and b) by using the <span 
class="cmtt-10">-X:aos:enable</span><span 
class="cmtt-10">_precompile=true </span>ﬂag at the
command line to trigger bulk compilation at boot time. A standard methodology is
to use a benchmark harness call back mechanism to call <span 
class="cmtt-10">compileAllMethods() </span>at
the end of the ﬁrst iteration of the benchmark. At the time of writing this gave
performance roughly 2
</p><!--l. 59--><p class="noindent" >For <span 
class="cmbx-10">&#x2019;warmup&#x2019; replay </span>(where <span 
class="cmtt-10">org.jikesrvm.adaptive.recompilation.BulkCompile.compileAllMethods()</span>
is called at the end of the ﬁrst iteration):
</p>
<!--l. 61-->
<div class="lstlisting" id="listing-44"><span class="label"><a 
 id="x8-66001r1"></a></span>-X:aos:initial_compiler=base -X:aos:enable_bulk_compile=true -X:aos:enable_recompilation=false -X:aos:cafi=benchmark.ca -X:vm:edgeCounterFile=benchmark.ec -X:aos:dcfi=benchmark.dc
</div>
<!--l. 65--><p class="noindent" >For <span 
class="cmbx-10">precompile replay </span>(where bulk compilation occurs at boot time):
</p>
<!--l. 67-->
<div class="lstlisting" id="listing-45"><span class="label"><a 
 id="x8-66002r1"></a></span>-X:aos:initial_compiler=base -X:aos:enable_precompile=true -X:aos:enable_recompilation=false -X:aos:cafi=benchmark.ca -X:vm:edgeCounterFile=benchmark.ec -X:aos:dcfi=benchmark.dc
</div>
<!--l. 73--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">6.2.3   </span> <a 
 id="x8-670006.2.3"></a>Verbosity</h4>
                                                                  

                                                                  
<!--l. 75--><p class="noindent" >You can alter the verbosity of the replay behavior with the ﬂag
<span 
class="cmtt-10">-X:aos:bulk</span><span 
class="cmtt-10">_compilation</span><span 
class="cmtt-10">_verbosity</span>, which by default (0) is silent, but
will produce more information about the recompilation with values of 1 or
2.
</p><!--l. 81--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">6.3   </span> <a 
 id="x8-680006.3"></a>Measuring GC performance</h3>
<!--l. 83--><p class="noindent" >MMTk includes a statistics subsystem and a harness mechanism for measuring its
performance. If you are using the DaCapo benchmarks, the MMTk harness
can be invoked using the &#x2019;-c MMTkCallback&#x2019; command line option, but for
other benchmarks you will need to invoke the harness by calling the static
methods
</p>
<!--l. 85-->
<div class="lstlisting" id="listing-46"><span class="label"><a 
 id="x8-68001r1"></a></span>org.mmtk.plan.Plan.harnessBegin() <br /><span class="label"><a 
 id="x8-68002r2"></a></span>org.mmtk.plan.Plan.harnessEnd()
</div>
<!--l. 90--><p class="noindent" >at the appropriate places. Other command line switches that aﬀect the collection of
statistics are
</p>
<div class="table">
                                                                  

                                                                  
<!--l. 92--><p class="noindent" ></p><hr class="float" /><div class="float" 
>
                                                                  

                                                                  
<div class="tabular"> <table id="TBL-7" class="tabular" 
cellspacing="0" cellpadding="0"  
><colgroup id="TBL-7-1g"><col 
id="TBL-7-1" /><col 
id="TBL-7-2" /></colgroup><tr  
 style="vertical-align:baseline;" id="TBL-7-1-"><td  style="white-space:wrap; text-align:left;" id="TBL-7-1-1"  
class="td11"><!--l. 95--><p class="noindent" >Option                                </p></td><td  style="white-space:wrap; text-align:left;" id="TBL-7-1-2"  
class="td11"><!--l. 95--><p class="noindent" >Description                                          </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-2-"><td  style="white-space:wrap; text-align:left;" id="TBL-7-2-1"  
class="td11"><!--l. 96--><p class="noindent" >-X:gc:printPhaseStats=true      </p></td><td  style="white-space:wrap; text-align:left;" id="TBL-7-2-2"  
class="td11"><!--l. 96--><p class="noindent" >Print statistics for each mutator/gc phase
during the run                                      </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-3-"><td  style="white-space:wrap; text-align:left;" id="TBL-7-3-1"  
class="td11"><!--l. 97--><p class="noindent" >-X:gc:xmlStats=true               </p></td><td  style="white-space:wrap; text-align:left;" id="TBL-7-3-2"  
class="td11"><!--l. 97--><p class="noindent" >Print  statistics  in  an  XML  format  (as
opposed to human-readable format)          </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-4-"><td  style="white-space:wrap; text-align:left;" id="TBL-7-4-1"  
class="td11"><!--l. 98--><p class="noindent" >-X:gc:verbose                         </p></td><td  style="white-space:wrap; text-align:left;" id="TBL-7-4-2"  
class="td11"><!--l. 98--><p class="noindent" >This is incompatible with MMTk&#x2019;s statistics
system.                                               </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-5-"><td  style="white-space:wrap; text-align:left;" id="TBL-7-5-1"  
class="td11"><!--l. 99--><p class="noindent" >-X:gc:variableSizeHeap=false    </p></td><td  style="white-space:wrap; text-align:left;" id="TBL-7-5-2"  
class="td11"><!--l. 99--><p class="noindent" >Disable dynamic resizing of the heap         </p></td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-6-"><td  style="white-space:wrap; text-align:left;" id="TBL-7-6-1"  
class="td11">                           </td></tr></table></div>
                                                                  

                                                                  
</div><hr class="endfloat" />
</div>
<!--l. 104--><p class="noindent" >Unless you are speciﬁcally researching ﬂexible heap sizes, it is best to run
benchmarks in a ﬁxed size heap, using a range of heap sizes to produce a curve that
reﬂects the space-time tradeoﬀ. Using replay compilation and measuring the
second iteration of a benchmark is a good way to produce results with low
noise.
</p><!--l. 106--><p class="noindent" >There is an active debate among memory management and VM researchers
about how best to measure performance, and this section is not meant to
dictate or advocate any particular position, simply to describe one particular
methodology.
</p>
<h3 class="sectionHead"><span class="titlemark">6.4   </span> <a 
 id="x8-690006.4"></a>Jikes RVM is really slow! What am I doing wrong?</h3>
<!--l. 113--><p class="noindent" >Perhaps you are not seeing stellar Jikes<sup class="textsuperscript"><span 
class="cmr-9">TM</span></sup> RVM performance. If Jikes RVM as
described above is not competitive product JVMs, we recommend you test your
installation with the DaCapo benchmarks. We expect Jikes RVM performance to be
very close to Sun&#x2019;s HotSpot 1.5 server running the DaCapo benchmarks. Of course,
running DaCapo well does not guarantee that Jikes RVM runs all codes
well.
</p><!--l. 115--><p class="noindent" >Some kinds of code will not run fast on Jikes RVM. Known issues include:
     </p><ol  class="enumerate1" >
     <li 
  class="enumerate" id="x8-69002x1">Jikes RVM start-up may be slow compared to the some product JVMs.
     </li>
     <li 
  class="enumerate" id="x8-69004x2">Remember                                                                            that
     the non-adaptive conﬁgurations (<span 
class="cmtt-10">-X:aos:enable</span><span 
class="cmtt-10">_recompilation=false</span>
     <span 
class="cmtt-10">-X:aos:initial</span><span 
class="cmtt-10">_compiler=opt</span>)  opt-compile  <span 
class="cmti-10">every  </span>method  the  ﬁrst
     time  it  executes.  With  aggressive  optimization  levels,  opt-compiling
     will severely slow down the ﬁrst execution of each method. For many
     benchmarks,  it  is  possible  to  test  the  quality  of  generated  code  by
     either running for several iterations and ignoring the ﬁrst, or by building
     a  warm-up  period  into  the  code.  The  SPEC  benchmarks  already  use
     these strategies. The adaptive conﬁguration does not have this problem;
     however, we cannot stipulate that the adaptive system will compete with
     the product on short-running codes of a few seconds.
     </li>
     <li 
  class="enumerate" id="x8-69006x3">Performance on tight loops may suﬀer. The Jikes RVM mechanism for safe
     points (thread preemption for garbage collection, on-stack-replacement,
     proﬁling, etc) relies on the insertion of a yield test on every back edge.
     This will hurt tight loops, including many simple microbenchmarks. We
     should someday alleviate this problem by strip-mining and hoisting the
     yield point out of hot loops, or implementing a safe point mechanism that
     does not require an explicit check.
     </li>
     <li 
  class="enumerate" id="x8-69008x4">The load balancing in the system is naive and unfair. This can hurt some
     styles of codes, including bulk-synchronous parallel programs.</li></ol>
                                                                  

                                                                  
<!--l. 123--><p class="noindent" >The Jikes RVM developers wish to ensure that Jikes RVM delivers competitive
performance. If you can isolate reproducible performance problems, please let us
know.
</p><!--l. 127--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">6.5   </span> <a 
 id="x8-700006.5"></a>Stability of Jikes RVM</h3>
<!--l. 129--><p class="noindent" >Jikes RVM is not as stable as commercial JVMs such as HotSpot or J9.
Design your evaluation systems (e.g. scripts) so that they can deal with
crashes and deadlocks/livelocks. The latter can be dealt with by running Jikes
RVM with a timelimit. For example, if you are using Linux and shell scripts,
you can use the <a 
href="http://devel.ringlet.net/sysutils/timelimit/" >timelimit</a> program to terminate the Jikes RVM after a set
time.
                                                                  

                                                                  
</p>
<!--l. 2--><div class="crosslinks"><p class="noindent"></p></div>
<!--l. 2--><p class="noindent" ><a 
 id="tailExperimentalGuidelines.html"></a></p> 
</body></html> 
