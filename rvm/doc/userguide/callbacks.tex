
\index{callbacks}

The RVM provides callbacks for many runtime events of interest to the RVM
programmer, such as classloading, VM bootimage creation, and VM exit.  The
callbacks allow arbitrary code to be executed on any of the supported events.

The callbacks are accessed through the nested interfaces defined in the 
\xlink{{\tt VM\_Callbacks}}{\VMCallbacksURL} 
class.  There is one interface per event type.  To be notified
of an event, register an instance of a class that implements the corresponding
interface with {\tt VM\_Callbacks} by calling the corresponding {\tt add...()}
method.  For example, to be notified when a class is instantiated (see section
\ref{sssec:classLoading}), first implement the {\tt
VM\_Callbacks.ClassInstantiatedMonitor} interface, and then call {\tt
VM\_Callbacks.addClassInstantiatedMonitor()} with an instance of your class.
When any class is instantiated, the {\tt notifyClassInstantiated} method in
your instance will be invoked.

The RVM supports callbacks for a number of events; see 
\xlink{{\tt VM\_Callbacks}}{\VMCallbacksURL} for the list of currently
supported callbacks.

The appropriate interface names can be obtained by appending ``Monitor'' to the
event names (e.g. the interface to implement for the {\tt MethodOverride} event
is {\tt VM\_Callbacks.MethodOverrideMonitor}).  Likewise, the method to
register the callback is ``add'', followed by the name of the interface (e.g.
the register method for the above interface is {\tt
VM\_Callbacks.addMethodOverrideMonitor()}).

Since the events for which callbacks are available are internal to the RVM,
there are naturally some limitations on the behavior of the callback code.  For
example, as soon as the exit callback is invoked, all threads are considered
daemon threads (i.e. the VM will not wait for any new threads created in the
callbacks to complete before exiting).  Thus, if the exit callback creates any
threads, it has to {\tt join()} with them before returning.  These limitations
may also produce some unexpected behavior.  For example, while there is an
elementary safeguard on any classloading callback that prevents recursive
invocation (i.e. if the callback code itself causes classloading), there is no
such safeguard across events, so, if there are callbacks registered for both
{\tt ClassLoaded} and {\tt ClassInstantiated} events, and the {\tt
ClassInstantiated} callback code causes dynamic class loading, the {\tt
ClassLoaded} callback will be invoked for the new class, but not the {\tt
ClassInstantiated} callback.

Examples of callback use can be seen in the {\tt VM\_Controller} class in the
adaptive system and the {\tt VM\_GCStatistics} class.

