This section provides some tips on collecting performance numbers with
RVM.

\index{boot image}
\index{configurations}
\subsection{Which boot image should I use?}

To make a long story short, use the
\begin{itemize}
\item {\tt FastSemispace} configuration for performance runs that invoke the optimizing compiler on every method, and
\item {\tt FastAdaptiveSemispace} configuration for performance runs that use the adaptive compilation system.
\end{itemize}

These two configurations share the following characteristics:

\begin{itemize}
\item The code placed in the boot image is optimized.
\item The optimizing compiler and associated support are in
the boot image.  Other
configurations with this characteristic begin with the prefix {\tt Full}.
If you do not use a {\tt Fast<...>} or {\tt Full<...>} configuration, 
the optimizing
compiler loads at runtime, and the optimizing compiler itself will be
baseline compiled and run slowly.
\item Both configurations set the final static boolean
{\tt VM.VerifyAssertions = false}.  This flag avoids expensive assertion
checking at runtime.
\index{garbage collection}
\item Both configurations use the non-generational, copying (semi-space) 
collector.  This collector has the fastest allocation sequence.  For
applications with a large working set (eg SPECjbb2000), you may get
better performance from the MarkSweep collector than the Semispace
collector.  Naturally, GC research will need to build configurations
with other collectors.
\end{itemize}

\subsection{What commmand-line arguments should I use?}

For best performance we recommend the following:

\begin{itemize}
\item {\tt -processors all}: By default, RVM uses only one processor.  Setting this option tells the runtime system to utilize all available processors.
\item {\tt -X:irc:O2}: For non-adaptive configurations, this command-line option tells the optimizing compiler to use our highest level of optimization.
\item Set the heap and large heap sizes generously.  We typically set the heap size to at least half the physical memory on a machine.
\item Use a dedicated machine with no other users.  The RVM thread and synchronization implementation do not play well with others.
\end{itemize}

\subsection{RVM is really slow! What am I doing wrong?}


Perhaps you are not seeing stellar RVM performance.  If RVM as
described above is not competitive with the IBM AIX\AIXTMFootnote or
Linux/IA32 product DK, we recommend you test your installation with
the SPECjvm98 benchmarks.  We expect RVM performance to be competitive
with the IBM DK 1.3.0 on the SPECjvm98 benchmarks.

Of course, SPECjvm98 does not guarantee that RVM runs all codes
well.  We have also tested various flavors of pBOB and the Volano
benchmarks, and usually see superior or competitive performance.

The IA32 port is somewhat less mature than the PPC port, and does not
deliver competitive performance on some codes.  In particular, IA32
floating-point performance is mediocre.

Some classes of codes will not run fast on RVM.  Known issues include:
\begin{itemize}
\item RVM start-up is slow compared to the IBM product JVM.
\item Remember that the non-adaptive configurations (eg. Fast) opt-compile
{\em every} method the first time it executes.  With aggressive optimization
levels, opt-compiling will severely slow down the first execution of
each method.  For many benchmarks, it is possible to test the quality
of generated code by either running for several iterations and ignoring
the first, or by building a warm-up period into the code.  The SPEC benchmarks
already use these strategies.  The adaptive configuration does not
have this problem; however, we cannot stipulate that the adaptive
system will compete with the product on short-running codes of a few seconds.
\item We expect RVM to perform well on codes with many threads, such as
VolanoMark.  However, if you have a code with many threads, each using
JNI, RVM performance will suffer due to factors in the design of
the current thread system.
\index{on-stack replacement}
\item RVM does {\em not} yet support on-stack replacement for
optimizing methods.  The adaptive system will not optimize a single
invocation of a long-running 
method.
\index{quasi-preemption}
\item Performance on tight loops may suffer.  The RVM thread system
relies on quasi-preemption; the optimizing compiler inserts a thread-switch
test on every back edge.  This will hurt tight loops, including many
simple microbenchmarks.  We should someday alleviate this problem by
strip-mining and hoisting the yield point out of hot loops.
\item The thread system currently uses a spinning idle thread. If a RVM
virtual processor (ie., pthread) has no work to do, it spins chewing up
cpu cycles.  Thus, RVM will only perform well if there is no other activity on the machine.
\item The load balancing in the system is naive and unfair.  This can hurt some styles of codes, including bulk-synchronous parallel programs.
\item The adaptive system may not perform well on SMPs; this may be due to bad
interaction with the thread load balancer.
\end{itemize}

The RVM developers wish to ensure that RVM delivers competitive performance.
If you can isolate reproducible performance problems, please let us
know. 

\AIXTMFooter