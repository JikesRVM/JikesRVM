This section contains information on how an adaptive configuration of
RVM can be used to profile an application and the VM.  The first
mechanism provides a coarse-grain profile, giving the percentage of
execution time spent in the hottest methods.  The second method
provides a mechanism to insert counters to count the frequency of 
specific events. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Profiling An Application}
One component of the adaptive optimization system is a low-overhead
time-based sampling mechanism.  This information can be used to drive
recompilation decisions.
\T~\cite{jalapeno-adaptive-00}
It can also be used to produce an aggregate
profile of the execution of an application.  
Here's how.

\begin{enumerate}
\item Create an adaptive configuration.  For the most accurate profile use
{\tt FastAdaptiveSemispace}.  See Section~\ref{section:installation}
\begin{verbatim}
% jconfigure FastAdaptiveSemispace
% cd $RVM_BUILD
% jbuild
\end{verbatim}

\item Run the application using the opt compiler as the runtime compiler and
instructing RVM to gather profile data.
\begin{verbatim}
% rvm -X:aos:primary_strategy=optonly -X:aos:gather_profile_data=true <classfile>
\end{verbatim}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Instrumented Event Counters}
\label{counting_events}
This section describes how the RVM optimizing compiler can be used to
insert counters in the optimized code to count the frequency of
specific events.  Infrastructure for counting events is in place that
hides many of the implementation details of the counters, so that
(hopefully) adding new code to count events should be easy.  All of
the instrumentation phases described below require an adaptive boot
image (any one should work).  Most of the code regarding
instrumentation lives in {\tt
\$RVM\_ROOT/rvm/src/vm/adaptive/runtimeMeasurements/instrumentation} and {\tt
adaptive/recompilation/instrumentation}.

Section~\ref{existing_phases} describes existing instrumentation
phases and how to run them, and Section~\ref{adding_phases}
describes the details of how a new phase can be added.
\subsubsection{Existing instrumentation phases}
\label{existing_phases}
There several existing instrumentation phases.  For now,
turning on each phase requires setting two flags, one for the AOS
system, and one for the opt compiler.  These counters are {\em not}
synchronized (as discussed in Section~\ref{adding_phases}), so they
should not be considered precise.
\begin{enumerate}
\item {\bf Method Invocation Counters} 

Inserts a counter in each method prologue.  Prints counters to stderr
at end.

Parameters: \\
{\tt
-X:aos:primary\_strategy=optonly \\
-X:aos:share:insert\_method\_counters\_opt=true}

\item {\bf Yieldpoint Counters}  

Inserts a counter after each yieldpoint instruction.  Maintains a
separate counter for backedge and prologue yieldpoints.

Parameters:\\
{\tt -X:aos:primary\_strategy=optonly \\
-X:aos:share:insert\_yieldpoint\_counters=true}




\item {\bf Instruction Counters}  

Inserts a counters on each instruction.  A separate count is
maintained for each opcode, and results are dumped to stderr at end of
run. The results look something like:

\begin{verbatim}
Printing Instruction Counters:
------------------------------
109.0 call
0.0 int_ifcmp
30415.0 getfield
20039.0 getstatic
63.0 putfield
20013.0 putstatic
Total: 302933
\end{verbatim}

This is useful for debugging or assessing the effectiveness
of an optimization because you can see a dynamic execution count, rather
than relying on timing.  

NOTE: Currently the counters are inserted at the end of HIR, so the
counts {\em will} capture the effect of HIR optimizations, and will
{\em not} capture optimization that occurs in LIR or later.  

\item {\bf Debugging Counters}  

This flag does not produce observable behavior by itself, but is
designed to allow debugging counters to be inserted easily in
opt-compiler to help debugging of opt-compiler transformations.
If you would like to know the dynamic frequency of a particular
event, simply turn on this flag, and you can easily count dynamic
frequencies of events by calling the method
\xlink{{\tt VM\_AOSDatabase.debuggingCounterData.
getCounterInstructionForEvent(String eventName);}}{\VMAOSDatabaseURL}.  This method
returns an 
\xlink{{\tt OPT\_Instruction}}{\OPTInstructionURL} 
that can be inserted into the
code.  The instruction will increment a counter associated with
the String name ``eventName'', and the counter will be printed at the
end of execution.

For an example, see 
\xlink{{\tt OPT\_Inliner.java}}{\OPTInlinerURL}.  
Look
for the code guarded by the flag {\tt COUNT\_FAILED\_METHOD\_GUARDS}.
 
Parameters:\\
{\tt -X:aos:primary\_strategy=optonly \\
-X:aos:share:insert\_debugging\_counters=true}

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Writing new instrumentation phases}
\label{adding_phases}
This subsection describes the event counting infrastructure.  It is
not a step-by-step for writing new phases, but instead is a
description of the main ideas of the counter infrastructure.
This description, in combination with the above examples, should be
enough to allow new users to write new instrumentation phases.

\paragraph{Counter Managers:}  Counters are created and inserted into
the code using the 
\xlink{{\tt
OPT\_InstrumentedEventCounterManager}}{\OPTInstrumentedEventCounterManagerURL} 
interface.
The purpose of the counter manager interface is to abstract away the
implementation details of the counters, making instrumentation
phases simpler and allowing the counter implementation to be changed
easily (new counter managers can be used without changing any of the
instrumentation phases).  Currently there exists only one counter
manager, 
\xlink{{\tt VM\_CounterArrayManager}}{\VMCounterArrayManagerURL}
, which implements unsynchronized
counters.
When instrumentation options
are turned on in the adaptive system, 
\xlink{{\tt VM\_Instrumentation.boot()}}{\VMInstrumentationURL}
creates an instance of a \xlink{{\tt VM\_CounterArrayManager}}{\VMCounterArrayManagerURL}.

\paragraph{Managed Data:} The class 
\xlink{{\tt VM\_ManagedCounterData}}{\VMManagedCounterDataURL} 
is used to
keep track of counter data that is managed using a counter
manager. This purpose of the data object is to maintain the mapping
between the counters themselves (which are indexed by number) and the
events that they represent.  For example, 
\xlink{{\tt VM\_StringEventCounterData}}{\VMStringEventCounterDataURL} 
is used record the fact that counter \#1
maps to the event named ``FooBar''.  

\ignore{ {\tt VM\_InstrumentedControlFlowEdgeData} is used during edge counting to
record the fact that counter \#1 maps to the ``fallthrough'' edge of
the branch instruction at bytecode offset \#5 at inline context
FooBar.  }

Depending on what you are counting, there may be one data object for
the whole program (such as 
\xlink{{\tt VM\_YieldpointCounterData}}{\VMYieldpointCounterDataURL} and
\xlink{{\tt
VM\_MethodInvocationCounterData}}{\VMMethodInvocationCounterDataURL}), 
or one per method.  There is also a
generic data object called 
\xlink{{\tt VM\_StringEventCounterData}}{\VMStringEventCounterDataURL} 
that
allows events to be give string names (see Debugging Counters above).

\paragraph{Instrumentation Phases:}  The instrumentation itself is
inserted by a compiler phase.  (see
\xlink{{\tt
OPT\_InsertInstructionCounters.java}}{\OPTInsertInstructionCountersURL},
\xlink{{\tt
OPT\_InsertYieldpointCounters.java}}{\OPTInsertYieldpointCountersURL},
\xlink{{\tt
OPT\_InsertMethodInvocationCounter.java}}{\OPTInsertMethodInvocationCounterURL} 
).  The instrumentation phase
inserts high level ``count event'' instructions (which are obtained by
asking the counter manager) into the code.  It also updates the
instrumented counter to remember which counters correspond to which
events.

\paragraph{Lower Instrumentation Phase:}  This 
\xlink{phase}{\OPTCompilerPhaseURL}
converts the high level ``count event'' instruction into the actual
counter code by using the counter manager.  It currently occurs at the
end of LIR, so instrumentation can not be inserted using this
mechanism after LIR.  This phase does not need to be modified if you
add a new phase, except that the {\tt shouldPerform()} method needs to
have your instrumentation listed, so this phase is run when your
instrumentation is turned on.


