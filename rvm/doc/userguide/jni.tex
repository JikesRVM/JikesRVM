\index{JNI}
\index{native code}

This section describes how Jikes RVM interfaces to native code. There
are three major aspects of this support:
\begin{description}
\item[JNI Functions] This is the mechanism for transitioning from
native code into Java. Jikes RVM implements all but 3 of the
functions defined by the 1.1 JNI specification. Jikes RVM implements
some of the additional functions added by the 1.2 JNI
specification.
\item[Native methods] This is the mechanism for transitioning from
Java to native code. In addition to the normal mechanism used to
invoke a native method, Jikes RVM also supports a more restricted
syscall mechanism that is used internally by low-level VM code to
invoke native code. 
\item[Integration with n-to-m threading] Attempting to get Jikes RVM's
cooperative n-to-m threading model to work nicely (at all) with native
code is a major challenge. We have gone through several major
redesigns of the JNI support code and RVM thread system in the
process. This is still a work in progress.
\end{description}
Each of these aspects is discussed in more detail in the following
sections. 

\subsection{JNI Functions}
All but three of the functions defined by the 1.1 JNI specification are
implemented by Jikes RVM. The missing functions are {\tt DefineClass},
{\tt RegisterNatives}, and {\tt UnregisterNatives}.  Almost all of the
additional functions added by the 1.2 JNI specification are not
implemented.  Contributions of the missing functionality (and
associated tests) would be greatly appreciated. 

The functions are defined in the class {\tt VM\_JNIFunctions}. Methods
of this class are compiled with special prologues/epilogues that
translate from native calling conventions to Java calling conventions
and handle other details of the transition related to m-to-n
threading.  Currently the optimizing compiler 
does not support these specialized prologue/epilogue sequences so all
methods in this class are baseline compiled.  The prologue/epilogue
sequences are actually generated by the platform-specific {\tt
VM\_JNICompiler}. 

\subsection{Invoking Native Methods}
There are two mechanisms whereby RVM may transition from Java to native
code.

\index{syscall}
The first mechanism is when RVM calls a method of the class {\tt VM\_SysCall}.
The native methods thus invoked are defined in one of the
C and C++ files of the {\tt JikesRVM} executable. 
These native methods are non-blocking system calls or C library 
services.  To implement a syscall, the RVM compilers generate a call
sequence consistent with the platform's underlying calling convention.
A {\tt syscall} is not a GC-safe point, so {\tt syscalls} may modify the
Java heap (eg. memcpy). For more details on the mechanics of adding a
new syscall to the system, see the header comments of 
\xlink{{\tt VM\_SysCall.java}}{\VMSysCallURL}.

The second mechanism is JNI.  Naturally, the user writes JNI code
using the JNI interface.  RVM implements a call to a native method by
using the platform-specific {\tt VM\_JNICompiler} to generate a stub
routine that manages the transition between Java and native code.  The
thread system implements recovery mechanisms to deal with JNI methods
that block or otherwise fail to return to Java promptly.  A JNI call
is a GC-safe point, since JNI code cannot freely modify the Java heap.

\subsection{Interactions with m-to-n Threading}
See section~\ref{sec:threads} for more details on the thread system
and m-to-n threading in Jikes RVM. 

There are two ways to execute native code: {\tt syscalls} and JNI.
A Java thread that calls native code by either mechanism will never
be preempted by RVM.  As far as RVM is concerned, a Java thread that
enters native code 'owns' the underlying {\tt VM\_Processor} (pthread)
until it returns to Java.  Of course the OS may preempt the underlying
pthread; this falls beyond RVM's control.

Some activities (eg. GC) require all threads currently running Java to halt.  
So what happens when one Java thread forces a GC while another Java thread is
executing native code?

If the native code is a {\tt syscall}, then the VM stalls until the native
code returns.  Thus, all {\tt syscalls} should be non-blocking
operations that return fairly soon.  Note that a {\tt syscall} is 
{\em not} a GC-safe point.

If the native code is JNI (outside RVM control), then the thread system
will wait for a while, eventually declare the underlying pthread "out to
lunch", and continue execution with the remaining pthreads.  Note that 
JNI code is a GC safe point; non-malicious correct native code cannot
perturb the Java heap without notifying the RVM through a JNI method
invocation.  Note that this preemption mechanism is currently only
implemented on AIX.

On Linux/IA32 Jikes RVM ``hijacks'' certain blocking system calls and
reflects them back into the VM. The VM then uses nonblocking
equivalents. This handles many of the common cases of blocking native
code without requiring the full complexity of the timer-based
preemption mechanism used on AIX. A complete solution would consist of
implementing both mechanisms on both platforms.  We hope to do this in
the future.

\subsection{Implementation Details}
Supporting the combination of blocking native code and m-to-n
threading is inherently complicated.  Unfortunately the Jikes RVM
implementation is further complicated by the fact that too much of the
control logic for Java-to-C and C-to-Java transitions is embedded in
the low-level, platform-specific {VM\_JNICompiler} classes. As a
result the code is very hard to maintain and the JNI implementations
on different platforms have an unfortunate tendency to diverge. 

We have some ideas for a redesign that would enable more of the
control logic to be embodied in shared Java code, but there are a few
minor issues to be worked out. Hopefully this will happen eventually.
