%      $Id$    

\newcommand{\vmInterfacePackageURL}{{\RVMJavadocURL}/memoryManagers/vmInterface/package-frame.html}
\newcommand{\JMTkPackageURL}{{\RVMJavadocURL}/memoryManagers/JMTk/package-frame.html}
\newcommand{\BaseFreeListURL}{{\RVMJavadocURL}/memoryManagers/JMTk/BaseFreeList.html}
\newcommand{\MarkSweepCollectorURL}{{\RVMJavadocURL}/memoryManagers/JMTk/MarkSweepCollector.html}
\newcommand{\BumpPointerURL}{{\RVMJavadocURL}/memoryManagers/JMTk/BumpPointer.html}
\newcommand{\SharedQueueURL}{{\RVMJavadocURL}/memoryManagers/JMTk/SharedQueue.html}
\newcommand{\LocalSSBURL}{{\RVMJavadocURL}/memoryManagers/JMTk/LocalSSB.html}
\newcommand{\BasePlanURL}{{\RVMJavadocURL}/memoryManagers/JMTk/BasePlan.html}
\newcommand{\StopTheWorldGCURL}{{\RVMJavadocURL}/memoryManagers/JMTk/StopTheWorldGC.html}
\newcommand{\GenerationalURL}{{\RVMJavadocURL}/memoryManagers/JMTk/Generational.html}
\newcommand{\VMResourceURL}{{\RVMJavadocURL}/memoryManagers/JMTk/VMResource.html}
\newcommand{\CopyURL}{{\RVMJavadocURL}/memoryManagers/JMTk/Copy.html}
\newcommand{\AddressQueueURL}{{\RVMJavadocURL}/memoryManagers/JMTk/AddressQueue.html}
\newcommand{\MemoryResourceURL}{{\RVMJavadocURL}/memoryManagers/JMTk/MemoryResource.html}
\newcommand{\MonotoneVMResourceURL}{{\RVMJavadocURL}/memoryManagers/JMTk/MonotoneVMResource.html}
\newcommand{\FreeListVMResourceURL}{{\RVMJavadocURL}/memoryManagers/JMTk/FreeListVMResource.html}
\newcommand{\LazyMmapperURL}{{\RVMJavadocURL}/memoryManagers/JMTk/LazyMmapper.html}
\newcommand{\RawPageAllocatorURL}{{\RVMJavadocURL}/memoryManagers/JMTk/RawPageAllocator.html}
\newcommand{\VMInterfaceURL}{{\RVMJavadocURL}/memoryManagers/vmInterface/VM\_Interface.html}
\newcommand{\ScanObjectURL}{{\RVMJavadocURL}/memoryManagers/vmInterface/ScanObject.html}
\newcommand{\ScanStaticsURL}{{\RVMJavadocURL}/memoryManagers/vmInterface/ScanStatics.html}
\newcommand{\ScanThreadURL}{{\RVMJavadocURL}/memoryManagers/vmInterface/ScanThread.html}
\newcommand{\VMGCMapIteratorURL}{{\RVMJavadocURL}/memoryManagers/vmInterface/VM\_GCMapIterator.html}
\newcommand{\VMCollectorThreadURL}{{\RVMJavadocURL}/memoryManagers/vmInterface/VM\_CollectorThread.html}
\newcommand{\VMHandshakeURL}{{\RVMJavadocURL}/memoryManagers/vmInterface/VM\_Handshake.html}

This section provides information on the implementation of JMTk, the
memory management component of Jikes\trademark\ RVM runtime system.

From Jikes RVM 2.2.0 onward, JMTk (Java Memory management
Toolkit) became the default memory management system for Jikes RVM.
JMTk is designed to be a portable toolkit, with Jikes
RVM-specific code factored out as far as possible.

\subsubsection{Directory Structure and Packages} \label{sssec:directories}

JMTk classes are contained in the
\texttt{\$RVM\_ROOT/rvm/src/vm/memoryManagers/JMTk} directory.

In keeping with the goal of modularity and portability, as far as
possible Jikes RVM-specific code is factored out.  Such VM-specific
code resides in a separate package,
(\xlink{\texttt{com.ibm.JikesRVM.memoryManagers.vmInterface}}{\vmInterfacePackageURL}),
and can be found in the \texttt{vmInterface} sub-directory.  All other
code is part of the
\xlink{\texttt{com.ibm.JikesRVM.memoryManagers.JMTk}}{\JMTkPackageURL}
package.

The \texttt{plan} sub-directory contains classes that define
\emph{memory management plans}.  A plan specifies a particular
configuration of JMTk components which together define the memory
management strategy for a particular build of Jikes RVM.  The
\texttt{policy} sub-directory contains classes implementing various
memory management policies (such as \xlink{mark-sweep
    collection}{\MarkSweepCollectorURL}, \xlink{free-list
    allocation}{\BaseFreeListURL}, \xlink{bump-pointer
    allocation}{\BumpPointerURL}, etc.).  The \texttt{utility}
sub-directory contains classes implementing generic utilities (such as
\xlink{load-balancing parallel queues}{\SharedQueueURL},
\xlink{sequential store buffers}{\LocalSSBURL}, etc.).

\subsubsection{Choosing a Garbage Collector} \label{ssec:choosinggc}

Depending on your purposes, you may choose to build Jikes RVM with one
of the following plans:
\begin{itemize}
\item \texttt{SemiSpace} (copying),
\item \texttt{MarkSweep} (non-copying),
\item \texttt{GenCopy} (classic copying generational),
\item \texttt{GenMS} (generational with mark-sweep mature space), or
\item \texttt{CopyMS} (non-generational copy/mark-sweep hybrid)
\item \texttt{NoGC} (allocation only, no garbage collection)
\end{itemize}
The relative performance of these collectors is highly dependent on
the application.  \texttt{GenMS} is probably a good starting point as
it has good performance in a wide range of situations.

All of the memory managers support finalization.  Moreover, a
collection can proceed even when some threads are executing in native
code. When a collection starts, threads in native code are blocked
from returning to Java code for the duration of that collection.

\subsubsection{Plans} \label{sssec:plans}
\index{garbage collection}
\index{stop-the-world garbage collection}

All plans inherit from \xlink{\texttt{BasePlan}}{\BumpPointerURL},
and all plans in this release are ``stop the world'' collectors, so
they all inherit from
\xlink{\texttt{StopTheWorldGC}}{\StopTheWorldGCURL}, which implements
basic stop the world GC functionality.  The two generational
collectors both inherit from
\xlink{\texttt{Generational}}{\GenerationalURL}, which includes
common nursery and write barrier implementations.

All JMTk plans support parallel allocation and collection.  To
minimize synchronization overheads, unsynchronized \emph{thread-local}
actions are distinguished from \emph{global} actions, which must only
be performed by a single thread.  Global state is held in each plan's
class variables, while instance variables reflect thread-local state,
each \texttt{Plan} instance bound to a
\xlink{\texttt{VM\_Processor}}{\VMProcessorURL} instance.

The basic functions of each plan include:
\begin{itemize}
\item Identifying a virtual memory layout (using
  \xlink{\texttt{VMResource}}{\VMResourceURL} to, for example, bind
  a semi-space or the nursery to a particular address range).
\item Providing allocation by binding suitable allocators to different
  \texttt{VMResource}s.
\item Invoking collection when necessary through the use of a
  \emph{polling} mechanism.
\item Applying the appropriate collection policies to objects
  encountered during the collection process (objects may be subject to
  different collection regimens depending on where they reside in
  memory).
\item Implementing read and write barriers if necessary.
\end{itemize}

It is not difficult to add your own memory management plan (allocator
and collector) to JMTk, especially if it uses the same ``stop the
world'' parallel collection strategy used by all the collectors in
this release.  A good way to start is to compare some of the different
plans and understand the significance of the differences.

The basic steps are:

\index{jconfigure script}
\index{VM\_Allocator class}
\begin{enumerate}
\item Create a new directory within the plan subdirectory, such as
  ``NewGC''.
\item Add a new configuration in \texttt{\$RVM\_ROOT/rvm/config/build}
  which includes your new directory in the build.  Name it
  appropriately, such as ``BaseBaseNewGC''.
\item Modify \texttt{\$RVM\_ROOT/rvm/bin/jconfigure} to handle the new
  collector sub-directory.
\item Copy the contents of some existing plan directory into your new
  directory, and modify the files (\texttt{Plan.java} and
  \texttt{Header.java}), choosing a starting point that has similar
  properties, such as copying or non-copying, generational or
  non-generational.
\end{enumerate}

\subsubsection{Policy} \label{sssec:policy}

The \texttt{policy} sub-directory contains implementations of key
memory management policy choices, such as \xlink{bump-pointer
    allocation}{\BumpPointerURL} and \xlink{free-list
    allocation}{\BaseFreeListURL}, \xlink{copying
    collection}{\CopyURL} and \xlink{mark-sweep
  collection}{\MarkSweepCollectorURL}.

\subsubsection{Utility} \label{sssec:utility}

The \texttt{utility} sub-directory contains basic utilities and
mechanisms, including:
\begin{itemize}
\item \xlink{Load-balancing shared parallel
      queues}{\SharedQueueURL}, which provide load balancing queue
  management for \xlink{address queues}{\AddressQueueURL} (used by
  the GC work queue), and \xlink{sequential store
      buffers}{\LocalSSBURL} (used by some write barriers as a
  remembering mechanism).
\item \xlink{Memory resources}{\MemoryResourceURL}, which are the
  mechanism for space \emph{accounting}.  Memory resources are used
  for accounting for all space, including space used by meta data
  (such as queues, etc.).
\item \xlink{Virtual Memory Resources}{\VMResourceURL} (VM
  Resources), which are mechanism for virtual memory \emph{mapping}.
  VM resources are used to associate regions of virtual memory with
  particular policies or needs (such as the nursery of a generational
  collector, or a region of memory where meta data resides, etc), and
  allow multiple allocators to consume each such space. There are a
  number of different VM resources, for \xlink{monotonic
      allocation}{\MonotoneVMResourceURL} (used by bump pointer
  allocators), \xlink{free list allocation}{\FreeListVMResourceURL}
  (used by free list allocators), etc.
\item Low level tools for \xlink{\texttt{mmap}ping}{\LazyMmapperURL}
  memory on demand, and for \xlink{allocating raw
      memory}{\RawPageAllocatorURL} (for use by meta data, for example).
\end{itemize}

\subsubsection{VMInterface} \label{sssec:vminterface}

The \texttt{vmInterface} sub-directory provides the interface between
Jikes RVM and JMTk.  The primary interface is provided by
\xlink{\texttt{VMInterface.java}}{\VMInterfaceURL}.  Key
VM-dependent mechanisms include:

\begin{itemize}
\item \xlink{Object}{\ScanObjectURL},
  \xlink{statics}{\ScanStaticsURL}, and
  \xlink{thread}{\ScanThreadURL} scanning,
\item \xlink{GC map iteration}{\VMGCMapIteratorURL}, and
\item GC \xlink{initiation}{\VMCollectorThreadURL} and \xlink{synchronization}{\VMHandshakeURL}.
\end{itemize}

