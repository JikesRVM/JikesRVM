This section provides some explanation of how Java\trademark threads are
scheduled and synchronized by the RVM.

\index{threads}
\index{scheduling}
\index{locking}

All Java threads (application threads, garbage collector threads, {\em
etc.})  derive from 
\xlink{{\tt VM\_Thread}}{\VMThreadURL}.  
These threads are multiplexed by
one or more virtual processors (see 
\xlink{{\tt VM\_Processor}}{\VMProcessorURL}
).  Normally, the
number of RVM virtual processors to use is a command line argument
(e.g. {\tt -X:processors=4}) Generally, there should be one RVM
virtual processor for each CPU on an SMP.  Additional virtual
processors may be created to handle threads executing non Java code
through the Java JNI.  Multiple virtual processors require a working
pThread library, each virtual processor being bound to a pThread.  It
is possible to build a system that only uses one virtual processor by
setting the preprocessor directive {\tt
JVM\_WITH\_SINGLE\_VIRTUAL\_PROCESSOR} to 1.  This may give a minor
performance benefit on uniprocessors.

Threads that are not executing are either placed on thead queues
(deriving from 
\xlink{{\tt VM\_AbstractThreadQueue}}{\VMAbstractThreadQueueURL}
) or are proxied (see below).
Thread queues are either global or (virtual) processor local.  The
latter do not require synchronized access but global queues do.
Unfortunately, we did not see how to use Java monitors to provide
this synchronization.  (In part, because it is needed to implement
monitors, see below.)  Instead this low-level synchronization is
provided by 
\xlink{{\tt VM\_ProcessorLock}}{\VMProcessorLockURL}s.

Transferring execution from one thread (A) to another (B) is a complex
operation negotiated by the {\tt yield} and {\tt morph} methods of
VM\_Thread and the {\tt dispatch} method of VM\_Processor.  {\tt
yield} places A on an indicated queue (releasing the lock on the
queue, if it is global).  {\tt morph} uses 
\xlink{{\tt VM\_Magic}}{\VMMagicURL} 
to capture the
state of the running thread and transfers control to {\tt dispatch}.
At this point, the virtual processor is executing in {\em phantom
mode}, it is using A's stack, but not in a way that will be visible to
A when it next gets executed.  {\tt dispatch} removes B from a queue
of executable threads and, using more VM\_Magic, transfers control
to B's stack.  (To B, it looks as if {\em its} call to {\tt dispatch}
has just returned.)  To prevent a different processor from dispatching
A while it is still executing in phantom mode, {\tt yield} sets the
{\tt beingDispatched} field of A, which is only reset by the magic
that transfers control to B.

Currently, RVM has no priority mechanism, that is, all threads run
at the same priority.

Similarly, it has only the most rudimentary load balancing mechanism.
Each virtual processor has a (local) idle queue.  Normally, the
processor's \xlink{{\tt VM\_IdleThread}}{\VMIdleThreadURL} inhabits
this queue.  When no other thread is executable, this thread is
executed.  This thread requests work by setting the static {\tt
idleProcessor} field to its virtual processor.  (When {\tt dispatch}
is looking for a runnable thread it checks that this field is null.
If not, and it has an spare runnable thread, it places the spare
thread on the idle processor's transfer queue.)  The idle thread then
spins for a short period of time waiting for work to materialize.  If
it does, the idle thread returns to its processor's idle queue and
the processor resumes execution of the newly transferred thread.
Otherwise, the idle thread surrenders the remainder of its virtual
processor's time slice back to the operating system.

More sophisticated priority and load-balancing mechanisms are in
order.

RVM uses a light-weight locking scheme to implement Java monitors (see
\xlink{{\tt VM\_Lock}}{\VMLockURL}).  Twenty bits of the status word of 
the object header are used for locking.  If the top bit is set, the
bottom nineteen are an index into an array of heavy-weight locks.
Otherwise, if the object is locked, these bits contain the id of the
thread that holds the lock and a count of how many times it is held.
If a thread tries to lock an object locked with a light-weight lock by
another thread, it can spin, yield, or inflate the lock.  Spinning is
probably a bad idea.  The number of times to yield before inflating is
a matter open for investigation (as are a number of locking
issues, see {\tt VM\_Lock}).  Heavy-weight locks contain an {\tt
enteringQueue} for threads trying to acquire the lock.

A similar mechanism is used to implement Java wait/notification
semantics.  Heavy-weight locks contain a {\tt waitingQueue} for
threads blocked at a Java {\tt wait}.  When a {\tt notify} is
received, a thread is taken from this queue and transferred to a ready
queue.  Priority {\tt wakeupQueue}s are used to implement Java sleep
semantics.  Logically, Java timed-wait semantics entail placing a
thread on both a {\tt waitingQueue} and a {\tt wakeupQueue}.  However, our
implementation only allows a thread to be on one thread queue at
a time.  To accommodate timed-waits, both {\tt waitingQueue}s and
{\tt wakeupQueue}s are queues of {\em proxies} rather than threads.
A \xlink{{\tt VM\_Proxy}}{\VMProxyURL} can represent the same thread
on more than one proxy queue.

\JavaTMFooter