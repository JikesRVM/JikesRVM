This section provides some explanation of how Java\trademark threads are
scheduled and synchronized by the RVM.

\index{threads}
\index{scheduling}
\index{locking}

All Java threads (application threads, garbage collector threads, {\em
etc.})  derive from 
\xlink{{\tt VM\_Thread}}{\VMThreadURL}.  
These threads are multiplexed by
one or more virtual processors (see 
\xlink{{\tt VM\_Processor}}{\VMProcessorURL}
).  Normally, the
number of RVM virtual processors to use is a command line argument
(e.g. {\tt -X:processors=4}) Generally, there should be one RVM
virtual processor for each CPU on an SMP.  Additional virtual
processors may be created to handle threads executing non Java code
through the Java JNI.  Multiple virtual processors require a working
pThread library, each virtual processor being bound to a pThread.  It
is possible to build a system that only uses one virtual processor by
setting the preprocessor directive {\tt
JVM\_WITH\_SINGLE\_VIRTUAL\_PROCESSOR} to 1.  This may give a minor
performance benefit on uniprocessors.

Threads that are not executing are either placed on thead queues
(deriving from 
\xlink{{\tt VM\_AbstractThreadQueue}}{\VMAbstractThreadQueueURL}
) or are proxied (see below).
Thread queues are either global or (virtual) processor local.  The
latter do not require synchronized access but global queues do.
Unfortunately, we did not see how to use Java monitors to provide
this synchronization.  (In part, because it is needed to implement
monitors, see below.)  Instead this low-level synchronization is
provided by 
\xlink{{\tt VM\_ProcessorLock}}{\VMProcessorLockURL}s.

Transferring execution from one thread (A) to another (B) is a complex
operation negotiated by the {\tt yield} and {\tt morph} methods of
VM\_Thread and the {\tt dispatch} method of VM\_Processor.  {\tt
yield} places A on an indicated queue (releasing the lock on the
queue, if it is global).  {\tt morph} uses 
\xlink{{\tt VM\_Magic}}{\VMMagicURL} 
to capture the
state of the running thread and transfers control to {\tt dispatch}.
At this point, the virtual processor is executing in {\em phantom
mode}, it is using A's stack, but not in a way that will be visible to
A when it next gets executed.  {\tt dispatch} removes B from a queue
of executable threads and, using more VM\_Magic, transfers control
to B's stack.  (To B, it looks as if {\em its} call to {\tt dispatch}
has just returned.)  To prevent a different processor from dispatching
A while it is still executing in phantom mode, {\tt yield} sets the
{\tt beingDispatched} field of A, which is only reset by the magic
that transfers control to B.

Beginning with version 2.0.1, the RVM has a simple load balancing
mechanism. Every once in a while, a thread will move from one virtual
processor to the next.  Such movement happens when a thread is
interrupted by a timer tick (or garbage collection) or when it comes
off a global queue (such as, the queues waiting for a heavy-weight
lock, see \xlink{{\tt VM\_Lock}}{\VMLockURL}).  Such migration will be
inhibited if the thread is the last (non-idle) executable thread on
its current virtual processor.  

If a virtual processor has no other executable thread, its idle thread
runs.  This thread posts a request for work and then busy-waits for a
short time (currently 0.001 seconds).  If no work arrives in that
period, the virtual processor surrenders the rest of its time slice
back to the operating system.  If another virtual processor notices
that this one needs work, it will tranfer an extra runnable thread (if
it has one) to this processor.  When work arrives, the idle thread
yields to an idle queue, and the recently transferred thread begins
execution.

Currently, RVM has no priority mechanism, that is, all threads run at
the same priority.

If the RVM detects that a thread is stuck executing native code (JNI)
for a long time, it temporarily prevents it from returning to Java and
creates a new pThread (or recycles one previously created for this 
purpose) and transfers the stuck thread's virtual processor to the
new pThread.  When the stuck thread returns to Java, the pThread
executing it is deactivated and added to a pool of available pThreads.
Currently, this mechanism does not work on Linux (possibly due to a
bug in the Linux 2.4 pThread library) and is disabled there.

RVM uses a light-weight locking scheme to implement Java monitors (see
\xlink{{\tt VM\_Lock}}{\VMLockURL}).  Twenty bits of the status word of 
the object header are used for locking.  If the top bit is set, the
bottom nineteen are an index into an array of heavy-weight locks.
Otherwise, if the object is locked, these bits contain the id of the
thread that holds the lock and a count of how many times it is held.
If a thread tries to lock an object locked with a light-weight lock by
another thread, it can spin, yield, or inflate the lock.  Spinning is
probably a bad idea.  The number of times to yield before inflating is
a matter open for investigation (as are a number of locking
issues, see {\tt VM\_Lock}).  Heavy-weight locks contain an {\tt
enteringQueue} for threads trying to acquire the lock.

A similar mechanism is used to implement Java wait/notification
semantics.  Heavy-weight locks contain a {\tt waitingQueue} for
threads blocked at a Java {\tt wait}.  When a {\tt notify} is
received, a thread is taken from this queue and transferred to a ready
queue.  Priority {\tt wakeupQueue}s are used to implement Java sleep
semantics.  Logically, Java timed-wait semantics entail placing a
thread on both a {\tt waitingQueue} and a {\tt wakeupQueue}.  However, our
implementation only allows a thread to be on one thread queue at
a time.  To accommodate timed-waits, both {\tt waitingQueue}s and
{\tt wakeupQueue}s are queues of {\em proxies} rather than threads.
A \xlink{{\tt VM\_Proxy}}{\VMProxyURL} can represent the same thread
on more than one proxy queue.

\JavaTMFooter