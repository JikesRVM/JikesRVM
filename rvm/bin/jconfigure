#! /bin/bash
#
# (C) Copyright IBM Corp. 2001, 2003
#
#$Id$
#
# Generate control files necessary to build a particular "configuration"
# of the Research Virtual Machine.
#
# See the usage message below, in section 1, the def. of function 
# help_message.  It gives much more information than is in this header comment.
#
# This script is organized into seven sections:
#    0 - Setup
#    1 - Documentation
#    2 - Definitions of constants
#    3 - Process RVM_TARGET_CONFIG
#    4 - ARGUMENT PARSING
#    5 - Definitions of functions
#    6 - Mainline Code that does the work
#
# @author Derek Lieber
# @date   19 Jan 2000
# @author Steven Augart (Bash version)
# @date 17 May 2003

## Exit statuses:

## We exit with status 0 upon success, as is conventional.
## In case of trouble, we exit with the triggering exit status (if invoked via 'set -e'.
## Exit status 33: Invalid arguments.
declare -i Exit_Status_Bad_Args=33
## Exit status 2: trouble (configuration, etc.)
## Exit status 1: misc. complaints.
##
## Exit status 111: The master "jbuild" script (generated by jconfigure) uses
## exit status "111" to mean that it has gone as far as it could with a
## cross-platform build, and that the target itself now needs to 
## run the linker.
declare -i Exit_Status_Run_Linker=111

#----------------------#
# SECTION 0 - Setup    #
#----------------------#

# What is our name?
# Bash internal shorthand that works like the "basename" command.
ME="${0##*/}"

# Where are we?
# Bash internal shorthand that works like the "dirname" command.
mydir="${0%/*}"			# temporary; directory we were run from

if [[ $mydir && $mydir != $ME ]]; then
    # Where to find auxiliary programs:
    bin_dir="${mydir}"
else
    bin_dir="${RVM_ROOT:?$ME: You must set the RVM_ROOT variable before you run this program.}/rvm/bin"
fi

# Stop immediately if any programs we call return errors.
#
## Check if the command does not support the ERR trap.
CLEANUP=":"
unset xited || :
if trap -- 'xited=$? finalarg=$_; set +vx; echo >&2 "$ME: some command we just ran (probably with a
      final argument of \"$finalarg\") exited with status $xited, possibly in source
      file line # $LINENO ${FUNCNAME+'"'"'and function '"'"'}$FUNCNAME
      I give up; aborting execution."; trap "echo >&2 \"Exiting due to an error\"" EXIT; eval $CLEANUP' ERR
then
    have_err_trap=yes
else
    echo >&2 "$ME: You are under a version of Bash 
    ($BASH_VERSION; probably pre-2.05) that
    does not support
    the ERR trap.  You may not get as much diagnostic info as you would like."
    unset have_err_trap || :
fi

trap -- 'echo >&2 "$ME: We are exiting due to an error; the triggering exit status was ${xited:-$?}.
   possibly in source file line # $LINENO and function $FUNCNAME
"; eval $CLEANUP' EXIT
set -e;

function croak_nonusage () {
    # Display the error message.  If it's a multi-line error message, indent
    # the second and subsequent lines by a few spaces.  
    # Try to auto-wrap the message if we have GNU Fold.

    local gnufold="/usr/bin/fold --width=65 --spaces"
    $gnufold < /dev/null &> /dev/null || gnufold=cat

    echo "${ME}: $*" | $gnufold | sed -e '2,$s/^/     /' >&2
    trap '' EXIT
    exit 2
}

sanity_env="${bin_dir}/sanity-envars.bash"
[[ -f $sanity_env ]] || croak_nonusage "Internal error: Cannot find the file sanity-envars.bash ($sanity_env); something is badly broken."
[[ -r $sanity_env ]] || croak_nonusage "Internal error: Cannot read the file sanity-envars.bash ($sanity_env); something is badly broken.  You might check the file permissions or user id you used to extract Jikes RVM."
. "${sanity_env}";		# Defines checkenv()

## Place where source files reside.
checkenv RVM_ROOT

## Place where RVM bootimage, booter, and runtime support files will be placed.
checkenv --may-not-exist RVM_BUILD
## What configuration will host the build process?
checkenv RVM_HOST_CONFIG
## What configuration will run the system?
checkenv RVM_TARGET_CONFIG

#---------------------------#
# SECTION 1 - DOCUMENTATION #
#---------------------------#

function help_message () {

    # If PAGER is not set, set it to "more".
    ${PAGER=more} <<- EOF
	Usage: ${ME} [-nocleanse | -cleanse ] [-quiet]
		[-D <variable>=<value>]... <configuration-name>
	Usage: ${ME} -help

	This script generates control files necessary to build a particular
	"configuration" of the Research Virtual Machine.
	
	Normally it is invoked as:
	
	   $ME <configuration-name>
	
	Where <configuration-name> indicates the configuration to be
	created and an environment variable, \$RVM_BUILD, specifies a
	directory where files comprising the configuration are to be
	placed.
	
	You can invoke this script as "${ME} < /dev/null" in order to
	suppress interactive questions.

	This script creates the \$RVM_BUILD directory and populates it with
	a skeleton directory structure along with some scripts and control
	files.

	After running this script, you can build an RVM executable by typing:
	
	    cd \$RVM_BUILD
	    ./jbuild
	
	Your \$RVM_ROOT tree will be template-expanded, macro-processed,
	compiled, and linked into a bootimage.  The processed sources,
	class files, bootimage, and booter will be placed into the
	\$RVM_BUILD directory.
	
	To execute the resulting bootimage (from any directory), type:
	
	   rvm <vm-flags> classname <application-args>
	
	Later, if you make changes to your \$RVM_ROOT tree, type "jbuild"
	again.  Modified source files will be discovered, copied to the
	build directory, recompiled, and the bootimage will be rebuilt.
	
	Special Cases
	=============
	
	To avoid unnecessarily rebuilding the bootimage (when, for example,
	you've only modified classes that are dynamically loaded and which
	are not part of the bootimage) type "jbuild -nolink".
	
	To avoid building the booter (when, for example, running on the AIX
	side of an AIX/Linux cross-compilation) type "jbuild -nobooter".
	
	To build only the booter (when, for example, running on Linux side
	of a cross-port to Linux) type "jbuild -booter".
	
	To force recompilation of all classes (when, for example, you've
	modified a global constant or have added/removed fields/methods
	from a class) type "jbuild -recompile".
	
	To monitor the build process in more detail type "jbuild -trace".
	"jbuild -help" will print the suboptions to "-trace".
	
	To restore the build directory to its original "unbuilt" state type
	"jbuild -clean".
	
	EOF
}
   
#--------------------------------------#
# SECTION 2 - DEFINITIONS OF CONSTANTS #
#--------------------------------------#


# The places to put scripts and control files. 

# (The *_STR variants of these variables have their variables expanded
# when the emitted script is executed, rather than being expanded prior to
# emitting the script.  This gives the scripts a degree of location
# transparency.  The _STR1 variables are similar to the _STR variables, 
# but are used to produce the localization script.  They lack the '$' )

BUILD_DIRECTORY="$RVM_BUILD"
BUILD_DIRECTORY_STR1="JAL_BUILD"
BUILD_DIRECTORY_STR="\$$BUILD_DIRECTORY_STR1"

ROOT_DIRECTORY="$RVM_ROOT"
ROOT_DIRECTORY_STR1="JAL_ROOT"
ROOT_DIRECTORY_STR="\$$ROOT_DIRECTORY_STR1"

# source path for configuration files 
# eg, BaseBaseSemispace
#
CONFIGURATION_FILE_SOURCE="$ROOT_DIRECTORY/rvm/config/build"

# Place to remember what configuration we've built.
#
CONFIGURATION_SUMMARY="$BUILD_DIRECTORY/RVM.configuration"

# Place to keep list of source directories to be scanned by preprocessor.
#
SOURCE_LIST="$BUILD_DIRECTORY/RVM.sources"
SOURCE_LIST_STR="$BUILD_DIRECTORY_STR/RVM.sources"

# Place to remember, if a cleansing pass should precede the build.
#
CLEANSE_STATUS="${BUILD_DIRECTORY}/RVM.cleanseRequired"
CLEANSE_STATUS_STR="${BUILD_DIRECTORY_STR}/RVM.cleanseRequired"

# Place to remember if preprocessor has yielded new/modified source files.
#
CLASSES_INVALID="${BUILD_DIRECTORY}/RVM.classesInvalid"
CLASSES_INVALID_STR="${BUILD_DIRECTORY_STR}/RVM.classesInvalid"

# Place to put preprocessed .java files and compiled .class files.
#
CLASSES_DIRECTORY="${BUILD_DIRECTORY}/RVM.classes"
CLASSES_DIRECTORY_STR="${BUILD_DIRECTORY_STR}/RVM.classes"

# Place to put source files that are machine generated.
#
GENERATED_FILES_DIRECTORY="${BUILD_DIRECTORY}/RVM.generatedSources"
GENERATED_FILES_DIRECTORY_STR="${BUILD_DIRECTORY_STR}/RVM.generatedSources"
   
# Place to put compiled versions of build tools and other glop
# generated during the build process.
#
SCRATCH_DIRECTORY="${BUILD_DIRECTORY}/RVM.scratch"
SCRATCH_DIRECTORY_STR="${BUILD_DIRECTORY_STR}/RVM.scratch"

# Place to put the debugger, and other such tools.
#
TOOL_DIRECTORY="${BUILD_DIRECTORY}/RVM.tools"
TOOL_DIRECTORY_STR="${BUILD_DIRECTORY_STR}/RVM.tools"

# Place to keep list of classes comprising the bootimage.
#
PRIMORDIAL_CLASSES="${BUILD_DIRECTORY}/RVM.primordials"
PRIMORDIAL_CLASSES_STR="${BUILD_DIRECTORY_STR}/RVM.primordials"

# Place to keep list of .class files to be excluded from bootimage.
#
EXCLUDED_CLASSES="${BUILD_DIRECTORY}/RVM.exclusions"
EXCLUDED_CLASSES_STR="${BUILD_DIRECTORY_STR}/RVM.exclusions"

# Place to put bootimage.
#
BOOTIMAGE="${BUILD_DIRECTORY}/RVM.image"
BOOTIMAGE_STR="${BUILD_DIRECTORY_STR}/RVM.image"

# Place to put bootimage map.
#
BOOTIMAGE_MAP=${BUILD_DIRECTORY}/RVM.map
BOOTIMAGE_MAP_STR=${BUILD_DIRECTORY_STR}/RVM.map

# Place to put booter.
#
BOOTER=${BUILD_DIRECTORY}/JikesRVM
BOOTER_STR=${BUILD_DIRECTORY_STR}/JikesRVM

# Variables to allow configuration files to alter the list of
# directories, primordials, exclusions and top level sources.
#
CONF_SPECIFIC_SOURCES_LIST=""
CONF_SPECIFIC_PRIMORDIALS_LIST=""
CONF_SPECIFIC_EXCLUSIONS_LIST=""
CONF_SPECIFIC_TOP_LEVEL_SOURCES=""

# Strings to use in the scripts as the locations of various commands.
#
HOST_JIKES_STR1="HOST_JIKES"
HOST_JIKES_STR="\$$HOST_JIKES_STR1"
HOST_JAVA_STR1="HOST_JAVA_RT"
HOST_JAVA_STR="\$$HOST_JAVA_STR1"
HOST_JAVAC_STR1="HOST_JAVAC"
HOST_JAVAC_STR="\$$HOST_JAVAC_STR1"
HOST_JAVA_HOME_STR1="HOST_JAVA_HOME"
HOST_JAVA_HOME="\$$HOST_JAVA_HOME_STR1"
HOST_JAVADOC_STR1="HOST_JAVADOC"
HOST_JAVADOC_STR="\$$HOST_JAVADOC_STR1"
HOST_JAR_STR1="HOST_JAR"
HOST_JAR_STR="\$$HOST_JAR_STR1"
HOST_REPOSITORIES_STR1="HOST_JAVA_REPOSITORIES"
HOST_REPOSITORIES_STR="\$$HOST_REPOSITORIES_STR1"
HOST_TOOLS_STR1="HOST_JAVA_TOOLS"
HOST_TOOLS_STR="\$$HOST_TOOLS_STR1"
GNU_MAKE_STR1="GNU_MAKE"
GNU_MAKE_STR="\$$GNU_MAKE_STR1"
HOST_CC_STR1="CC"
HOST_CC_STR="\$$HOST_CC_STR1"
HOST_CPP_STR1="CPP"
HOST_CPP_STR="\$$HOST_CPP_STR1"
HOST_CPLUS_STR1="CPLUS"
HOST_CPLUS_STR="\$$HOST_CPLUS_STR1"
HOST_SHLD_STR1="HOST_SHLD"
HOST_SHLD_STR="\$$HOST_SHLD_STR1"

# Generate map of bootimage?
#
declare -x -i GENERATE_MAP=1

# Current version of RVM
JIKESRVM_VERSION="Jikes Research VM for Java post 2.2.2 (CVS head)"

# Default values for RunBootImage constants.
# Reasonable default values.
# To change the defaults for a paricular configuration, 
# redefine appropriate environment variables in the configuration's stanza.
#
DEFAULT_INITIAL_HEAP_SIZE=20   # in megabytes
DEFAULT_MAXIMUM_HEAP_SIZE=100  # in megabytes

# Here are the choices for target architecture.
#
declare -i RVM_FOR_POWERPC=0  # does not imply aix, nor Linux
declare -i RVM_FOR_IA32=0     # also implies linux

# Here are the choices for target operating system.
#
declare -i RVM_FOR_AIX=0	   # Implies PPC
declare -i RVM_FOR_LINUX=0	   # Implies nothing.

# 32-bit or 64-bit address size
#
declare -i RVM_FOR_32_ADDR=0
declare -i RVM_FOR_64_ADDR=0
 
# Here are the choices for compiler components and extensions.
# Note: baseline compiler is always built into bootimage: its presence is not controlled by any flags.
#
declare -i RVM_WITH_OPT_COMPILER=0
declare -i RVM_WITH_ADAPTIVE_SYSTEM=0 # superset of opt
declare -i RVM_WITH_OPT_TEST_HARNESS=0  # superset of opt, for test/debug via OptTestHarness class

# Include support for hardware performance monitors (HPM)
declare -i RVM_WITH_HPM=0

declare -x -i RVM_WITH_NON_BLOCKING_FDS_FOR_CLASSPATH=0

# Here are the choices for compiler to generate code for classes that are loaded into bootimage.
#
declare -i RVM_WITH_BASE_BOOTIMAGE_COMPILER=0
declare -i RVM_WITH_OPT_BOOTIMAGE_COMPILER=0

# Here are the choices for the object model
#
declare -i RVM_WITH_DEFAULT_OBJECT_MODEL=1
declare -i RVM_WITH_ONE_WORD_MASK_OBJECT_MODEL=0
declare -i RVM_WITH_ONE_WORD_PTR_OBJECT_MODEL=0
declare -i RVM_WITH_ONE_WORD_INDEX_OBJECT_MODEL=0

# Here are the choices for additional components that are under development and/or are excluded from default build.
#
declare -i RVM_FOR_SINGLE_VIRTUAL_PROCESSOR=0   # use pThread library to access multiple CPU's (or not)
declare -i RVM_WITH_DETERMINISTIC_THREAD_SWITCHING=0 # thread switch after n method calls, don't use interrupts to drive preemption
declare -i RVM_WITHOUT_PREEMPTIVE_THREAD_SWITCHING=0 # thread switch only at explicit yield and wait calls
declare -i RVM_WITH_ALL_CLASSES=0   # include all vm classes in bootimage, not just those needed for startup
declare -i RVM_WITHOUT_ASSERTIONS=0 # exclude runtime assertion checks
declare -i RVM_WITH_EXTREME_ASSERTIONS=0 # include extra assertion checking 
declare -i RVM_WITHOUT_AOS_LOG=0    # turn off AOS logging
declare -i RVM_WITH_NATIVE_DAEMON_PROCESSOR=0

#
# intercept blocking system calls (currently Linux-only)
#
declare -x -i RVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS=0

# controls for diagnostic flags
declare -i RVM_FOR_STRESSGC=0

# using on stack replacement 
declare -i RVM_WITH_OSR=0


# These have preprocessor "//-#if" conditional directives that 
# test against them.   If we put the preprocessor into paranoid mode, it
# complains about any tests against undefined conditionals.
# Search for "BUILD_WITH_PARANOID_PREPROCESSOR" below and way below.
declare -i RVM_WITHOUT_LOAD_BALANCING=0	# default in VM_IdleThread.java
declare -i RVM_WITH_FREE_LOCK_BALANCING=0	# In VM_Lock.java
declare -i RVM_WITH_TENTATIVE_MICROLOCKING=0	
declare -i RVM_FOR_MCS_PROCESSOR_LOCKS=0
declare -i RVM_WITH_VARIABLE_LOCK_RETRY_LIMIT=0
declare -i RVM_WITH_LOCK_CONTENTION_TRACING=0
declare -i RVM_WITH_DEBUG=0

## Just affects the build process
declare -i BUILD_WITH_PARANOID_PREPROCESSOR=0

#---------------------------------------#
# SECTION 3 - PROCESS RVM_TARGET_CONFIG # 
#---------------------------------------#
# One use of the target_config file is to define
# directives that hold for all configurations 
# defined on the target. By sourcing it here,
# we define such directives for all configs on the target,
# but still allow them to be overridden on the command line
# or in a build-config file.
. "${RVM_TARGET_CONFIG}"


#--------------------------------------#
# SECTION 4 - ARGUMENT PARSING         #
#--------------------------------------#

function croak_usage () {
    # Display the error message.  If it's a multi-line error message, indent
    # the second and subsequent lines by a few spaces.
    echo "${ME}: $*" | sed -e '2,$s/^/     /' >&2
    echo >&2 "${ME}: Type \"${ME} -help\" for usage information."
    trap '' EXIT
    exit $Exit_Status_Bad_Args
}

declare -i quiet=0 cleanse=1
while :
do
    case "$1" in 
	-help|--help ) 
	    help_message;
	    trap '' EXIT
	    exit 0; ;;
	-D )
 	    shift
	    eval "export $1";;
	
	-quiet|--quiet ) 
	    quiet=1;;

	-cleanse|--cleanse ) 
	    cleanse=1;;

	-nocleanse|--nocleanse ) 
	    cleanse=0;;

	-*)  croak_usage "I don't understand the flag \"$1\""
	    ;;

	--) shift;
	    break;
	    ;;
	* ) break;;
    esac

    shift
done

(( $# >= 1 )) || croak_usage "Please specify <configuration-name>"
CONFIGURATION_NAME="$1"
shift

(( $# == 0 )) || croak_usage "Too many arguments; specify only one <configuration-name>."


if [[ -f "${CONFIGURATION_FILE_SOURCE}/${CONFIGURATION_NAME}" ]]; then
    . "${CONFIGURATION_FILE_SOURCE}/${CONFIGURATION_NAME}" "${CONFIGURATION_FILE_SOURCE}"
else
    croak_usage "Unknown configuration ${CONFIGURATION_NAME}"
fi

# set the relative path to the object model.
if (( RVM_WITH_ONE_WORD_MASK_OBJECT_MODEL )); then
    OBJECT_MODEL_PATH_STR=objectModel/oneWordMaskTIB
elif (( RVM_WITH_ONE_WORD_PTR_OBJECT_MODEL )); then
    OBJECT_MODEL_PATH_STR=objectModel/oneWordTIBPtr
elif (( RVM_WITH_ONE_WORD_INDEX_OBJECT_MODEL )); then
    OBJECT_MODEL_PATH_STR=objectModel/oneWordIndexTIB
else
    OBJECT_MODEL_PATH_STR=objectModel/default
fi


if (( RVM_FOR_AIX || RVM_FOR_SINGLE_VIRTUAL_PROCESSOR == 1 )); then
    RVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS=1
fi

## Setting PREPROCESSOR_DEFINITIONS:
## We keep this variable with a newline-separated list of definitions.
# Convert configuration choices into preprocessor definitions.
#    RVM_FOR_xxx  --> -DRVM_FOR_xxx
#    RVM_WITH_xxx --> -DRVM_WITH_xxx
#    RVM_WITHOUT_xxx --> -DRVM_WITH_xxx
#
## To find out which programmable conditions are still alive (i.e., which ones
## are currently in use in the program source code), look at 
## rvm/GNUmakefile, the 'conditionals' target.  
## The BUILD_WITH_PARANOID_PREPROCESSOR directive affects this.
PREPROCESSOR_DEFINITIONS="-DBOOTIMAGE_LOAD_ADDRESS=${BOOTIMAGE_LOAD_ADDRESS}"
PREPROCESSOR_DEFINITIONS="${PREPROCESSOR_DEFINITIONS}
-DMAXIMUM_MAPPABLE_ADDRESS=${MAXIMUM_MAPPABLE_ADDRESS}"
CLEANUP='/bin/rm -f $tmpf'	# used by EXIT trap.
tmpf=/tmp/jconfigure.$$
set | sed -n -e 's/^RVM_FOR_/-DRVM_FOR_/p' \
		-e 's/^RVM_WITH_/-DRVM_WITH_/p'			\
		-e 's/RVM_WITHOUT_/-DRVM_WITHOUT_/p' > $tmpf
if (( BUILD_WITH_PARANOID_PREPROCESSOR )); then
    from_vars="$(< $tmpf)"
else
    ## To cut down on the number of definitions that appear in our generated
    ## code, if we are not compiling with the paranoid preprocessor flags 
    ## enabled, we can remove all of the ones which just set to 
    ## the default value (zero) 
    from_vars="$(sed -e '/=0/d' $tmpf)"
fi
eval $CLEANUP
# rm -f $tmpf
CLEANUP=":"
# echo "from_vars are $from_vars"
PREPROCESSOR_DEFINITIONS="${PREPROCESSOR_DEFINITIONS}
${from_vars}"
unset from_vars
# Place where bootimage runner lives.
#
if (( RVM_FOR_POWERPC )); then
    BOOTIMAGE_RUNNER_DIR="${RVM_ROOT}/rvm/src/tools/bootImageRunner"
    BOOTIMAGE_RUNNER_DIR_STR="${ROOT_DIRECTORY_STR}/rvm/src/tools/bootImageRunner"
    BOOTIMAGE_RUNNER_SUBDIR="${RVM_ROOT}/rvm/src/tools/bootImageRunner/powerPC"
    BOOTIMAGE_RUNNER_SUBDIR_STR="${ROOT_DIRECTORY_STR}/rvm/src/tools/bootImageRunner/powerPC"
elif (( RVM_FOR_IA32 )); then
    BOOTIMAGE_RUNNER_DIR="${RVM_ROOT}/rvm/src/tools/bootImageRunner"
    BOOTIMAGE_RUNNER_DIR_STR="${ROOT_DIRECTORY_STR}/rvm/src/tools/bootImageRunner"
    BOOTIMAGE_RUNNER_SUBDIR="${RVM_ROOT}/rvm/src/tools/bootImageRunner/IA32"
    BOOTIMAGE_RUNNER_SUBDIR_STR="${ROOT_DIRECTORY_STR}/rvm/src/tools/bootImageRunner/IA32"
else
    echo >&2 "$ME: Trouble is looming; neither RVM_FOR_POWERPC nor RVM_FOR_IA32 is defined."
    BOOTIMAGE_RUNNER_DIR="UNKNOWN_BOOTIMAGE_RUNNER_DIRECTORY"
    BOOTIMAGE_RUNNER_DIR_STR="UNKNOWN_BOOTIMAGE_RUNNER_DIRECTORY"
fi

# Place where bootimage writer lives.
#
BOOTIMAGE_WRITER_DIR="${RVM_ROOT}/rvm/src/tools/bootImageWriter"
BOOTIMAGE_WRITER_DIR_STR="${ROOT_DIRECTORY_STR}/rvm/src/tools/bootImageWriter"

#--------------------------------------#
# SECTION 5 - DEFINITIONS OF FUNCTIONS #
#--------------------------------------#

# Check configuration options for sanity.
function checkConfigurationOptions {
    if (( ! RVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS )) \
	&& (( RVM_WITH_NATIVE_DAEMON_PROCESSOR ))
    then
	croak_nonusage "\
If RVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS is not specified,\
then RVM_WITH_NATIVE_DAEMON_PROCESSOR must not be specified";
    fi
}

# Emit list of source tree directories whose java files comprise the current configuration.
#
function emitSourceList () {
    if (( RVM_FOR_POWERPC )); then
	ARCH_DIR="powerPC"
    elif (( RVM_FOR_IA32 )); then
	ARCH_DIR="intel"
    else
	ARCH_DIR="UNSPECIFIED_ARCHITECTURE"
    fi
   
    # Common components.
    #
    echo $RVM_ROOT/rvm/src/vm
    echo $RVM_ROOT/rvm/src/vm/arch/$ARCH_DIR
    echo $RVM_ROOT/rvm/src/vm/arch/$ARCH_DIR/runtime
    echo $RVM_ROOT/rvm/src/vm/classLoader
    echo $RVM_ROOT/rvm/src/vm/jni
    echo $RVM_ROOT/rvm/src/vm/runtime
    echo $RVM_ROOT/rvm/src/vm/scheduler
    echo $RVM_ROOT/rvm/src/vm/utility
    echo $RVM_ROOT/rvm/src/vm/verifier
    echo $RVM_ROOT/rvm/src/vm/compilers/compiledCode
    

    echo $RVM_ROOT/rvm/src/vm/arch/$ARCH_DIR/jni

    # Baseline compiler components (always part of bootimage).
    #
    echo ${RVM_ROOT}/rvm/src/vm/compilers/baseline           # architecture independent
    echo ${RVM_ROOT}/rvm/src/vm/compilers/baseline/GCMap     # architecture independent
    echo ${RVM_ROOT}/rvm/src/vm/compilers/baseline/profiling # architecture independent
    echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/baseline    # architecture dependent
    echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/baseline/GCMap
    if [[ -e ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/assembler ]]; then
	echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/assembler # architecture dependent
    fi
    
    echo ${RVM_ROOT}/rvm/src/vm/objectModel
    echo ${RVM_ROOT}/rvm/src/vm/objectModel/lockNursery
    echo ${RVM_ROOT}/rvm/src/vm/${OBJECT_MODEL_PATH_STR}

    # other components
    #
    echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/disassembler

    # Optimizing compiler components.
    #
    if (( RVM_WITH_OPT_COMPILER )); then
	# core components
	#
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/driver
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/instrumentation
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/cfg
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/conversions/bc2hir
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/conversions/hir2lir
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/conversions/lir2mir
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/conversions/mir2mc
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/gcmap
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/instruction
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/instruction/operand
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/util
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/control
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/control/dominators
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/coalesce
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/liveness
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/liveRangeSplitting
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/simpleSSA
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/simpleSSA/escape
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/abcd
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/builder
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/codePlacement
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/expressionFolding
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/gvn
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/loadElimination
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/redundantBranchElimination
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/storeElimination
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/ipa/inlining
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/ipa/specialization
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/ipa/summaries
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/local
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/local/depGraph
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/local/instructionScheduler
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/regalloc/linearScan
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/regalloc/util
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/dataflowUtil
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/exception
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/graph
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/graph/vis
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/graph/vis/vcg
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/graph/vis/dot
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/list
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/dotgraph
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/set
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/vmInterface/classLoader
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/vmInterface/classLoader/jikesrvm
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/vmInterface/services
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/vmInterface

	# architecture-specific components
	#
	echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing
	echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/ir/instruction
	echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/ir/instruction/operand
	echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/ir/conversions/lir2mir
	echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/ir/conversions/mir2mc
	echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/regalloc
	echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/vmInterface/services
    fi

    # Adaptive compiler components.
    #
    if (( RVM_WITH_ADAPTIVE_SYSTEM )); then
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/controller
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/recompilation
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/runtimeMeasurements
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/runtimeMeasurements/listeners
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/runtimeMeasurements/organizers
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/database
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/database/methodSamples
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/database/callGraph
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/recompilation/instrumentation
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/runtimeMeasurements/instrumentation
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/utility
    fi

    # On stack replacement components.
    #
    if (( RVM_WITH_OSR )); then
        echo $RVM_ROOT/rvm/src/vm/arch/$ARCH_DIR/executionState
        echo $RVM_ROOT/rvm/src/vm/adaptive/onStackReplacement/optCompilationWithOsr
        echo $RVM_ROOT/rvm/src/vm/adaptive/onStackReplacement/specialCompilation
        echo $RVM_ROOT/rvm/src/vm/adaptive/onStackReplacement/util
        echo $RVM_ROOT/rvm/src/vm/adaptive/onStackReplacement/executionState
        echo $RVM_ROOT/rvm/src/vm/adaptive/onStackReplacement/threadControls
    fi

    # architecture specific writebarrier support for baseline compilers
    #
    echo "$RVM_ROOT/rvm/src/vm/arch/$ARCH_DIR/compilers/baseline/writeBarrier"

    # Bootimage compiler components.
    #
    if (( ${RVM_WITH_BASE_BOOTIMAGE_COMPILER} )); then
	echo ${RVM_ROOT}/rvm/src/vm/compilers/harness/bootImage/baseline
    elif (( ${RVM_WITH_OPT_BOOTIMAGE_COMPILER} )); then
	echo ${RVM_ROOT}/rvm/src/vm/compilers/harness/bootImage/optimizing
    fi

    # Runtime compiler components.
    #
    echo ${RVM_ROOT}/rvm/src/vm/compilers/harness/runtime

    # Common memory manager components.
    #
    echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk
    echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/vmInterface
    echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/header
    echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan
    echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/policy
    echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/utility
    # collector specific classes
    #
    if (( $RVM_WITH_SEMI_SPACE )); then
        echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/semiSpace
    elif (( $RVM_WITH_MARK_SWEEP )); then
        echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/markSweep
    elif (( $RVM_WITH_GEN_COPY )); then
        echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/genCopy
    elif (( $RVM_WITH_GEN_MS )); then
        echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/genMS
    elif (( $RVM_WITH_GEN_RC )); then
        echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/genRC
    elif (( $RVM_WITH_COPY_MS )); then
        echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/copyMS
    elif (( $RVM_WITH_REF_COUNT )); then
        echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/refCount
    elif (( $RVM_WITH_NO_GC )); then
        echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/noGC
    fi

    # standard library support
    #
    echo $RVM_ROOT/rvm/src/vm/libSupport
    echo $RVM_ROOT/rvm/src/vm/libSupport/java/lang
    echo $RVM_ROOT/rvm/src/vm/libSupport/java/lang/ref
    echo $RVM_ROOT/rvm/src/vm/libSupport/java/lang/reflect
    echo $RVM_ROOT/rvm/src/vm/libSupport/java/net
    echo $RVM_ROOT/rvm/src/vm/libSupport/java/io

    # Add support for hardware performance monitors on PowerPC
    #
    if (( $RVM_WITH_HPM )); then
	echo $RVM_ROOT/rvm/src/vm/adaptive/runtimeMeasurements/hardwarePerformanceMonitors
    fi

    # Add the configuration specific directories
    #
    for dir in $CONF_SPECIFIC_SOURCES_LIST; do
        echo $RVM_ROOT/$dir
    done
}




## We only emit the boilerplate inline.
function emitBoilerplate () {
    cat <<- 'EOF'
	## BEGIN inline Bash boilerplate.
	# What is our name?
	# Bash internal shorthand that works like the "basename" command.
	ME="${0##*/}"
	EOF
    emit_enable_exit_on_error
	# tracing() takes 0 or 1 arguments.
	# The trace argument can be:
	# -trace		 (gets most things but for some of the bootimagewriter)
	# -trace=ant		# Just ant is of interest
	# -trace=jbuild		# high-level
	# 
	# This is then converted to:
	# TRACE_FLAG: (empty)  # only if nothing was said
	# TRACE_FLAG: ,no-all,
	# TRACE_FLAG: ,-trace,
	# We can be tracing:
	# preprocessor,make,BootImageWriter,ant,jbuild
	# As well as the groups:
	# most,all
	# See the help message in "jbuild -help" for more info.

	# Returns true (exit 0) if we are tracing
	# Returns false (exit 1) if we are not.
    cat <<- 'EOF'
	function tracing() {
	    [[ $TRACE_FLAG ]] || return 1

	    local -i dflt=0	# default answer, true.
	    # Canonicalize.
	    if [[ $TRACE_FLAG != ,*, ]]; then
	        if [[ $TRACE_FLAG = -trace ]]; then
	            TRACE_FLAG=,most,
	        elif [[ $TRACE_FLAG != -trace=* ]]; then
	            echo >&2 "${ME}: I don't understand the trace flag \"$TRACE_FLAG\".   Aborting execution."
	            trap '' EXIT
	            kill $$
	        else
		    # It's -trace=
	            TRACE_FLAG=",${TRACE_FLAG#-trace=},";
	        fi
	        TRACE_FLAG=${TRACE_FLAG/,no-most,/,no-all,}
	        TRACE_FLAG=${TRACE_FLAG/,most,/,preprocessor,make,no-BootImageWriter,ant,jbuild,}
	    fi
	    if [[ $TRACE_FLAG == *,no-all,* ]]; then
	            dflt=1	# false
	    fi
	    if (( $# > 0 )); then
	        local arg="$1"
	        # If someone explicitly requested it, then, trace it.
	        if [[ $TRACE_FLAG == *,${arg},* ]]; then
	            return 0;
	        elif [[ $TRACE_FLAG == *,no-${arg},* ]]; then
	            return 1;
	        fi
	    fi 
	    return $dflt;
	}
	## END inline Bash boilerplate.
	EOF
}

function emit_disable_exit_on_error () {
    cat <<- 'EOF'
	## BEGIN disable_exit_on_error.
	EOF
    if [ "$have_err_trap" ]; then
	cat <<- 'EOF'
	# This has to be inline or a source'd file; the ERR trap is not
	# inherited by shell functions.
	trap - ERR || echo >&2 "$ME: We do not have the ERR Trap in this shell.  Must be cross-configuring or something of the sort."
	EOF
    fi
    cat <<- 'EOF'
	set +e
	## END disable_exit_on_error.
EOF
}

function emit_enable_exit_on_error () {
    # This has to be inline or a source'd file; the ERR trap is not
    # inherited by shell functions.
    cat <<- 'EOF'
	## BEGIN enable_exit_on_error.
	EOF
    if [ "$have_err_trap" ]; then
	cat <<- 'EOF'
	if trap -- 'finalarg="$_" xited=$?; set +vx; echo >&2 "$ME: some command we just ran (probably with a
	      final argument of \"$finalarg\") exited with status $xited, possibly in source
	      file line # $LINENO${FUNCNAME+'"'"' and function '"'"'\"}$FUNCNAME${FUNCNAME+\"}
	      I give up; aborting execution."; trap "echo >&2 \"Exiting due to an error\"" EXIT' ERR
	then
	    have_err_trap=yes
	else
	    echo >&2 "$ME: You are under a version of Bash 
	    ($BASH_VERSION; probably pre-2.05) that
	    does not support
	    the ERR trap.  You may not get as much diagnostic info as you would like."
	    unset have_err_trap || :
	fi
	EOF
	if false; then
	    cat <<- 'EOF'
	trap 'echo >&2 "$ME: A command I just ran (probably with a final argument of "$_")
	   exited with status $?.  Something is broken; I give up."' ERR \
	  || echo >&2 "$ME: We do not have the ERR Trap in this shell.  Must be cross-configuring or something of the sort."
		EOF
	fi
    fi
    cat <<- 'EOF'
	set -e
	## END enable_exit_on_error
	EOF
}



# Emit script which sets all shell variables relative to the
# shadow and build directory
function emitEnvironmentBash () {
    # read the target environment file
    #
    echo '#! /bin/bash'
    echo '# Note: the above #! /bin/bash is there merely as documentation.'
    echo '# This file will not be run as a program directly, but rather sourced'
    echo '# by other routines.'
    echo ''
    echo '# Set the environment.'
    echo ""
    echo "# This file is generated by jconfigure from the configuration file"
    echo "# RVM_HOST_CONFIG ($RVM_HOST_CONFIG).  "
    echo "# You may edit this file, but"
    echo "# all your changes will be lost if jconfigure is executed again using"
    echo "# the current directory ($RVM_BUILD) as RVM_BUILD."
    echo ""
    echo "# This file was generated from the configuration file:"
    echo "#      $CURRENT_CONFIG_FILE"

    echo ""
    echo "export $BUILD_DIRECTORY_STR1=$RVM_BUILD"
    echo "export $ROOT_DIRECTORY_STR1=$RVM_ROOT"
    echo ""
    echo "export $HOST_JIKES_STR1=\"$JIKES\""
    echo "export $HOST_JAVA_STR1=\"$HOST_JAVA\""
    echo "export $HOST_JAVAC_STR1=\"$HOST_JAVAC\""
    echo "export $HOST_JAVA_HOME_STR1=\"$HOST_JAVA_HOME\""
    echo "export $HOST_JAVADOC_STR1=\"$HOST_JAVADOC\""
    echo "export $HOST_JAR_STR1=\"$HOST_JAR\""
    echo "export $HOST_REPOSITORIES_STR1=$HOST_REPOSITORIES"
    echo "export $HOST_TOOLS_STR1=$HOST_TOOLS"
    echo "export LD_LIBRARY_PATH=\"\$LD_LIBRARY_PATH:$HOST_JAVA_LD_LIBRARY_PATH\""
    echo ""
    echo "export $GNU_MAKE_STR1=$GNU_MAKE"
    echo ""
    echo "export $HOST_CC_STR1='$CC'"
    echo "export $HOST_CPLUS_STR1='$CPLUS'"
    echo "export $HOST_CPP_STR1='$CPP'"
    echo "export $HOST_SHLD_STR1='$LDSHARED'"
    echo ""
    echo "export AWK='$AWK'"  
    echo "export BASH='$BASH'"  
    echo "export CVS='$CVS'"  
    echo "export DIFF='$DIFF'"  
    echo "export FGREP='$FGREP'"
    echo "export FIND='$FIND'"
    echo "export GNU_TAR='$GNU_TAR'"  
    echo "export GREP='$GREP'"
    echo "export MD5SUM='$MD5SUM'"  
    echo "export PS='$PS'"  
    echo "export SED='$SED'"
    echo "export WGET='$WGET'"
    echo "export XARGS='$XARGS'"
    echo "export UNZIP_CMD='$UNZIP_CMD'"
    echo "export ANT_CMD='$ANT_CMD'"
    echo ""
    echo "export ECLIPSE_INSTALL_DIR='$ECLIPSE_INSTALL_DIR'"
    echo ""
    echo "export CLASSPATH_LIBRARIES=YES"
    if [[ $CLASSPATH_ROOT ]]; then
        echo "export CLASSPATH_ROOT=$CLASSPATH_ROOT"
    fi
    echo ""
}

#
# Emit Makefile
# 
function emitMakefile () {
    cat <<- EOF
        include $RVM_ROOT/rvm/Make.rules.generic

	# environment specific make rules
	
	# This file is generated by jconfigure according to values specified
	# in the configuration file RVM_HOST_CONFIG.  You may edit this file, but
	# all your changes will be lost if jconfigure is executed again using
	# the current directory as RVM_BUILD.
	
	# This file was generated from the configuration file:
	#      ${CURRENT_CONFIG_FILE}

	$BUILD_DIRECTORY_STR1 = $RVM_BUILD
	$ROOT_DIRECTORY_STR1 = $RVM_ROOT
	
	$HOST_JIKES_STR1 = $JIKES
	
	HOST_JAVA_HOME = $HOST_JAVA_HOME
	HOST_JAVA = $HOST_JAVA
	HOST_JAVAC = $HOST_JAVAC
	HOST_JAVADOC = $HOST_JAVADOC
	HOST_JAR = $HOST_JAR
	HOST_REPOSITORIES = $HOST_REPOSITORIES
	HOST_TOOLS = $HOST_TOOLS
	
	CC = $CC
	CPLUS = $CPLUS
	CXX = $CPLUS
	LDSHARED = $LDSHARED
	JNI_NATIVE_LIBS_LD = $JNI_NATIVE_LIBS_LD
	
	AWK= $AWK
	BASH = $BASH
	CVS = $CVS
	DIFF= $DIFF
	FGREP = $FGREP
	FIND = $FIND
	GNU_TAR = $GNU_TAR
	GREP = $GREP
	MD5SUM = $MD5SUM
	PS= $PS
	SED = $SED
	WGET = $WGET
	XARGS = $XARGS
	UNZIP_CMD = $UNZIP_CMD
	
	
	CLASSPATH_LIBRARIES = YES
	EOF
}


# Emit a script to run each phase of vm builder in turn.

function emitController () {
    cat <<- EOF
	#!/bin/bash

	# Run all phases of vm builder.

	$(emitBoilerplate)

	# timeit() \$1: The command to run
	#	   \$2: That command's arguments.

	# The old (until 2003 June) KSH script displayed
	# seconds of precision to three decimal places.  The
	# SECONDS variable in my version of Bash only returns
	# integers.

	function timeit () {
	    # We can either do some modifications to the output
	    # format, and use TIMEFORMAT instead of SECONDS...
	    # TIMEFORMAT="%3lR"
	    # time "\$@"		
	    # ...Or we can just deal.with integer seconds.  Since the SECONDS
	    # variable is cumulative, it is compatible with the way we used to
	    # do this.

	    # The --via-RUN-BUILD-COPY flag adds text to one of the 
	    # error messages and makes sure we don't run the remote command
	    # with \$TRACE, \$VFLAG, and \$XFLAG
	    declare -i via_RUN_BUILD_COPY=0
	    if [[ \$1 = --via-RUN-BUILD-COPY ]]; then
		let ++via_RUN_BUILD_COPY
		shift
	    fi	
	    # Disable exit-on-error; inside "timeit", we can get a better
	    # exit message than the default one.
    $(emit_disable_exit_on_error)
	    local cmd="\$1"
	    shift
	    if (( via_RUN_BUILD_COPY )); then
	        "\${cmd}" "\$@"
	    else
	        "\${cmd}" \$TRACE_FLAG \$VFLAG \$XFLAG "\$@"
	    fi
	    local status=\$?
    $(emit_enable_exit_on_error)
	    echo "\$SECONDS s"
	    if (( status == $Exit_Status_Run_Linker )); then
		echo >&2 "\$ME: You need to run the linker on the appropriate platform."
		trap '' EXIT
		exit $Exit_Status_Run_Linker
	    elif (( status != 0 )); then
		if (( via_RUN_BUILD_COPY )); then
		    echo >&2 "$ME: Possible difficulty with the remote command specified in RUN_BUILD_COPY:"
		fi
	        echo >&2 "\$ME: Trouble while running \"\$cmd \$*\" (exit status \$status); aborting execution"
	        trap '' EXIT
	        exit \$status;
	    fi
	    return \$status;	# will always return 0
	}

	VFLAG="" XFLAG="" DEMOGRAPHICS_FLAG="" CLEAN_FLAG="" RECOMPILE_FLAG="" NOLINK_FLAG="" BOOTER_FLAG="" NOBOOTER_FLAG=""
	while (( \$# > 0 )); do
	    arg="\$1"
	    [[ \$arg != --?* ]] || arg="\${arg#-}"
	    if [[ \$arg == -trace* ]]; then
	        TRACE_FLAG="\$arg"
	    elif [[ \$arg = -v ]]; then
	       VFLAG=-v
	    elif [[ \$arg = -x ]]; then
	       XFLAG=-x
	    elif [[ \$arg = -demographics ]]; then
	        DEMOGRAPHICS_FLAG=-demographics
	    elif [[ \$arg = -clean ]]; then
	        CLEAN_FLAG=-clean
	    elif [[ \$arg = -recompile ]]; then
	        RECOMPILE_FLAG=-recompile
	    elif [[ \$arg = -nolink ]]; then
	        NOLINK_FLAG=-nolink
	    elif [[ \$arg = -nobooter ]]; then
	        NOBOOTER_FLAG=-nobooter
	    elif [[ \$arg = -booter ]]; then
	        NOLINK_FLAG=-nolink
	        BOOTER_FLAG=-booter
	    else
	        echo >&2 \
		"Usage: \$ME [-trace[=<trace-opts>]] [-v] [-x] [-demographics] 
		         [-clean] [-recompile] [-nolink] [-nobooter] [-booter]

		    -trace: As if \"-trace=most\".  Some debugging information.
		    -trace=make:  Make is no longer run with --silent.
		    -trace=ant:  Ant is no longer run with -quiet.
		    -trace=preprocessor: Follow the process of running the preprocessor on Java
		          source code.
		    -trace=BootImageWriter: the BootImageWriter sends out lots of information 
		         (about 9420 lines in a BaseBaseCopyMS build.)  That's why -trace
		         no longer includes the BootImageWriter output by default.
		    -trace=jbuild:  Higher-level info as the build progresses.
		    -trace=most:   Same as -trace=all,no-BootImageWriter
		    -trace=all:   Everything.
		    "
		echo >&2 \
		"    -v, -x: Turn on the -v and/or -x debugging flags in the subshells we spawn.
		    -nobooter: avoid building the booter (when, for example, running on the AIX
		          side of an AIX/Linux cross-compilation)

		    -booter:  build only the booter (when, for example, running on 
		          the Linux side of an AIX cross-build to Linux)

		    -nolink:  avoid unnecessarily rebuilding the bootimage (when, for example,
		          you've only modified classes that are dynamically loaded and which
		          are not part of the bootimage)

		    -recompile:  force recompilation of all classes (when, for example, 
		          you've modified a global constant or have added/removed
		           fields/methods from a class)

		    -clean:  restore the build directory to its original \"unbuilt\" state"
		trap '' EXIT
	        exit 33
	    fi
	    shift
	done

	
	if [[ \$BOOTER_FLAG = -booter ]]; then
	  . ./environment.target
	else
	  . ./environment.host
	fi
	
#    	[[ \$VFLAG ]] || VFLAG=+v
#    	[[ \$XFLAG ]] || XFLAG=+x
	[ ! "\$VFLAG\$XFLAG" ] || set \$VFLAG \$XFLAG
	# Ensure that we have the right version of the class libraries
	\$JAL_ROOT/rvm/bin/jBuildClasspathJar --check
	
	if [[ \$CLEAN_FLAG = -clean ]]; then
	    rm -rf \$TOOL_DIRECTORY_STR
	    timeit ./jbuild.expand      -clean
	    timeit ./jbuild.copy        -clean
	    timeit ./jbuild.compile     -clean
	    timeit ./jbuild.linkImage   \$DEMOGRAPHICS_FLAG -clean
	    timeit ./jbuild.linkBooter  -clean
	    trap '' EXIT
	    exit 0
	fi

	if [[ \$RECOMPILE_FLAG = -recompile ]]; then
	    timeit ./jbuild.compile -clean
	fi

	if [[ -e $CLEANSE_STATUS_STR ]]; then
	    rm -rf $TOOL_DIRECTORY_STR
	    timeit ./jbuild.expand     -clean
	    timeit ./jbuild.copy       -clean
	    timeit ./jbuild.compile    -clean
	    timeit ./jbuild.linkImage  \$DEMOGRAPHICS_FLAG -clean
	    timeit ./jbuild.linkBooter -clean
	    rm -f $CLEANSE_STATUS_STR
	elif [[ \$NOLINK_FLAG != -nolink ]]; then
	    timeit ./jbuild.linkImage  \$DEMOGRAPHICS_FLAG -clean
	    timeit ./jbuild.linkBooter -clean
	fi

	if [[ \$BOOTER_FLAG = -booter ]]; then
	    # Instead of running "jbuild.linkBooter", we can optionally
	    # run a command specified
	    # in the environment variable RUN_BUILD_COPY.
	    #
	    # For example, this variable could use rsh or ssh 
	    # to run the linkBooter command remotely on the target machine.
	    if [[ \$RUN_BUILD_COPY ]]; then
	         timeit --via-RUN-BUILD-COPY \$RUN_BUILD_COPY
	    else
	         timeit ./jbuild.linkBooter
	    fi
	else
	    timeit ./jbuild.expand 
	    timeit ./jbuild.copy   
	    timeit ./jbuild.compile
	    if [[ \$NOLINK_FLAG != -nolink ]]; then
	        timeit ./jbuild.linkImage  \$DEMOGRAPHICS_FLAG
	        if [[ \$NOBOOTER_FLAG != -nobooter ]]; then
		    if [[ \$RUN_BUILD_COPY ]]; then
			timeit --via-RUN-BUILD-COPY \$RUN_BUILD_COPY
		    else
			timeit  ./jbuild.linkBooter
		    fi
		fi
	    fi
	fi
	
	if [[ -x JikesRVM ]] && [[ -f JikesRVM ]]; then
	    echo "\${ME}: To execute the $CONFIGURATION_NAME RVM (from any directory) type:"
	    echo "\${ME}:    rvm <vm-args> classname <application-args>"
	    if ! type -p rvm > /dev/null; then
	        echo "${ME}: You will also need to add ${RVM_ROOT}/bin to your path"
	    fi
	fi
	EOF
}


# echo >&2  "HERE I AM! emitExpander" # DBG
# Emit script to generate VM source tree Java files that derive from templates.
# Taken:    .template files in source tree
# Returned: .java files in ${GENERATED_FILES_DIRECTORY}
#
function emitExpander () {
    cat <<- EOF
	#! /bin/bash
	# Generate VM sources that derive from templates.
	$(emitBoilerplate)
	. ./environment.host


	# Process command-line args   
	unset TRACE_FLAG VFLAG XFLAG CLEAN_FLAG || :
	SILENT_MAKE=--silent
	while (( \$# > 0 )); do
	    arg="\$1"
	    [[ \$arg != --?* ]] || arg=\${arg#-}
	    if [[ \$arg == -trace* ]]; then
	        TRACE_FLAG="\$arg"
	    elif [[ \$arg = -v ]]; then
	        VFLAG=-v
	    elif [[ \$arg = -x ]]; then
	        XFLAG=-x
	    elif [[ \$arg = -clean ]]; then
	        CLEAN_FLAG=-clean
	    else
	        echo >&2 "\$ME: Unknown argument: \$arg"
		trap '' EXIT
	        exit $Exit_Status_Bad_Args
	    fi
	    shift
	done
	if tracing make; then
	    SILENT_MAKE=
	fi

	echo -n "\${ME}: "

#	! tracing jbuild || XFLAG=-x
#    	[[ \$VFLAG ]] || VFLAG=+v
#    	[[ \$XFLAG ]] || XFLAG=+x
	[ ! "\$VFLAG\$XFLAG" ] || set \$VFLAG \$XFLAG
	if [[ \$CLEAN_FLAG ]]; then
	    rm -rf ${SCRATCH_DIRECTORY_STR}
	    mkdir -p ${SCRATCH_DIRECTORY_STR}/com/ibm/JikesRVM
	    cd ${GENERATED_FILES_DIRECTORY_STR}
	    echo *.* | \$XARGS -r rm -f
	EOF
    if (( RVM_WITH_OPT_COMPILER )); then
	cat <<- EOF
	    cd ${GENERATED_FILES_DIRECTORY_STR}/instructionFormats
	    echo *.* | \$XARGS -r rm -f
	EOF
    fi
    cat <<- EOF

	    echo -n "(templates cleaned) "
	    trap '' EXIT
	    exit 0
	fi
	# Make the tools that we need to do template expansion
	${GNU_MAKE_STR} \${SILENT_MAKE} -C "${ROOT_DIRECTORY_STR}/rvm/src/tools/templateExpander" tool SCRATCH_DIR="${SCRATCH_DIRECTORY_STR}"
EOF
    if (( RVM_WITH_OPT_COMPILER )); then
	echo "\
${GNU_MAKE_STR} \${SILENT_MAKE} -C ${ROOT_DIRECTORY_STR}/rvm/src/tools/jburg tool SCRATCH_DIR=${SCRATCH_DIRECTORY_STR}\
"
    fi

    # build command line options for core VM
    echo "\
${GNU_MAKE_STR} \${SILENT_MAKE} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/utility MakeTemplates GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR} SCRATCH_DIR=${SCRATCH_DIRECTORY_STR}"
    
    # build command line options for JMTk
    echo "\
${GNU_MAKE_STR} \${SILENT_MAKE} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/memoryManagers/JMTk/utility MakeTemplates GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR} SCRATCH_DIR=${SCRATCH_DIRECTORY_STR}"
    
    # build VM_Assembler on Intel
    if (( RVM_FOR_IA32 )); then
	echo "\
${GNU_MAKE_STR} \${SILENT_MAKE} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/arch/intel/assembler GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR}"
	if (( RVM_WITH_OPT_COMPILER )); then
	echo "\
${GNU_MAKE_STR} \${SILENT_MAKE} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/arch/intel/compilers/optimizing/ir/conversions/mir2mc GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR}"
	fi
    fi

    # Do the expansion
    echo "\
${GNU_MAKE_STR} \${SILENT_MAKE} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/classLoader MakeTemplates GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR}

${GNU_MAKE_STR} \${SILENT_MAKE} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/compilers/baseline MakeTemplates GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR} SCRATCH_DIR=${SCRATCH_DIRECTORY_STR}"

    if (( RVM_WITH_OPT_COMPILER )); then
	echo "\
${GNU_MAKE_STR} \${SILENT_MAKE} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/compilers/optimizing MakeTemplates ARCH_DIR=${ARCH_DIR} GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR} SCRATCH_DIR=${SCRATCH_DIRECTORY_STR} IS_ADAPTIVE=${RVM_WITH_ADAPTIVE_SYSTEM}"
	if (( RVM_WITH_EXTREME_ASSERTIONS )); then
	    echo "\
${GNU_MAKE_STR} \${SILENT_MAKE} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/compilers/optimizing/ir/instruction fatalInstructionFormat ARCH_DIR=${ARCH_DIR} GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR} SCRATCH_DIR=${SCRATCH_DIRECTORY_STR}"
	fi
    fi
    if (( RVM_WITH_ADAPTIVE_SYSTEM )); then
	echo "\
${GNU_MAKE_STR} \${SILENT_MAKE} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/adaptive MakeTemplates GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR} SCRATCH_DIR=${SCRATCH_DIRECTORY_STR} IS_ADAPTIVE=${RVM_WITH_ADAPTIVE_SYSTEM}"
    fi
    
    echo '
if tracing jbuild; then
    echo ""
fi
';
}


# Emit script to copy/preprocess VM Java files from source tree to 
# build directory.
# Taken:    .java files in source tree
# Returned: .java files in build directory
#
# echo >&2  "HERE I AM! emitCopier" # DBG
function emitCopier () {
    if (( BUILD_WITH_PARANOID_PREPROCESSOR )); then
	PARANOID_PREPROCESSOR_FLAG=" --no-undefined-constants-in-conditions"
    fi
    cat <<- EOF
	#! /bin/bash
	# Copy or preprocess VM Java files from the source tree to 
	# the build directory.
	# Taken:    .java files in the source tree
	# Returned: .java files in the build directory

	$(emitBoilerplate)
	. ./environment.host
	

	# Process command-line args   
	unset TRACE_FLAG  VFLAG XFLAG CLEAN_FLAG || :
	SILENT_MAKE=--silent
	while (( \$# > 0 )); do
	    arg="\$1"
	    if [[ \$arg = -- ]]; then
	        shift		# The end of the flag arguments
	        break;
	    fi
	    [[ \$arg != --?* ]] || arg="\${arg#-}"
	    if [[ \$arg == -trace* ]]; then
	        TRACE_FLAG="\$arg"
	    elif [[ \$arg = -v ]]; then
	        VFLAG=-v
	    elif [[ \$arg = -x ]]; then
	        XFLAG=-x
	    elif [[ \$arg = -clean ]]; then
	        CLEAN_FLAG=-clean
	    else
	        echo >&2 "\$ME: Unknown argument: \$arg"
	        trap '' EXIT
	        exit $Exit_Status_Bad_Args
	    fi
	    shift
	done

	if tracing make; then
	    SILENT_MAKE=
	fi
	echo -n "\${ME}: "

	if [[ \$CLEAN_FLAG ]]; then
	    if tracing jbuild; then
		echo " (nuking .java files in ${CLASSES_DIRECTORY_STR})"
	    fi
	    find ${CLASSES_DIRECTORY_STR} -name "*.java" -exec rm {} \;
	    echo "This file indicates that some or all classes need to be recompiled" > ${CLASSES_INVALID_STR}
	    echo -n "(sources cleaned) "
	    trap '' EXIT
	    exit 0
	fi
#    	[[ \$VFLAG ]] || VFLAG=+v
#    	[[ \$XFLAG ]] || XFLAG=+x
	[ ! "\$VFLAG\$XFLAG" ] || set \$VFLAG \$XFLAG
	# Make the preprocessor
	${GNU_MAKE_STR} \${SILENT_MAKE} -C ${ROOT_DIRECTORY_STR}/rvm/src/tools/preprocessor INCLUDED_MAKEFILE=${BUILD_DIRECTORY_STR}/Make.rules.host tool SCRATCH_DIR=${SCRATCH_DIRECTORY_STR}
	cp ${SCRATCH_DIRECTORY_STR}/preprocessModifiedFiles ${BUILD_DIRECTORY_STR}/jbuild.prep.host
	echo -n '(preprocessor built) '

	# This may be reset in the loop below.
	FILES_HAVE_CHANGED=0

	# Update from directories containing sources that implement the virtual machine.
	#
	PREPROC_FLAGS="--only-boolean-constants-in-conditions ${PARANOID_PREPROCESSOR_FLAG}"
	if tracing preprocessor; then
	    PREPROC_FLAGS="-trace \$PREPROC_FLAGS"
	fi
	for d in \$(< ${SOURCE_LIST_STR} ); do
	    if tracing preprocessor; then
	         echo -n "\${ME}: expanding \${d}..."
	    fi
	    shopt -s nullglob
	    # FILES may be empty.
	    FILES="\$(echo \${d}/*.java)"
EOF
    emit_disable_exit_on_error
    # The odd code below where I have $(echo  ...) is because I need to turn
    # the PREPROCESSOR_DEFINITIONS from a newline-separated list to a space-separated list.
    cat <<- EOF

	    ## Approach abandoned because xargs will exit with status 123
	    ## upon nonzero exit status from jbuild.prep.host, but 
	    ## jbuild.prep.host will exit with status 1 when files are modified.
	    ## So, all the non-zero return values get mapped to 123, and we 
	    ## want to distinguish 1 (OK) 
	    ## from other non-zero return values (trouble).
	    # echo \$FILES | \$XARGS -r ${BUILD_DIRECTORY_STR}/jbuild.prep.host \${PREPROC_FLAGS} $(echo ${PREPROCESSOR_DEFINITIONS}) ${CLASSES_DIRECTORY_STR} 

	    if [[ ! \$FILES ]]; then
	        continue;
	    fi
	    ${BUILD_DIRECTORY_STR}/jbuild.prep.host \${PREPROC_TRACE_FLAG} $(echo ${PREPROCESSOR_DEFINITIONS}) ${CLASSES_DIRECTORY_STR} \$FILES 
	    status=\$?
EOF
    emit_enable_exit_on_error
    echo '
    if (( status == 1 )); then
	FILES_HAVE_CHANGED=1
    elif (( status != 0 )); then
	echo >&2 "$ME: Trouble while running jbuild.prep.host (exit status ${status}).
    Aborting execution."
	trap "" EXIT
	exit $status
    fi
    if tracing preprocessor; then
	echo ""
    fi
done

# Update from directories containing machine generated source files
# Do this after we copy the "normal" files to allow us to
# overwrite any dummy versions of the files we have sitting
# around in the shadow (telling people that the file is generated).
if tracing preprocessor; then
    echo -n "${ME}: '${GENERATED_FILES_DIRECTORY_STR}'/"
fi
FILES=$(${FIND} '${GENERATED_FILES_DIRECTORY_STR}'/ -name "*.java")'
    emit_disable_exit_on_error
    ## See above comment on xargs.
    # echo 'echo $FILES | $XARGS -r '${BUILD_DIRECTORY_STR}'/jbuild.prep.host ${PREPROC_TRACE_FLAG}' ${PREPROCESSOR_DEFINITIONS} ${CLASSES_DIRECTORY_STR}'
    echo ${BUILD_DIRECTORY_STR}/jbuild.prep.host "\${PREPROC_TRACE_FLAG}" ${PREPROCESSOR_DEFINITIONS} ${CLASSES_DIRECTORY_STR} "\${FILES}"
    echo 'status=$?'
    emit_enable_exit_on_error
    echo '
if [[ ${status} = 1 ]]; then
    FILES_HAVE_CHANGED=1
elif [[ ${status} != 0 ]]; then
    echo >&2 "$ME: Trouble while running jbuild.prep.host (exit status ${status}); aborting execution."
    trap '' EXIT
    exit ${status}
fi
if tracing preprocessor; then
    echo ""
fi'

    # copy classpath jar file
    if ! [[ $CLASSPATH_ROOT ]]; then
	CPS="$RVM_ROOT/classpath"
    else
	CPS="${CLASSPATH_ROOT}"
    fi
    echo '
SYSTEM_TYPE=$('$CPS'/classpath/config.guess)
cp -f '$CPS'/$SYSTEM_TYPE/lib/glibj.zip '${CLASSES_DIRECTORY_STR}'/rvmrt.jar

echo -n "(classpath.jar copied) "

# Remember if any new (or modified) source files were discovered.
#
if [[ ${FILES_HAVE_CHANGED} = 1 ]]; then
    touch' ${CLASSES_INVALID_STR} '
fi'
}
    

# Emit script to generate VM class files from Java files.
# Taken:    .java files in build directory 
#            CLASSES_INVALID
# Returned: .class files in build directory
#
# echo >&2  "HERE I AM! emitCompiler" # DBG

function emitCompiler () {
    cat <<- 'EOF'
	#! /bin/bash
	# Generate VM class files from Java files.
	# Taken:    .java files in build directory 
	#            CLASSES_INVALID
	# Returned: .class files in build directory
EOF
    emitBoilerplate;
    cat <<- EOF
	. ./environment.host


	unset TRACE_FLAG VFLAG XFLAG CLEAN_FLAG || :
	while (( \$# > 0 )); do
	    arg="\$1"
	    if [[ \$arg = -- ]]; then
	        shift		# The end of the flag arguments
	        break;
	    fi
	    [[ \$arg != --?* ]] || arg="\${arg#-}"
	    if [[ \$arg == -trace* ]]; then
		TRACE_FLAG="\$arg"
	    elif [[ \$arg = -v ]]; then
	        VFLAG=-v
	    elif [[ \$arg = -x ]]; then
	        XFLAG=-x
	    elif [[ \$arg = -clean ]]; then
	        CLEAN_FLAG=-clean
	    else
	        echo >&2 "\$ME: Unknown argument: \$arg"
	        trap '' EXIT
	        exit $Exit_Status_Bad_Args
	    fi
	    shift
	done

	echo -n "\${ME}: "
#    	[[ \$VFLAG ]] || VFLAG=+v
#    	[[ \$XFLAG ]] || XFLAG=+x
	[ ! "\$VFLAG\$XFLAG" ] || set \$VFLAG \$XFLAG

	if [[ \$CLEAN_FLAG ]]; then
	    cd ${CLASSES_DIRECTORY_STR}
	    # This avoids any limits on the size of the command-line arguments.
	    # 'echo' is a bash builtin, and as such is unaffected by such O/S 
	    # limits. 
	    echo *.class | \$XARGS -r rm -f
	    touch ${CLASSES_INVALID_STR} 
	    echo -n "(classes cleaned) "
	    trap "" EXIT
	    exit 0
	fi
EOF
    # Generate classes
    #
    TOP_LEVEL_SOURCES="Dummy.java"
    if (( RVM_WITH_OPT_COMPILER )); then
	TOP_LEVEL_SOURCES="${TOP_LEVEL_SOURCES} OptDummy.java"
    fi
    if (( RVM_WITH_OPT_TEST_HARNESS )); then
	TOP_LEVEL_SOURCES="${TOP_LEVEL_SOURCES} OptDummy.java OptTestHarness.java"
    fi
    TOP_LEVEL_SOURCES="${TOP_LEVEL_SOURCES} ${CONF_SPECIFIC_TOP_LEVEL_SOURCES}"
    TOP_LEVEL_CLASSES="$(echo ${TOP_LEVEL_SOURCES}| sed 's@\.java@.class@g')"

    cat <<- EOF
	if [[ -e $CLASSES_INVALID_STR ]]; then
	    cd $CLASSES_DIRECTORY_STR
	    rm -f $TOP_LEVEL_CLASSES
	    jikes_invocation="$HOST_JIKES_STR -nowarn -g +U -classpath .:rvmrt.jar $TOP_LEVEL_SOURCES"
	    $(emit_disable_exit_on_error)
	    if \${jikes_invocation}; then
		echo -n '(classes compiled) '
	    else
		status=\$?
		echo >&2 "\$ME: The Jikes compiler exited with status \${status} while we were building the source file(s): $TOP_LEVEL_SOURCES"
		echo >&2 "\$ME: We invoked the Jikes compiler in the directory $CLASSES_DIRECTORY_STR"
		echo >&2 "\$ME: With the command-line: \$jikes_invocation"
		exit \$status
	    fi
	    $(emit_enable_exit_on_error)
	    rm -f jksvm.jar
	    ## The Sun JAR manual page claims that '-O' is the flag for
	    ## no-compression.  It's actually '0' (zero), not the letter 'O'.
	    $HOST_JAR_STR -c0f jksvm.jar Dummy.class # > /dev/null 2>&1

	    \$FIND . -name '*.class' | \$XARGS -r $HOST_JAR_STR -u0f jksvm.jar # > /dev/null 2>&1
	    echo -n '(jksvm.jar built) '

	    rm -f jksvmsrc.jar
	    $HOST_JAR_STR -c0f jksvmsrc.jar Dummy.java # > /dev/null 2>&1
	    ## -r is the no-run-if-empty flag.
	    \$FIND . -name '*.java' | \$XARGS -r $HOST_JAR_STR -u0f jksvmsrc.jar # > /dev/null 2>&1
	    echo -n '(jksvmsrc.jar built) '

	else
	    if tracing jbuild; then
	         echo -n "(nothing needed to be compiled) "
	    fi
	fi
	rm -f $CLASSES_INVALID_STR

	if tracing jbuild; then
	    echo ""
	fi
	EOF
}

# echo >&2  "HERE I AM! emitImageLinker" # DBG
function emitImageLinker () {
    cat <<- EOF
	#! /bin/bash
	# Generate the VM bootimage.
	# Taken:    .class files in build directory
	# Returned: PRIMORDIAL_CLASSES and bootimage in build directory
	#            InterfaceDeclarations.h in bootImageRunner directory
	#
	$(emitBoilerplate)

	. ./environment.host

	# Process command-line args
	unset TRACE_FLAG VFLAG XFLAG CLEAN_FLAG DEMOGRAPHICS_FLAG || :
	SILENT_MAKE=--silent
	while (( \$# > 0 )); do
	    arg="\$1"
	    [[ \$arg != --?* ]] || arg="\${arg#-}"
	    if [[ \$arg == -trace* ]]; then
	        TRACE_FLAG="\$arg"
	    elif [[ \$arg = -v ]]; then
	       VFLAG=-v
	    elif [[ \$arg = -x ]]; then
	       XFLAG=-x
	    elif [[ \$arg = -demographics ]]; then
	        DEMOGRAPHICS_FLAG=-demographics
	    elif [[ \$arg = -clean ]]; then
	        CLEAN_FLAG=-clean
	    else
	        echo >&2 "\$ME: Unknown argument: \$arg"
	        trap '' EXIT
	        exit $Exit_Status_Bad_Args
	    fi
	    shift
	done
	
	echo -n "\${ME}: "
#    	[[ \$VFLAG ]] || VFLAG=+v
#    	[[ \$XFLAG ]] || XFLAG=+x
	[ ! "\$VFLAG\$XFLAG" ] || set \$VFLAG \$XFLAG
	if tracing make; then
	    SILENT_MAKE=
	fi

EOF
    
    BOOTIMAGE_WRITER_MAKEFILE=Makefile

    echo "if [[ \$CLEAN_FLAG ]]; then"
    echo "    rm -f $PRIMORDIAL_CLASSES_STR $EXCLUDED_CLASSES_STR $BOOTIMAGE_STR $BOOTIMAGE_MAP_STR"
    echo '    echo -n "(primordials cleaned) "'
    echo "    rm -f $SCRATCH_DIRECTORY_STR/GenerateInterfaceDeclaration.*"
    echo "    rm -f $SCRATCH_DIRECTORY_STR/InterfaceDeclaration.h"
    echo "    rm -f $SCRATCH_DIRECTORY_STR/BootImage*.java"
    echo "    rm -f $SCRATCH_DIRECTORY_STR/BootImage*.class"
    echo '    echo -n "(bootimage cleaned) "'
    echo '    trap "" EXIT'
    echo '    exit 0'
    echo 'fi'
    echo ''
    echo "rm -f $SCRATCH_DIRECTORY_STR/GenerateInterfaceDeclaration.*"
    echo "rm -f $SCRATCH_DIRECTORY_STR/InterfaceDeclaration.h"
    echo "rm -f $SCRATCH_DIRECTORY_STR/BootImage*.java"
    echo "rm -f $SCRATCH_DIRECTORY_STR/BootImage*.class"
    echo 'echo -n "(bootimage cleaned) "'

    # Generate list of classes to include in the bootimage.
    #
    echo "if [[ ! -e ${PRIMORDIAL_CLASSES_STR} ]]; then"

    # 
    # (1) Generate a list of Excluded classes that we don't want in the bootimage
    #

    # skip: needed to build bootimage, but not to run it
    echo "   echo BootImageInterface               > ${EXCLUDED_CLASSES_STR}"
    echo "   echo Dummy.class                      >> ${EXCLUDED_CLASSES_STR}"
    echo "   echo OptDummy.class                   >> ${EXCLUDED_CLASSES_STR}"

    # skip: JikesRVMSocketImpl; don't load native libs unless needed
    echo "   echo JikesRVMSocketImpl               >> ${EXCLUDED_CLASSES_STR}"

    # skip: don't put application class loader in, due to static data issues
    echo "   echo ApplicationClassLoader.class     >> ${EXCLUDED_CLASSES_STR}"

    # We can't carry these from bootimage writing to runtime without special treatment
    echo "   echo java/lang/ref/PhantomReference.class     >> ${EXCLUDED_CLASSES_STR}"
    echo "   echo java/lang/ref/SoftReference.class     >> ${EXCLUDED_CLASSES_STR}"
    echo "   echo java/lang/ref/WeakReference.class     >> ${EXCLUDED_CLASSES_STR}"

    # Add any configuration specific exclusions
    for exclusion in ${CONF_SPECIFIC_EXCLUSIONS_LIST}; do
	echo "   echo '${exclusion}'                  >> ${EXCLUDED_CLASSES_STR}"
    done

    # 
    # (2) Generate a list of primary classes (non-arrays, non compiler generated (Foo${bar})
    #     classes that will be included in the bootimage unless explicitly excluded.
    
    echo "   cd ${CLASSES_DIRECTORY_STR}"
    
    if (( RVM_WITH_ALL_CLASSES )); then
       echo "   \${FIND} . -name '*.class' -print > ${PRIMORDIAL_CLASSES_STR}.1"
    else
	echo "   \$FIND . -name 'VM*.class' -print > $PRIMORDIAL_CLASSES_STR.1"
	if (( RVM_WITH_ADAPTIVE_SYSTEM )); then
	    echo "   \$FIND ./com/ibm/JikesRVM/opt -name '*.class' -print >> $PRIMORDIAL_CLASSES_STR.1"
        fi
	echo "   \$FIND ./com/ibm/JikesRVM/memoryManagers -name '*.class' -print >> $PRIMORDIAL_CLASSES_STR.1"
	echo "   \$FIND . -path '*/JikesRVMSupport.class' -print >> $PRIMORDIAL_CLASSES_STR.1"
    fi

    cat <<- EOF
    \${SED} -e 's/#.*//' -e '/^[ \t]*\$/d' >> ${PRIMORDIAL_CLASSES_STR}.1 << EOF_PRIMORDIAL_CLASSES_STR_1
# VM daemon threads that don't start with VM for historical reasons
com/ibm/JikesRVM/FinalizerThread
com/ibm/JikesRVM/MainThread
com/ibm/JikesRVM/DebuggerThread

# Classes needed for OutOfMemory servicing which we can't afford to load when we are actually out of memory
com/ibm/JikesRVM/PrintLN
com/ibm/JikesRVM/PrintContainer

## Classes involved with the process of class loading...
# fundamental java classes
#
java/lang/Class
java/lang/Object
java/lang/Runtime
java/lang/String
java/lang/StringBuffer
java/util/StringTokenizer
java/lang/System
java/lang/Thread
java/lang/ThreadGroup

java/lang/OutOfMemoryError
java/lang/Cloneable
java/lang/VMObject
java/lang/VMSystem
java/lang/VMString
gnu/classpath/Configuration

    # reflection support
    #
java/lang/reflect/Field
java/lang/reflect/Method
java/lang/reflect/Member
java/lang/reflect/Constructor
java/lang/reflect/AccessibleObject

    # hardware runtime errors
    #
java/lang/ArithmeticException
java/lang/ArrayIndexOutOfBoundsException
java/lang/Exception
java/lang/Error
java/lang/IndexOutOfBoundsException
java/lang/LinkageError
java/lang/NullPointerException
java/lang/RuntimeException
java/lang/SecurityException
java/lang/StackOverflowError
java/lang/Throwable
java/lang/UnknownError
java/lang/VirtualMachineError

    # software runtime errors
    #
java/lang/IncompatibleClassChangeError
java/lang/ClassCastException
java/lang/ArrayStoreException
java/lang/NegativeArraySizeException
java/lang/AbstractMethodError
java/lang/StringIndexOutOfBoundsException
java/lang/UnsatisfiedLinkError
java/lang/InternalError
java/lang/IllegalMonitorStateException

    # primitive wrapper types
    #
java/lang/Boolean
java/lang/Byte
java/lang/Character
java/lang/Double
java/lang/Float
java/lang/Integer
java/lang/Long
java/lang/Number
java/lang/Short

    # class loading errors
    #
java/io/IOException
java/io/EOFException
java/io/FileNotFoundException
java/lang/ClassNotFoundException
java/lang/ClassFormatError
java/lang/NoClassDefFoundError
java/util/zip/ZipException

    # util datastructures (needed by compilers, classloaders, etc)
    #
java/util/AbstractList
java/util/AbstractMap
java/util/AbstractSet
java/util/ArrayList
java/util/Arrays
java/util/HashMap
java/util/HashSet
java/util/Hashtable
java/util/List
java/util/ListResourceBundle
java/util/PropertyResourceBundle
java/util/MissingResourceException
java/util/Properties
java/util/ResourceBundle
java/util/Vector
java/util/AbstractCollection
java/util/Collections
java/util/Stack
java/util/WeakHashMap

    # class loaders
    #
java/lang/ClassLoader
java/lang/VMClassLoader
java/lang/VMSecurityManager
gnu/java/io/PlatformHelper
java/security/CodeSource
java/security/Policy
java/security/PermissionCollection
java/security/Permissions
java/security/Principal
gnu/java/locale/Calendar
java/lang/reflect/InvocationTargetException

    # class loading from regular files
    #
java/io/File
java/io/DataInputStream
java/io/DataOutputStream
java/io/FilterInputStream
java/io/InputStream
java/io/FileInputStream
java/io/FileDescriptor
EOF

    if (( RVM_WITH_NON_BLOCKING_FDS_FOR_CLASSPATH )); then
	echo "java/io/VMFileDescriptor"
    fi

	cat <<EOF
    # class loading from zip files
    #
java/util/zip/ZipFile
java/util/zip/ZipFile
java/util/zip/ZipEntry
java/util/zip/Inflater
java/util/zip/InflaterInputStream
java/util/zip/Deflater
java/util/zip/DeflaterOutputStream
java/util/zip/ZipException
java/util/zip/Adler32
java/util/zip/StreamManipulator
java/util/zip/OutputWindow
java/util/zip/InflaterHuffmanTree
java/util/zip/DeflaterHuffman
java/util/zip/InflaterDynHeader
java/io/InputStreamReader
java/io/BufferedReader
java/io/Reader
java/lang/Math
java/io/Serializable
java/util/Calendar
java/util/GregorianCalendar
java/util/Locale
java/util/Date
java/util/TimeZone
java/util/SimpleTimeZone
java/lang/Cloneable
java/security/AccessController
java/security/PrivilegedAction
java/util/PropertyPermission
java/security/BasicPermission
java/security/Permission
java/security/AllPermission
java/security/AllPermissionCollection
java/lang/RuntimePermission
EOF
    
    # the application class loader uses jar classes (which can be loaded or not)

    if (( RVM_WITH_ALL_CLASSES )); then
	cat <<- EOF
java/util/jar/JarException
java/util/jar/JarInputStream
java/util/jar/Attributes
java/util/jar/JarOutputStream
java/util/jar/JarEntry
java/util/jar/JarFile
java/util/jar/Manifest
	EOF

    fi

	cat <<- EOF
java/io/BufferedOutputStream
java/io/BufferedInputStream
java/io/ByteArrayInputStream
java/io/FileOutputStream
java/io/PrintStream
java/io/RandomAccessFile
java/io/ObjectStreamField
EOF
    if (( RVM_WITH_OSR )); then
	cat <<- EOF
	# on stack replacement
com/ibm/JikesRVM/OSR/OSR_ObjectHolder
com/ibm/JikesRVM/OSR/OSR_BaselineExecStateExtractor
com/ibm/JikesRVM/OSR/OSR_OptExecStateExtractor
com/ibm/JikesRVM/OSR/OSR_EncodedOSRMap
com/ibm/JikesRVM/OSR/OSR_SpecialCompiler
com/ibm/JikesRVM/OSR/OSR_AdjustBCIndexes
com/ibm/JikesRVM/OSR/OSR_PostThreadSwitch
com/ibm/JikesRVM/adaptive/OSR_OnStackReplacementTrigger
com/ibm/JikesRVM/adaptive/OSR_OnStackReplacementEvent
com/ibm/JikesRVM/adaptive/OSR_OnStackReplacementPlan
com/ibm/JikesRVM/adaptive/OSR_OrganizerThread
EOF
    fi

	cat <<- EOF
java/io/PrintWriter
java/io/OutputStreamWriter
java/io/InputStreamReader
gnu/java/io/EncodingManager
gnu/java/io/decode/Decoder8859_1
gnu/java/io/decode/Decoder8859_2
gnu/java/io/decode/Decoder8859_3
gnu/java/io/decode/Decoder8859_4
gnu/java/io/decode/Decoder8859_5
gnu/java/io/decode/DecoderEightBitLookup
gnu/java/io/decode/DecoderUTF8
gnu/java/io/encode/Encoder8859_1
gnu/java/io/encode/Encoder8859_2
gnu/java/io/encode/Encoder8859_3
gnu/java/io/encode/Encoder8859_4
gnu/java/io/encode/Encoder8859_5
gnu/java/io/encode/EncoderEightBitLookup
gnu/java/io/encode/EncoderUTF8
java/lang/ref/Reference
java/lang/ref/ReferenceQueue
gnu/java/security/provider/DefaultPolicy
gnu/java/locale/Calendar_en
EOF
    if (( RVM_WITH_OPT_COMPILER )); then
	# data structures that need to carry over from boot image writing
	# and/or classes that opt wants to be in the bootimage to 
	# generate decent code (avoid dynamic linking, get them opt compiled)
	if (( RVM_WITH_OPT_BOOTIMAGE_COMPILER )); then
	cat <<- EOF
java/util/Enumeration
java/util/Dictionary
java/util/TreeMap
java/util/TreeSet
java/util/Stack

com/ibm/JikesRVM/opt/ir/OPT_CallSiteTreeNode
com/ibm/JikesRVM/opt/OPT_FieldAnalysis
com/ibm/JikesRVM/opt/OPT_FieldDatabase
com/ibm/JikesRVM/opt/OPT_SpecializedMethod
com/ibm/JikesRVM/opt/OPT_InvokeeThreadLocalContext
com/ibm/JikesRVM/opt/OPT_SpecializedMethodPool
com/ibm/JikesRVM/opt/OPT_SpecializationDatabase

com/ibm/JikesRVM/opt/OPT_ClassLoadingDependencyManager
com/ibm/JikesRVM/opt/OPT_InvalidationDatabase
com/ibm/JikesRVM/opt/OPT_InterfaceHierarchy
com/ibm/JikesRVM/opt/OPT_SummaryDatabase
com/ibm/JikesRVM/opt/OPT_MethodSummary
EOF
	fi

	if (( RVM_WITH_ADAPTIVE_SYSTEM )); then
	    echo com/ibm/JikesRVM/opt/OPT_ContextFreeInlinePlan
	fi
    fi

    if (( RVM_WITH_HPM )) ; then
	cat << EOF
com/ibm/JikesRVM/HPM_counters
com/ibm/JikesRVM/HPM_info
Lcom/ibm/JikesRVM/Java2HPM;
EOF
    fi
    cat <<- EOF
EOF_PRIMORDIAL_CLASSES_STR_1
	#
	# (3) Now that we have a big file of root classes to include, 
	#     process the exclusions,
	#     find all the compiler-generated classes,
	#     and convert to internal names.
	    \$FGREP -v -f $EXCLUDED_CLASSES_STR ${PRIMORDIAL_CLASSES_STR}.1 | \${SED} -e'/\\\$/d' -e 's@^\\./@@' -e 's@\.class\$@@' -e 's@^\\(.*\\)\$@\\1.class\\
\\1\$@' > ${PRIMORDIAL_CLASSES_STR}.2
	    $HOST_JAR_STR tf rvmrt.jar > $PRIMORDIAL_CLASSES_STR.3
	    \$FIND . -name '*.class' -print | \$SED 's@^\./@@' >> $PRIMORDIAL_CLASSES_STR.3
	    > $PRIMORDIAL_CLASSES_STR # Create it clean
#	DEBUGGING -- lets us test for junk in the RVM.primordials file:
#	    echo fi > $PRIMORDIAL_CLASSES_STR
	    \$FGREP -f $PRIMORDIAL_CLASSES_STR.2 $PRIMORDIAL_CLASSES_STR.3 | \$SED 's@\(.*\)\.class@L\1;@' >> $PRIMORDIAL_CLASSES_STR
	    rm $PRIMORDIAL_CLASSES_STR.1
	    rm $PRIMORDIAL_CLASSES_STR.2
	    rm $PRIMORDIAL_CLASSES_STR.3
	# 
	# (4) Add Array types.  NOTE: These must be in internal form.
	#
	\${SED} -e 's/#.*//' -e '/^\$/d' >> $PRIMORDIAL_CLASSES_STR << 'EOF_PRIMORDIAL_CLASSES_STR'
	[Ljava/util/AbstractSet;
	[Ljava/util/HashSet;
	[Ljava/util/HashMap\$HashEntry;
	[Ljava/util/WeakHashMap\$WeakBucket;
	[Ljava/security/Principal;

	[Ljava/util/zip/ZipEntry;
	[Lcom/ibm/JikesRVM/VM_LockNursery\$VM_LockBucket;
	[Lcom/ibm/JikesRVM/classloader/VM_Atom;
	[Lcom/ibm/JikesRVM/VM_BasicBlock;
	[Lcom/ibm/JikesRVM/classloader/VM_Field;
	[Lcom/ibm/JikesRVM/classloader/VM_Method;
	[Lcom/ibm/JikesRVM/classloader/VM_MemberReference;
	[Lcom/ibm/JikesRVM/classloader/VM_Type;
	[Lcom/ibm/JikesRVM/classloader/VM_TypeReference;
	[Lcom/ibm/JikesRVM/memoryManagers/vmInterface/VM_CollectorThread;
	[Lcom/ibm/JikesRVM/memoryManagers/JMTk/VMResource;
	[Lcom/ibm/JikesRVM/memoryManagers/JMTk/MemoryResource;
	[Lcom/ibm/JikesRVM/memoryManagers/JMTk/Plan;
	[Lcom/ibm/JikesRVM/memoryManagers/JMTk/SynchronizedCounter;
	[Ljava/lang/Object;
	[[Ljava/lang/Object;
	[Ljava/lang/String;
	[Ljava/lang/Class;
	[Ljava/lang/reflect/Field;
	[Ljava/lang/reflect/Method;
	[Ljava/lang/reflect/Member;
	[Ljava/lang/reflect/Constructor;
	[Ljava/io/ObjectStreamField;
	[Ljava/security/ProtectionDomain;
	[Ljava/lang/Package;

	[B
	[C
	[I
	[F
	[D
	[J
	[S
	[Z
	[[I
	[[B
	[[D
	[[[I

	# These next arrays are really arrays of primitves to Jikes RVM 
	#  (even though Java doesn't think they are...)
	[Lcom/ibm/JikesRVM/VM_Address;
	[Lcom/ibm/JikesRVM/VM_Word;
	[Lcom/ibm/JikesRVM/VM_Offset;
	[Lcom/ibm/JikesRVM/VM_Extent;
	[Lcom/ibm/JikesRVM/VM_Code;
	    
	[Lcom/ibm/JikesRVM/VM_CodeArray;

	[Lcom/ibm/JikesRVM/classloader/VM_Class;
	[Lcom/ibm/JikesRVM/VM_UnusualMaps;
	[Lcom/ibm/JikesRVM/VM_Processor;
	[Lcom/ibm/JikesRVM/VM_Thread;
	[Lcom/ibm/JikesRVM/VM_Lock;
	[Lcom/ibm/JikesRVM/VM_CompiledMethod;
	[Lcom/ibm/JikesRVM/VM_DynamicLibrary;

	[Lcom/ibm/JikesRVM/classloader/VM_InterfaceMethodSignature; # For fast interface method invoker

	[Lcom/ibm/JikesRVM/VM_CommandLineArgs\$Prefix; # For command-line argument processing
	EOF
    if (( RVM_WITH_OPT_COMPILER )); then
	cat <<- EOF
		[[C
		[Ljava/util/HashSet;
	EOF
	if (( RVM_WITH_ALL_CLASSES )); then
	cat <<- EOF
		[Lcom/ibm/JikesRVM/opt/OPT_OperatorClass;
		[Lcom/ibm/JikesRVM/opt/OPT_ResourceReservation;
		[Lcom/ibm/JikesRVM/opt/ir/OPT_Operator;
		[Lcom/ibm/JikesRVM/opt/ir/OPT_Register;
	EOF
	fi

	if (( RVM_WITH_ADAPTIVE_SYSTEM )); then
	cat <<- EOF
		[Lcom/ibm/JikesRVM/adaptive/VM_MethodListener;
		[Lcom/ibm/JikesRVM/adaptive/VM_EdgeListener;
		[Lcom/ibm/JikesRVM/adaptive/VM_ContextListener;
		[Lcom/ibm/JikesRVM/adaptive/VM_NullListener;
EOF
	fi
    fi

# Add the configuration specific primordials
#
    for primordial in $CONF_SPECIFIC_PRIMORDIALS_LIST; do
	echo $primordial
    done

cat <<-EOF
EOF_PRIMORDIAL_CLASSES_STR
EOF
    echo '    echo -n "(primordial class names written) "'
    echo 'fi'

    echo "\
# Create bootimage.
#"
    BOOTIMAGE_WRITER_ARGS="\$DEMOGRAPHICS_FLAG \$BOOTIMAGE_WRITER_TRACE_FLAG"

    BOOTIMAGE_WRITER_ARGS="$BOOTIMAGE_WRITER_ARGS -ia $BOOTIMAGE_LOAD_ADDRESS"

    if (( GENERATE_MAP )); then
	BOOTIMAGE_WRITER_ARGS="$BOOTIMAGE_WRITER_ARGS -m $BOOTIMAGE_MAP_STR"
    fi
    
    if (( RVM_FOR_IA32 )); then
	BOOTIMAGE_WRITER_ARGS="$BOOTIMAGE_WRITER_ARGS -littleEndian"
    fi

    echo ""
    echo 'OPT_ARGS="'$OPT_ARGS' $DEBUG_ARGS"'

    if (( RVM_WITH_NOFLUSH )); then
	echo ' OPT_ARGS="$OPT_ARGS -X:bc:no_cache_flush=true"'
    fi

    echo "if tracing BootImageWriter; then"
    echo '    OPT_ARGS="$OPT_ARGS -X:bc:verbose=true"'
    echo '    VERBOSE_STR="VERBOSE_ARG=-verbose:gc"'
    echo 'fi'
    echo "if tracing preprocessor; then"
    echo '    PREPROC_TRACE_FLAG="-trace"'
    echo 'else'
    echo '    PREPROC_TRACE_FLAG=""'
    echo 'fi'
    echo ""

    # copy and preprocess BootImageWriter sources
    #
    echo ''
    echo "BOOTIMAGE_WRITER_TRACE_FLAG="
    echo "if tracing BootImageWriter; then"
    echo '    echo -n "$ME: '$BOOTIMAGE_WRITER_DIR_STR'"'
    echo "    BOOTIMAGE_WRITER_TRACE_FLAG=-trace"
    echo 'fi'
    echo "FILES=\$(echo $BOOTIMAGE_WRITER_DIR_STR/*.java)"
    echo "if ! [[ \$FILES ]]; then"
    echo "    echo >&2 \$ME: Trouble: Cannot find any files in $BOOTIMAGE_WRITER_DIR_STR!"
    echo "    trap '' EXIT"
    echo "    exit 2"
    echo "fi"
    # See above comment in jconfigure on xargs.
    echo "echo \$FILES | \$XARGS -r \"$BUILD_DIRECTORY_STR/jbuild.prep.host\" --disable-modification-exit-status \$PREPROC_TRACE_FLAG" $PREPROCESSOR_DEFINITIONS $SCRATCH_DIRECTORY_STR 
    # echo $BUILD_DIRECTORY_STR/jbuild.prep.host --disable-modification-exit-status '$PREPROC_TRACE_FLAG' $PREPROCESSOR_DEFINITIONS $SCRATCH_DIRECTORY_STR "\$FILES"
    echo "if tracing preprocessor; then"
    echo '    echo ""'
    echo 'fi'
    echo ''

    # compile BootImageWriter.java
    #
    echo "cd $SCRATCH_DIRECTORY_STR &&\
	  $HOST_JAVAC_STR -nowarn -g \
	  -classpath .:$BUILD_DIRECTORY_STR/RVM.classes:$BUILD_DIRECTORY_STR/RVM.classes/rvmrt.jar\
	  -bootclasspath $BUILD_DIRECTORY_STR/RVM.classes:$BUILD_DIRECTORY_STR/RVM.classes/rvmrt.jar\
	  BootImageWriter.java"

    # copy and preprocess GenerateInterfaceDeclarations.java
    #
    echo ''
    echo "if tracing jbuild; then"
    echo "    echo -n \"\$ME: $BOOTIMAGE_RUNNER_DIR_STR\""
    echo "fi"
    echo "FILE=$BOOTIMAGE_RUNNER_DIR_STR/GenerateInterfaceDeclarations.java"
    echo "if ! [[ -f \$FILE ]]; then"
    echo "    echo >&2 \$ME: Trouble: Cannot find \$FILE!"
    echo "    trap '' EXIT"
    echo "    exit 2"
    echo "fi"
    # We explicitly do not double-quote $PREPROCESSOR_DEFINITIONS, since we
    # need the newlines in that string to be replaced with spaces.
    echo "$BUILD_DIRECTORY_STR/jbuild.prep.host --disable-modification-exit-status \$PREPROC_TRACE_FLAG" $PREPROCESSOR_DEFINITIONS "$SCRATCH_DIRECTORY_STR  \$FILE"
    echo "if tracing jbuild; then"
    echo '    echo ""'
    echo 'fi'
    echo '
#
# compile GenerateInterfaceDeclarations.java
#'
    echo "cd $SCRATCH_DIRECTORY_STR &&\
	  $HOST_JAVAC_STR -nowarn -g \
	  -classpath $BUILD_DIRECTORY_STR/RVM.classes:$BUILD_DIRECTORY_STR/RVM.classes/rvmrt.jar\
	  -bootclasspath $BUILD_DIRECTORY_STR/RVM.classes:$BUILD_DIRECTORY_STR/RVM.classes/rvmrt.jar\
	  GenerateInterfaceDeclarations.java"

    echo '#
# generate InterfaceDeclarations.h
#'
    echo "rm -f $SCRATCH_DIRECTORY_STR/InterfaceDeclarations.h"
    echo "cd $SCRATCH_DIRECTORY_STR && $HOST_JAVA_STR -Xms200M -Xmx200M\
	  -classpath .:$CLASSES_DIRECTORY_STR:$CLASSES_DIRECTORY_STR/rvmrt.jar\
	  GenerateInterfaceDeclarations -ia $BOOTIMAGE_LOAD_ADDRESS >\
	  $SCRATCH_DIRECTORY_STR/InterfaceDeclarations.h"
    echo ""

    echo "cd $BOOTIMAGE_WRITER_DIR_STR"

    echo "$GNU_MAKE_STR -f $BOOTIMAGE_WRITER_MAKEFILE \$SILENT_MAKE \$VERBOSE_STR\
	  RVM_REPOSITORIES=$CLASSES_DIRECTORY_STR/jksvm.jar:$CLASSES_DIRECTORY_STR/rvmrt.jar\
	  RVM_BOOTIMAGE_CLASSES=$PRIMORDIAL_CLASSES_STR\
	  RVM_BOOTIMAGE=$BOOTIMAGE_STR\
	  RVM_BOOTIMAGE_COMPILER_ARGS=\"\$OPT_ARGS\"\
	  RVM_BOOTIMAGE_WRITER_ARGS=\"$BOOTIMAGE_WRITER_ARGS\"\
	  SCRATCH_DIR=$SCRATCH_DIRECTORY_STR\
	  $BOOTIMAGE_STR"

    echo "if tracing jbuild; then"
    echo '  echo ""'
    echo 'fi'
}

function emitCheckIfIAmTheTarget () {
    echo "# Make sure that the architecture and O/S I'm running on are"
    echo "# the ones I should be on in order to link native executables."
    echo "# (This assumes we can only link native executables on the"
    echo "# native software and O/S.)"


    if (( RVM_FOR_AIX )); then
	echo "if [[ \$(uname) != AIX ]]; then"
	echo '    echo "please run me on AIX"'
	echo '    trap "" EXIT'
	echo "    exit $Exit_Status_Run_Linker"
	echo 'fi'
    elif (( RVM_FOR_LINUX )); then
	echo "if [[ \$(uname) != Linux ]]; then"
	echo '    echo "please run me on Linux"'
	echo '    trap "" EXIT'
	echo "    exit $Exit_Status_Run_Linker"
	echo 'fi'

	if (( RVM_FOR_POWERPC )); then
	    echo "if [[ \$(uname -m) != ppc ]]; then"
	    echo '    echo "please run me on Linux PowerPC"'
	    echo '    trap "" EXIT'
	    echo "    exit $Exit_Status_Run_Linker"
	    echo 'fi'
	elif (( RVM_FOR_IA32 )); then
	    echo "if [[ \$(uname -m) != i686 ]]; then"
	    echo '    echo "please run me on Linux IA32"'
	    echo '    trap "" EXIT'
	    echo "    exit $Exit_Status_Run_Linker"
	    echo 'fi'
	fi
    fi
    echo ""
}

# Emit script to generate jbuild.linkBooter, the vm booter, 
# echo >&2  "HERE I AM! emitBooterLinker" # DBG
function emitBooterLinker () {
    echo '#! /bin/bash'
    echo ""
    echo '# Generate vm booter.'
    echo ""
    echo '# Taken:    InterfaceDeclarations.h in bootImageRunner directory'
    echo '# Returned: booter in build directory'
    echo ""
    echo '# Allow the build directory to be different between'
    echo '# the host/boot image'
    echo '# writing system and the target system.'
    echo ""
    emitBoilerplate
    echo 'ROOT_DIR="${0%/*}"'
    echo '# If a relative path, go over to a fully-qualified path.'
    echo 'if [[ "$ROOT_DIR" = "." ]]; then'
    echo '    ROOT_DIR="$PWD"'
    echo 'fi'
    echo '# I do not understand the point behind this code. --Steve Augart'
    echo '# The strange part for me is that CURRENT_DIR is not defined anywhere else in this build process.'
    echo 'if [[ "$ROOT_DIR" != "$CURRENT_DIR" ]]; then'
    echo '    if [[ -f "$CURRENT_DIR"/"$ROOT_DIR"/"$ME" ]]; then'
    echo '      ROOT_DIR=$CURRENT_DIR/$ROOT_DIR'
    echo '    fi'
    echo 'fi'
    echo ""
    echo ". \$ROOT_DIR/environment.target"
    echo ""
    echo "$BUILD_DIRECTORY_STR1=\$ROOT_DIR"
    echo ""

    echo 'unset TRACE_FLAG VFLAG XFLAG CLEAN_FLAG || :'
    echo 'SILENT_MAKE=--silent'
    echo "while (( \$# > 0 )); do"
    echo '    arg="$1"'
    echo '    [[ $arg != --?* ]] || arg="${arg#-}"'
    echo "    if [[ \$arg == -trace* ]]; then"
    echo '        TRACE_FLAG="$arg"'
    echo "    elif [[ \$arg = -v ]]; then"
    echo "        VFLAG=-v"
    echo "    elif [[ \$arg = -x ]]; then"
    echo "        XFLAG=-x"
    echo "    elif [[ \$arg = -clean ]]; then"
    echo "        CLEAN_FLAG=-clean"
    echo "    else"
    echo "        echo >&2 \"\$ME: Unknown argument: \$arg\""
    echo "	  trap '' EXIT"
    echo "        exit $Exit_Status_Bad_Args"
    echo "    fi"
    echo "    shift"
    echo "done"
 
    echo "if tracing make; then"
    echo "    SILENT_MAKE="
    echo "fi"
    echo "echo -n \"\$ME: \""
#    echo "! tracing jbuild || XFLAG=-x"
#    echo "[[ \$VFLAG ]] || VFLAG=+v"
#    echo "[[ \$XFLAG ]] || XFLAG=+x"
    echo "[ ! \"\$VFLAG\$XFLAG\" ] || set \$VFLAG \$XFLAG"

    echo ""
    echo "rm -f libjni.a"
    echo "cd $SCRATCH_DIRECTORY_STR"
    echo "rm -f $BOOTER_STR RunBootImage.o initBootRecord.o sys.o bootThread.o bootThread.s libvm.o RunBootImage.h preprocessModifiedFiles"
    echo 'echo -n "(booter cleaned) "'
    echo "if [[ \$CLEAN_FLAG ]]; then"

    echo '    trap "" EXIT'
    echo '    exit 0'
    echo 'fi'
    echo ""

    emitCheckIfIAmTheTarget
    echo ""

    if [[ $RVM_HOST_CONFIG != $RVM_TARGET_CONFIG ]]; then
	echo "  \$JAL_ROOT/rvm/bin/jBuildClasspathJar --check"
    fi

    # copy native libraries
    if [[ $CLASSPATH_ROOT ]]; then
	CPS=$CLASSPATH_ROOT
    else
	CPS=$RVM_ROOT/classpath
    fi
    echo "SYSTEM_TYPE=\$(${CPS}/classpath/config.guess)"
    ## AIX requires that dynamically loaded libraries end in .a, 
    ## so that dlopen() will find them.  Also, the classpath builder, on AIX,
    ## generates the files with the suffix ".so.0".  We transform one to the othr.
    if (( RVM_FOR_AIX )); then
	echo 'for _library in' $CPS/'$SYSTEM_TYPE/native/jni/*/.libs/*.so.0; do'
	echo '    oldbase=$(basename ${_library} .so.0)'
	echo '    dest_lib='${BUILD_DIRECTORY_STR}'/${oldbase}.a'
	echo '    cp $_library $dest_lib'
	echo 'done'
	echo 'unset oldbase dest_lib _library || :'
    else
	## On Linux, on the other hand, dynamically loaded libraries end in 
	## .so.  The classpath builder conveniently generates them 
	## with this suffix.
	echo 'cp -f '$CPS'/$SYSTEM_TYPE/native/jni/*/.libs/*.so '$BUILD_DIRECTORY_STR
    fi
    echo -e "\necho -n '(classpath native libraries copied) '"

    # Make a target platform preprocessor for use in gctest
    echo "${GNU_MAKE_STR} \${SILENT_MAKE} -C ${ROOT_DIRECTORY_STR}/rvm/src/tools/preprocessor INCLUDED_MAKEFILE=${BUILD_DIRECTORY_STR}/Make.rules.target tool SCRATCH_DIR=${SCRATCH_DIRECTORY_STR}"
    echo "cp ${SCRATCH_DIRECTORY_STR}/preprocessModifiedFiles ${BUILD_DIRECTORY_STR}/jbuild.prep.target"

    # Create RunBootImage.h file.
    echo "echo \"// RunBootImage.C boot-time constants\" >> RunBootImage.h"
    echo "echo \"const int heap_default_initial_size  = $DEFAULT_INITIAL_HEAP_SIZE*1024*1024;\" >> RunBootImage.h"
    echo "echo \"const int heap_default_maximum_size      = $DEFAULT_MAXIMUM_HEAP_SIZE*1024*1024;\" >> RunBootImage.h"
    echo "echo \"const char *rvm_version              = \\\"$JIKESRVM_VERSION\\\";\" >> RunBootImage.h"
    echo "echo \"const char *rvm_configuration        = \\\"$CONFIGURATION_NAME\\\";\" >> RunBootImage.h"
    echo "echo \"const char *rvm_host_configuration   = \\\"$RVM_HOST_CONFIG\\\";\" >> RunBootImage.h"
    echo "echo \"const char *rvm_target_configuration = \\\"$RVM_TARGET_CONFIG\\\";\" >> RunBootImage.h"
    echo ""

    # build the JNI library for creating processes
    echo "cd \${JAL_ROOT}/rvm/src/tools/bootImageRunner/"
    if (( RVM_FOR_AIX )); then
	local -r shlib_suffix=.a
    else
	local -r shlib_suffix=.so
    fi
    echo '$GNU_MAKE $SILENT_MAKE -f Makefile.proc DEST=$JAL_BUILD/libjpnexec'${shlib_suffix}' $JAL_BUILD/libjpnexec'${shlib_suffix}

    if (( RVM_FOR_SINGLE_VIRTUAL_PROCESSOR )); then
	CC_DEFINES="-DRVM_FOR_SINGLE_VIRTUAL_PROCESSOR"
    else 
	CC_DEFINES="-URVM_FOR_SINGLE_VIRTUAL_PROCESSOR"
    fi

    if (( RVM_FOR_32_ADDR )); then
	CC_DEFINES="$CC_DEFINES -DRVM_FOR_32_ADDR -URVM_FOR_64_ADDR"
    fi
    if (( RVM_FOR_64_ADDR )); then
	CC_DEFINES="$CC_DEFINES -DRVM_FOR_64_ADDR -URVM_FOR_32_ADDR"
    fi
  
    if (( RVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS )); then
	CC_DEFINES="$CC_DEFINES -DRVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS"
    else
	# Build the blocking system call wrapper library, if requested
	echo '$GNU_MAKE $SILENT_MAKE -f Makefile.syswrap DEST=$JAL_BUILD/libsyswrap'${shlib_suffix}' CXXFLAGS="'"$CC_DEFINES"'" $JAL_BUILD/libsyswrap'${shlib_suffix}
    fi

    if (( RVM_FOR_POWERPC && RVM_FOR_AIX )); then
	echo "BOOTER_CC=\"$HOST_CPLUS_STR \${CXXFLAGS} -g -O2 -DRVM_FOR_AIX -DRVM_FOR_POWERPC $CC_DEFINES\""
 	 echo "LDSHARED=\"$HOST_SHLD_STR\""
	echo 'BOOTER_CCM="$BOOTER_CC -M"'
	echo "CPP=\"$HOST_CC_STR -E $CC_DEFINES\""

	echo 'CCLIBS="-lpthread -lm"'
	echo 'IMAGE='

    elif (( RVM_FOR_POWERPC && RVM_FOR_LINUX && RVM_FOR_SINGLE_VIRTUAL_PROCESSOR )); then
	echo "BOOTER_CC=\"$HOST_CPLUS_STR \${CXXFLAGS} -g -O2 -DRVM_FOR_LINUX -DRVM_FOR_POWERPC $CC_DEFINES\""
 	echo "LDSHARED=\"$HOST_SHLD_STR\""
	echo "BOOTER_CCM=\$BOOTER_CC"
	echo "CPP=\"$HOST_CPP_STR $CC_DEFINES\""

	echo 'CCLIBS="${EXTRA_CCLIBS} -ldl -lm"'
	echo 'IMAGE="-DIMAGE_ADDRESS=0x31000000"'

    elif (( RVM_FOR_POWERPC && RVM_FOR_LINUX && !RVM_FOR_SINGLE_VIRTUAL_PROCESSOR )); then
	echo "BOOTER_CC=\"$HOST_CPLUS_STR \${CXXFLAGS} -g -O2 -rdynamic -DRVM_FOR_LINUX -DRVM_FOR_POWERPC $CC_DEFINES\""
	echo "LDSHARED=\"$HOST_SHLD_STR\""
	echo "BOOTER_CCM=\$BOOTER_CC"
	echo "CPP=\"$HOST_CPP_STR $CC_DEFINES -D__linuxsmp__\""
	
	echo 'CCLIBS="-lpthread -ldl -lm"'
	echo 'IMAGE="-DIMAGE_ADDRESS=0x31000000"' 

    elif (( RVM_FOR_IA32 && RVM_FOR_LINUX && !RVM_FOR_SINGLE_VIRTUAL_PROCESSOR )); then
	echo "BOOTER_CC=\"$HOST_CPLUS_STR \${CXXFLAGS} -g -O2 -rdynamic -DRVM_FOR_LINUX -DRVM_FOR_IA32 -D_REENTRANT $CC_DEFINES\""

	echo 'CCLIBS="-lpthread -ldl"'
	echo 'IMAGE='
    elif (( RVM_FOR_IA32 && RVM_FOR_LINUX && RVM_FOR_SINGLE_VIRTUAL_PROCESSOR )); then
	echo "BOOTER_CC=\"$HOST_CPLUS_STR \${CXXFLAGS} -g -O2 -DRVM_FOR_LINUX -DRVM_FOR_IA32 $CC_DEFINES\""

	echo 'CCLIBS="-ldl"'
	echo 'IMAGE='
    fi
    echo ""

    if (( RVM_FOR_POWERPC && ( RVM_FOR_AIX || RVM_FOR_LINUX ) )); then
	echo "cd $BOOTIMAGE_RUNNER_DIR_STR &&\
		\$BOOTER_CC -c -O -I$SCRATCH_DIRECTORY_STR\
		-I$BOOTIMAGE_RUNNER_SUBDIR_STR\
		\$IMAGE -DRVM_BOOTIMAGE=\\\"$BOOTIMAGE_STR\\\"\
		-o $SCRATCH_DIRECTORY_STR/RunBootImage.o RunBootImage.C"

	echo "cd $BOOTIMAGE_RUNNER_SUBDIR_STR &&\
	    \$BOOTER_CC -c -O -I. -I$SCRATCH_DIRECTORY_STR \
	    -o $SCRATCH_DIRECTORY_STR/initBootRecord.o initBootRecord.C"
	
	echo "cd $BOOTIMAGE_RUNNER_SUBDIR_STR &&\
		\$CPP -I$SCRATCH_DIRECTORY_STR -P\
		bootThread.c > $SCRATCH_DIRECTORY_STR/bootThread.s"
	echo "\$BOOTER_CC -c -o $SCRATCH_DIRECTORY_STR/bootThread.o\
		$SCRATCH_DIRECTORY_STR/bootThread.s"
	echo "cd $BOOTIMAGE_RUNNER_SUBDIR_STR &&\
		\$BOOTER_CC -c -I. -I$SCRATCH_DIRECTORY_STR\
		\$IMAGE -DRVM_BOOTIMAGE=\\\"$BUILD_DIRECTORY_STR/RVM.image\\\"\
		-o $SCRATCH_DIRECTORY_STR/libvm.o libvm.C"

	if (( $RVM_WITH_HPM )); then
	echo "cd $BOOTIMAGE_RUNNER_DIR_STR &&\
	    \$BOOTER_CC -c -O -I$SCRATCH_DIRECTORY_STR -DRVM_WITH_HPM=1\
	    -o $SCRATCH_DIRECTORY_STR/sys.o sys.C"
	
	echo 'echo -n "(build libhpm.a library) "'
	echo "cd $ROOT_DIRECTORY_STR/rvm/src/vm/arch/powerPC/runtime &&\
	    \$BOOTER_CC -c -O -o $SCRATCH_DIRECTORY_STR/hpm.o hpm.c"
	echo "cd $SCRATCH_DIRECTORY_STR &&\
	        \$LDSHARED -o \$JAL_BUILD/libhpm.a  hpm.o -L\"$RVM_HPM_DIR\" -lpmapi"

	echo "cd $SCRATCH_DIRECTORY_STR &&\
	    \$BOOTER_CC -o $BOOTER_STR RunBootImage.o initBootRecord.o libvm.o sys.o bootThread.o \$CCLIBS\
	    -L\"$RVM_HPM_DIR\" -lpmapi -L\"\$JAL_BUILD\" -lhpm"

	echo 'echo -n "(build libJava2HPM.a JNI library) "'
	echo "cd $ROOT_DIRECTORY_STR/rvm/src/vm/arch/powerPC/runtime &&\
  		\$BOOTER_CC -c -O -I$SCRATCH_DIRECTORY_STR -I$ROOT_DIRECTORY_STR/rvm/src/include\
 		-o $SCRATCH_DIRECTORY_STR/Java2HPM.o Java2HPM.C"

	echo "cd $SCRATCH_DIRECTORY_STR &&\
	        \$LDSHARED -o \$JAL_BUILD/libJava2HPM.a  Java2HPM.o\
	        -L\"$RVM_HPM_DIR\" -lpmapi -L\"\$JAL_BUILD\" -lhpm > /dev/null 2>&1"
	else
	echo "cd ${BOOTIMAGE_RUNNER_DIR_STR} &&\
	    \${BOOTER_CC} -c -O -I${SCRATCH_DIRECTORY_STR}\
	    -o ${SCRATCH_DIRECTORY_STR}/sys.o sys.C"
	echo "cd ${SCRATCH_DIRECTORY_STR} &&\
	    \${BOOTER_CC} -o ${BOOTER_STR} RunBootImage.o initBootRecord.o libvm.o sys.o bootThread.o \${CCLIBS}"
	fi
	echo 'echo -n "(booter linked)"'

    elif (( RVM_FOR_IA32 && RVM_FOR_LINUX )); then
	echo "cd ${BOOTIMAGE_RUNNER_DIR_STR} &&\
		\${BOOTER_CC} -c -I${SCRATCH_DIRECTORY_STR}\
		\${IMAGE} -DRVM_BOOTIMAGE=\\\"${BOOTIMAGE_STR}\\\"\
		-o ${SCRATCH_DIRECTORY_STR}/RunBootImage.o RunBootImage.C"
	echo "cd ${BOOTIMAGE_RUNNER_SUBDIR_STR} &&\
		\${BOOTER_CC} -c -I. -I${SCRATCH_DIRECTORY_STR}\
		-o ${SCRATCH_DIRECTORY_STR}/initBootRecord.o initBootRecord.C"
	echo "cd ${BOOTIMAGE_RUNNER_DIR_STR} &&\
		\${BOOTER_CC} -c -I${SCRATCH_DIRECTORY_STR}\
		-o ${SCRATCH_DIRECTORY_STR}/sys.o sys.C"
	echo "cd ${BOOTIMAGE_RUNNER_SUBDIR_STR} &&\
		\${BOOTER_CC} -c -I${SCRATCH_DIRECTORY_STR}\
		-o ${SCRATCH_DIRECTORY_STR}/bootThread.o bootThread.S"
	echo "cd ${BOOTIMAGE_RUNNER_SUBDIR_STR} &&\
		\${BOOTER_CC} -c -I${SCRATCH_DIRECTORY_STR}\
	        -I${ROOT_DIRECTORY_STR}/rvm/src/vm/arch/intel/disassembler\
		-o ${SCRATCH_DIRECTORY_STR}/libvm.o libvm.C"
	echo "cd ${ROOT_DIRECTORY_STR}/rvm/src/vm/arch/intel/disassembler &&\
		\${BOOTER_CC} -funsigned-bitfields -c -I${SCRATCH_DIRECTORY_STR}\
		-o ${SCRATCH_DIRECTORY_STR}/disasm.o disasm.C"
	echo "cd ${ROOT_DIRECTORY_STR}/rvm/src/vm/arch/intel/disassembler &&\
		\${BOOTER_CC} -funsigned-bitfields -c -I${SCRATCH_DIRECTORY_STR}\
		-o ${SCRATCH_DIRECTORY_STR}/ihnpdsm.o ihnpdsm.C"
	echo "cd ${SCRATCH_DIRECTORY_STR} &&\
	    \${BOOTER_CC} -o ${BOOTER_STR} RunBootImage.o initBootRecord.o sys.o bootThread.o libvm.o\
	                           disasm.o ihnpdsm.o \${CCLIBS}"
	echo 'echo "(booter linked)"'
	echo ""

    else
	echo 'echo "I do not know how to link the booter"'
	echo 'trap "" EXIT'
	echo 'exit' $Exit_Status_Run_Linker
    fi
}

# Emit script to generate .class files for vm tools that are not part of 
# the build.   This becomes jbuild.tool
#
# echo >&2  "HERE I AM! emitToolCompiler" # DBG
function emitToolCompiler () {
    echo '#! /bin/bash'
    echo '# Generate class files for vm tools that are not part of the build.'
    echo '# This runs the Jikes Compiler with the'
    echo '# classpath and command-line flags set up so that we can just'
    echo '# make .class files for Jikes RVM to run.'
    emitBoilerplate
    echo ". \${RVM_BUILD}/environment.target"

    echo "function usage () {"
    echo '    echo 2>&1 "usage: ${ME} [ -trace[=<commands>] ] [ -classpath x:y:z ] [ -- ] java-file [ java-file... ]"'
    echo '    trap "" EXIT'
    echo "    exit $Exit_Status_Bad_Args"
    echo '}'

    echo 'if [[ '${BUILD_DIRECTORY_STR}' = "" ]]; then'
    echo '    echo >&2 "${ME}: please set your' ${BUILD_DIRECTORY_STR1} 'environment variable (eg. ${HOME}/rvmBuild)"'
    echo '    trap "" EXIT'
    echo '    exit' $Exit_Status_Bad_Args
    echo 'fi'

    echo 'if [[ '${HOST_JAVAC_STR}' = "" ]]; then'
    echo '    echo >&2 "${ME}: please set your' ${HOST_JAVAC_STR1} 'environment variable"'
    echo '    trap "" EXIT'
    echo '    exit' $Exit_Status_Bad_Args
    echo 'fi'

    echo 'unset EXTRA_CPATH TRACE_FLAG XFLAG VFLAG || :'
    echo 'while :; do'
    echo '    arg="$1"'
    echo '    [[ $arg != -- ]] || { shift ; break; }'
    echo '    [[ \$arg != --?* ]] || arg="\${arg#-}"'
    echo "    if [[ \$arg = -classpath ]]; then"
    echo '        (( $# > 1 )) || usage'
    echo '        EXTRA_CPATH=$2${EXTRA_CPATH+:}${EXTRA_CPATH}'
    echo '        shift'
    echo '        shift'
    echo "    elif [[ \$arg = -v ]]; then"
    echo "        VFLAG=-v"
    echo '        shift'
    echo "    elif [[ \$arg = -x ]]; then"
    echo "        XFLAG=-x"
    echo '        shift'
    echo '    elif [[ $arg == -trace* ]]; then'
    echo '        TRACE_FLAG=$arg'
    echo '        shift'
#    echo '    elif [[ $arg == -* ]]; then'
#    echo '        echo >&2 "${ME}: Unknown argument: $arg"'
#    echo '	  exit 33'
    echo '    else'
    echo '        break	# must be a regular argument or a flag we do not handle.'
    echo '    fi'
    echo 'done'
    echo ""    
    echo "CPATH=\${EXTRA_CPATH-.}:${BUILD_DIRECTORY_STR}/RVM.classes:${BUILD_DIRECTORY_STR}/RVM.classes/rvmrt.jar"
    echo "! tracing jbuild || XFLAG=-x"
    echo "[ ! \"\$VFLAG\$XFLAG\" ] || set \$VFLAG \$XFLAG"
    echo ""
    echo "exec $HOST_JAVAC_STR -nowarn -g -classpath \"\$CPATH\" -bootclasspath \"\$CPATH\" \"\$@\""
}
  
# Emit script to run jbuild.prep.target on java files that are not part of the build
#
function emitToolPreprocessor () {
    echo '#! /bin/bash'
    echo "# Run Jikes RVM's preprocessor on some source code files."
    echo "# Provides all of the standard preprocessor definitions we need for"
    echo "# the target environment.  Sticks the pure .java files that are the output"
    echo "# into the <output-directory> specified as the first non-flag"
    echo "# command-line argument."
    emitBoilerplate;
    echo '. "$RVM_BUILD/environment.target"'

    echo "if (( \$# == 0 )); then"
    echo '    echo >&2 "usage: $ME [ extra-preprocessor-flags...] output-directory java-file [ java-file... ]"'
    echo '    trap "" EXIT'
    echo "    exit $Exit_Status_Bad_Args"
    echo 'fi'

    echo 'exec "$RVM_BUILD/jbuild.prep.target"' $PREPROCESSOR_DEFINITIONS '"$@"'
}
  
function emitPluginBuilder () {
    cat <<- EOF
	#! /bin/bash
	# Build and install Jikes RVM launching plugin for Eclipse 2.x

	# pick up configuration to learn where Ant is
	$(emitBoilerplate)

	. "\${RVM_BUILD}/environment.target"


	usage () {
	    echo "Usage: \$ME [ --help ] [ -trace[=<args>] ] [ -v ] [ -x ]"
	    echo "      [ -- ] [ <eclipse-install-dir> ]"
	}

	help() {
	    usage;
	    echo "\$ME: To specify Eclipse's installation directory, do one"
	    echo "\$ME:  of the following (in order of decreasing precedence):" 
	    echo "  1: invoke this program as \$ME [<flags>] <eclipse-install-dir>"
	    echo "  2: set ECLIPSE_INSTALL_DIR in \${RVM_TARGET_CONFIG}, or"
	    echo "  3: set the environment variable ECLIPSE_INSTALL_DIR"
	}

	QUIET_ANT=-quiet
	unset XFLAG VFLAG || :

	while (( \$# > 0 )); do
	    arg="\$1"
	    if [[ \$arg = -- ]]; then
	        shift		# The end of the flag arguments
	        break;
	    fi
	    [[ \$arg != --?* ]] || arg="\${arg#-}"
	    if [[ \$arg = -v ]]; then
	        VFLAG=-v
	        shift
	    elif [[ \$arg = -x ]]; then
	        XFLAG=-x
		shift
	    elif [[ \$arg == -trace* ]]; then
		TRACE_FLAG="\$arg"
	        ! tracing ant || QUIET_ANT=
	        shift
	    elif [[ \$arg = -help ]] || [[ \$arg = -help ]]; then
	        shift
	        help
	        exit 0
	    elif [[ \$arg == -* ]]; then
	        echo >&2 "\$ME: Unknown flag: \$arg"
	        usage >&2
	        exit $Exit_Status_Bad_Args
	    fi
	done

	# allow user-specified Eclipse install to override env
	if [[ \$1 ]]; then
	    ECLIPSE_INSTALL_DIR=\$1
	    shift
	fi

	if (( \$# != 0 )); then
	    echo >&2 "$ME: Too many arguments."
	    usage >&2
	    exit $Exit_Status_Bad_Args;
	fi
	# must have Eclipse for command line or env
	if [[ ! \${ECLIPSE_INSTALL_DIR} ]]; then
	    echo "\$ME: You must (but didn't) specify the directory where Eclipse is installed."
	    help;
	    trap "" EXIT
	    exit 2
	fi >&2

	# must have Ant
	if [[ ! \${ANT_CMD} ]]; then
	    echo "must specify ANT_CMD in \${RVM_TARGET_CONFIG}"
	    trap "" EXIT
	    exit 2
	fi

	# build the plugin
#    	[[ \$VFLAG ]] || VFLAG=+v
#    	[[ \$XFLAG ]] || XFLAG=+x
	[ ! "\$VFLAG\$XFLAG" ] || set \$VFLAG \$XFLAG
	srcdir=\${JAL_ROOT}/rvm/src/tools/eclipse/plugin2
	! tracing ||  echo "Building in \${srcdir}"
	cd \${srcdir}
	# Get the name of the package we're building.  It changes with each
	# new version of Jikes RVM.  Only used for showing progress.
	declare -r pkgname=\$(sed -n -e 's/.*name="package".*value="\\([^"][^"]*[Jj]ikes[Rr][Vv][Mm][^"]*\\)".*/\\1/p' build.xml)
	echo "Building and installing the Eclipse plugin \$pkgname"
	( ! tracing jbuild && ! tracing ant ) || echo "Setting up ant.properties"

	echo "eclipse.dir=\${ECLIPSE_INSTALL_DIR}" > ant.properties

	if tracing ant; then
	    echo "build.trace=true"
	else
	    echo "build.trace=false"
	fi >> ant.properties
	export JAVA_HOME=\${HOST_JAVA_HOME}

	\${ANT_CMD} \$QUIET_ANT install

	EOF
}

#------------------------------------------------#
# SECTION 6 - Mainline Code that does the work.  #
#------------------------------------------------#
    
echo "${ME}: setting up ${BUILD_DIRECTORY} for ${CONFIGURATION_NAME}"

# Ensure configuration options are sensible.
checkConfigurationOptions

# Make a fresh start.
#
if (( cleanse )) && [[ -e ${BUILD_DIRECTORY} ]] # old directory exists; 
then 
    if [ -t 0 ]    # keyboard is live (ie. this is not an automated build)
    then
	## && [[ ! $EMACS ]] 
	## It would be nice to test whether we are running under EMACS's 
	## M-x compile mode.   But I do not know how to do that. 
 	got_EOF=""
	response="unset"
	status=0
	if ! read -n 1 -p "${ME}: ${BUILD_DIRECTORY} already exists, replace it? (y/n) --> " response; then
	    # Shell does not let us distinguish EOF from I/O errors.
	    got_EOF=1
	fi
	echo ""		# finish the line since our user did not type a newline' for us.
	if [[ $got_EOF ]]; then
	    echo >&2 "${ME}: Got EOF (End of File).  We won't write anything."
	    response=EOF
	fi
	if [[ $response != y* ]]; then
	    echo >&2 "${ME}: Operation aborted; nothing written."
	    trap '' EXIT
	    exit $Exit_Status_Bad_Args
	fi
    fi
    ( cd ${BUILD_DIRECTORY} && rm -rf * )
fi
if ! (( cleanse )) && ! (( quiet )); then
    echo " (writing new files, but not deleting old stuff)"
fi

# Create output directory structure.
#
mkdir -p ${BUILD_DIRECTORY}
mkdir -p ${GENERATED_FILES_DIRECTORY}
mkdir -p ${GENERATED_FILES_DIRECTORY}/instructionFormats
mkdir -p ${SCRATCH_DIRECTORY}
mkdir -p ${CLASSES_DIRECTORY}

(( quiet )) || echo -n "(directories created) "

# Create control files and scripts.
#
PERM=+r+w

function make_config_summary () {
    local s="$1"
    rm -f $s
    echo "configuration name: ${CONFIGURATION_NAME}" > $s
    echo "preprocessor definitions:"                 >>${s}
    echo "${PREPROCESSOR_DEFINITIONS}"   >> ${s}
    chmod ${PERM} ${s}
}

make_config_summary ${CONFIGURATION_SUMMARY}

(( cleanse )) && touch                          ${CLEANSE_STATUS}

rm -f				$SOURCE_LIST
emitSourceList                >${SOURCE_LIST}
chmod ${PERM}                    ${SOURCE_LIST}

rm -f				${BUILD_DIRECTORY}/jbuild
emitController                >${BUILD_DIRECTORY}/jbuild
chmod +x${PERM}                  ${BUILD_DIRECTORY}/jbuild

rm -f				${BUILD_DIRECTORY}/jbuild.expand
emitExpander                  >${BUILD_DIRECTORY}/jbuild.expand
chmod +x${PERM}                  ${BUILD_DIRECTORY}/jbuild.expand

rm -f				${BUILD_DIRECTORY}/jbuild.copy
emitCopier                    >${BUILD_DIRECTORY}/jbuild.copy
chmod +x${PERM}                  ${BUILD_DIRECTORY}/jbuild.copy

rm -f				${BUILD_DIRECTORY}/jbuild.compile
emitCompiler                  >${BUILD_DIRECTORY}/jbuild.compile
chmod +x${PERM}                  ${BUILD_DIRECTORY}/jbuild.compile

rm -f				${BUILD_DIRECTORY}/jbuild.linkImage
emitImageLinker               >${BUILD_DIRECTORY}/jbuild.linkImage
chmod +x${PERM}                  ${BUILD_DIRECTORY}/jbuild.linkImage

rm -f				 ${BUILD_DIRECTORY}/jbuild.linkBooter
emitBooterLinker              >${BUILD_DIRECTORY}/jbuild.linkBooter
chmod +x${PERM}                  ${BUILD_DIRECTORY}/jbuild.linkBooter

rm -f				${BUILD_DIRECTORY}/jbuild.tool
emitToolCompiler              >${BUILD_DIRECTORY}/jbuild.tool
chmod +x${PERM}                  ${BUILD_DIRECTORY}/jbuild.tool

rm -f				${BUILD_DIRECTORY}/jbuild.toolPrep
emitToolPreprocessor          >$BUILD_DIRECTORY/jbuild.toolPrep
chmod +x$PERM                  $BUILD_DIRECTORY/jbuild.toolPrep

rm -f			       ${BUILD_DIRECTORY}/jbuild.plugin
emitPluginBuilder             >$BUILD_DIRECTORY/jbuild.plugin
chmod +x$PERM                  $BUILD_DIRECTORY/jbuild.plugin

# write the environment specific configuration files
#

# read the host environment file
. ${RVM_HOST_CONFIG}
export CURRENT_CONFIG_FILE=${RVM_HOST_CONFIG}
rm -f			      ${BUILD_DIRECTORY}/Make.rules.host
emitMakefile	      	      >${BUILD_DIRECTORY}/Make.rules.host
chmod -x${PERM}		      ${BUILD_DIRECTORY}/Make.rules.host

rm -f			      ${BUILD_DIRECTORY}/environment.host
emitEnvironmentBash	      >${BUILD_DIRECTORY}/environment.host
chmod -x${PERM}		      ${BUILD_DIRECTORY}/environment.host

# read the target environment file
. ${RVM_TARGET_CONFIG}
export CURRENT_CONFIG_FILE=${RVM_TARGET_CONFIG}

rm -f			      ${BUILD_DIRECTORY}/Make.rules.target
emitMakefile		      >${BUILD_DIRECTORY}/Make.rules.target
chmod -x${PERM}		      ${BUILD_DIRECTORY}/Make.rules.target

rm -f			      ${BUILD_DIRECTORY}/environment.target
emitEnvironmentBash	      >${BUILD_DIRECTORY}/environment.target
chmod -x${PERM}		      ${BUILD_DIRECTORY}/environment.target

# write the GNU Classpath security properties file
#
f=${BUILD_DIRECTORY}/security/JikesRVM.security
rm -f $f
mkdir -p $(dirname $f)
echo "security.provider.1=gnu.java.security.provider.Gnu" > $f
chmod -x${PERM} $f

(( quiet )) || echo -n "(control files and scripts installed) "

if (( ! quiet )); then
    if [ -t 0 ]; then # keyboard is live (ie. this is not an automated build)
	echo ""
	echo "${ME}: ${CONFIGURATION_NAME} configuration is ready"
	echo "${ME}: To build it, type:"
	echo "${ME}:    cd ${BUILD_DIRECTORY}"
	echo "${ME}:    ./jbuild"
    else
	echo "done."
    fi
fi
trap '' EXIT
