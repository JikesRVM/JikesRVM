#
#  This file is part of the Jikes RVM project (http://jikesrvm.org).
#
#  This file is licensed to You under the Eclipse Public License (EPL);
#  You may not use this file except in compliance with the License. You
#  may obtain a copy of the License at
#
#      http://www.opensource.org/licenses/eclipse-1.0.php
#
#  See the COPYRIGHT.txt file distributed with this work for information
#  regarding copyright ownership.
#
# BURS rules that are common to PPC32 and PPC64
# !!!warning: pay attention to rules that set condition bits !!!
# Mostly these are mode dependant and do NOT have the same behavior on 32-bit and 64-bit.
# E.g. ADDr, ADDIC, ANDr are not OK to use here. SLWr and ANDIr on the other hand can be used.
#
# The format of PRODUCTION is 'non-terminal:	rule'
PRODUCTION
# COST is a Java expression that evaluates to an integer.
# The following conventions are more or less followed:
# TODO: define conventions for PPC rules!
COST
# For definition of FLAGS bits see BURS_TreeNode.java
FLAGS
# Code
TEMPLATE

##################################
# Definitions of non-terminals and
# mapping of leaves into non-terminals
##################################
# the non-terminal r can be mapped to non-terminal stm at no cost
stm:	r
0
NOFLAGS
// No code emitted

# the terminal REGISTER maps to non-terminal r
r:	REGISTER
0
NOFLAGS
// No code emitted

# the nonterminal czr can map to non-terminal r
# czr indicates that (1) a register result is produced
# and (2) as a side-effect of producing that result the condition registers
# are set as if the result was compared to 0.
r:	czr
0
NOFLAGS
// No code emitted

# the nonterminal rz can map to non-terminal r
# rz indicates that a register result is zero extended
r:	rs
0
NOFLAGS
// No code emitted

# the nonterminal rz can map to non-terminal r
# rz indicates that a register result is zero extended
r:	rz
0
NOFLAGS
// No code emitted

# the nonterminal rp can map to non-terminal rs
# rp indicates that a register result is always a positive 32-bit value
rs:	rp
0
NOFLAGS
// No code emitted

# the nonterminal rp can map to non-terminal rz
# rp indicates that a register result is always a positive 32-bit value
rz:	rp
0
NOFLAGS
// No code emitted

# A non-terminal that can be anything
any:	NULL
0
NOFLAGS
// No code emitted

any:	r
0
NOFLAGS
// No code emitted

any:	ADDRESS_CONSTANT
0
NOFLAGS
// No code emitted

any:	INT_CONSTANT
0
NOFLAGS
// No code emitted

any:	LONG_CONSTANT
0
NOFLAGS
// No code emitted

any:	OTHER_OPERAND(any, any)
0
NOFLAGS
// No code emitted

##################################
# A few operators are passed through unchanged
##################################
stm:	RESOLVE
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	IG_PATCH_POINT
10
EMIT_INSTRUCTION
EMIT(InlineGuard.mutate(P(p), IG_PATCH_POINT, null, null, null, InlineGuard.getTarget(P(p)), InlineGuard.getBranchProfile(P(p))));

stm:	UNINT_BEGIN
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	UNINT_END
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	YIELDPOINT_PROLOGUE
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	YIELDPOINT_EPILOGUE
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	YIELDPOINT_BACKEDGE
10
EMIT_INSTRUCTION
EMIT(P(p));

##################################
# One operator is passed through nearly unchanged
##################################
stm:	LOWTABLESWITCH(r)
10
EMIT_INSTRUCTION
LOWTABLESWITCH(P(p));

##################################
# NOPs can simply be dropped
##################################
stm:	NOP
10
NOFLAGS
// drop on floor

#####
# GUARD_MOVE
#####
# note: ignoring guard registers, thus no uses
r:	GUARD_MOVE
11
EMIT_INSTRUCTION
EMIT(P(p));

#####
# GUARD_COMBINE
#####
# note: ignoring guard registers, thus no uses
r:	GUARD_COMBINE
11
EMIT_INSTRUCTION
EMIT(P(p));

#####
# NULL_CHECK
#####
stm:	NULL_CHECK(r)
11
EMIT_INSTRUCTION
EMIT(P(p));

###########
# Rules for exceptions
###########
r:	GET_CAUGHT_EXCEPTION
11
EMIT_INSTRUCTION
GET_EXCEPTION_OBJECT(P(p));

stm:	SET_CAUGHT_EXCEPTION(r)
11
EMIT_INSTRUCTION
SET_EXCEPTION_OBJECT(P(p));

##################################
# Cache instructions
##################################
#####
# FENCE
#####
stm:	FENCE
11
EMIT_INSTRUCTION
EMIT(MIR_Empty.mutate(P(p), PPC_SYNC));

#####
# WRITE_FLOOR
#####
stm:	WRITE_FLOOR
11
EMIT_INSTRUCTION
EMIT(MIR_Empty.mutate(P(p), PPC_SYNC));

#####
# READ_CEILING
#####
stm:	READ_CEILING
11
EMIT_INSTRUCTION
EMIT(MIR_Empty.mutate(P(p), PPC_ISYNC));

#####
# DCBF
#####
stm:	DCBF(r)
11
EMIT_INSTRUCTION
EMIT(MIR_CacheOp.mutate(P(p), PPC_DCBF, I(0), R(CacheOp.getRef(P(p)))));

#####
# DCBST
#####
stm:	DCBST(r)
11
EMIT_INSTRUCTION
EMIT(MIR_CacheOp.mutate(P(p), PPC_DCBST, I(0), R(CacheOp.getRef(P(p)))));

#####
# DCBT
#####
stm:	DCBT(r)
11
EMIT_INSTRUCTION
EMIT(MIR_CacheOp.mutate(P(p), PPC_DCBT, I(0), R(CacheOp.getRef(P(p)))));

#####
# DCBTST
#####
stm:	DCBTST(r)
11
EMIT_INSTRUCTION
EMIT(MIR_CacheOp.mutate(P(p), PPC_DCBTST, I(0), R(CacheOp.getRef(P(p)))));

#####
# DCBZ
#####
stm:	DCBZ(r)
11
EMIT_INSTRUCTION
EMIT(MIR_CacheOp.mutate(P(p), PPC_DCBZ, I(0), R(CacheOp.getRef(P(p)))));

#####
# DCBZL
#####
stm:	DCBZL(r)
11
EMIT_INSTRUCTION
EMIT(MIR_CacheOp.mutate(P(p), PPC_DCBZL, I(0), R(CacheOp.getRef(P(p)))));

#####
# ICBI
#####
stm:	ICBI(r)
11
EMIT_INSTRUCTION
EMIT(MIR_CacheOp.mutate(P(p), PPC_ICBI, I(0), R(CacheOp.getRef(P(p)))));

##################################
# Trap operations
##################################
#####
# TRAP
#####
stm:	TRAP
10
EMIT_INSTRUCTION
TRAP(P(p));

#####
# TRAP_IF
#####
stm:	TRAP_IF(r,r)
10
EMIT_INSTRUCTION
TRAP_IF(P(p));

stm:	TRAP_IF(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
TRAP_IF_IMM(P(p), false);

stm:	TRAP_IF(r,LONG_CONSTANT)
10
EMIT_INSTRUCTION
TRAP_IF_IMM(P(p), true);

##################################
# Basic Boolean ALU operations
##################################
#####
# BOOLEAN_NOT
#####
r:	BOOLEAN_NOT(r)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_XORI, Unary.getResult(P(p)), R(Unary.getVal(P(p))), IC(1)));

#####
# BOOLEAN_CMP_INT
#####
r:	BOOLEAN_CMP_INT(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
BOOLEAN_CMP_INT_IMM(BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)), R(BooleanCmp.getVal1(P(p))), IC(BooleanCmp.getVal2(P(p))));

r:	BOOLEAN_CMP_INT(r,r)
10
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)), R(BooleanCmp.getVal1(P(p))), R(BooleanCmp.getVal2(P(p))));

boolcmp:	BOOLEAN_CMP_INT(r,INT_CONSTANT)
0
EMIT_INSTRUCTION
PUSH_BOOLCMP(BooleanCmp.getCond(P(p)), BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p)), false);

boolcmp:	BOOLEAN_CMP_INT(r,r)
0
EMIT_INSTRUCTION
PUSH_BOOLCMP(BooleanCmp.getCond(P(p)), BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p)), false);

#####
# BOOLEAN_CMP_ADDR
#####
r:	BOOLEAN_CMP_ADDR(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
BOOLEAN_CMP_ADDR_IMM(BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)), R(BooleanCmp.getVal1(P(p))), IC(BooleanCmp.getVal2(P(p))));

r:	BOOLEAN_CMP_ADDR(r,r)
10
EMIT_INSTRUCTION
BOOLEAN_CMP_ADDR(BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)), R(BooleanCmp.getVal1(P(p))), R(BooleanCmp.getVal2(P(p))));

boolcmp:	BOOLEAN_CMP_ADDR(r,INT_CONSTANT)
0
EMIT_INSTRUCTION
PUSH_BOOLCMP(BooleanCmp.getCond(P(p)), BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p)), true);

boolcmp:	BOOLEAN_CMP_ADDR(r,r)
0
EMIT_INSTRUCTION
PUSH_BOOLCMP(BooleanCmp.getCond(P(p)), BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p)), true);

## chaining of boolcmps
boolcmp:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
VR(p) == 1 && BooleanCmp.getCond(P(p)).isEQUAL()?0:INFINITE
NOFLAGS
// use already pushed boolean cmp

boolcmp:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
VR(p) == 1 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()?0:INFINITE
EMIT_INSTRUCTION
FLIP_BOOLCMP(); // invert condition

boolcmp:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
VR(p) == 0 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()?0:INFINITE
NOFLAGS
// use already pushed boolean cmp

boolcmp: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
VR(p) == 0 && BooleanCmp.getCond(P(p)).isEQUAL()?0:INFINITE
EMIT_INSTRUCTION
FLIP_BOOLCMP(); // invert condition

## materialize boolcmp into a register
r:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
VR(p) == 1 && BooleanCmp.getCond(P(p)).isEQUAL()?10:INFINITE
EMIT_INSTRUCTION
EMIT_PUSHED_BOOLCMP(BooleanCmp.getResult(P(p)));

r:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
VR(p) == 1 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()?10:INFINITE
EMIT_INSTRUCTION
FLIP_BOOLCMP(); EMIT_PUSHED_BOOLCMP(BooleanCmp.getResult(P(p)));

r:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
VR(p) == 0 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()?10:INFINITE
EMIT_INSTRUCTION
EMIT_PUSHED_BOOLCMP(BooleanCmp.getResult(P(p)));

r: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
VR(p) == 0 && BooleanCmp.getCond(P(p)).isEQUAL()?10:INFINITE
EMIT_INSTRUCTION
FLIP_BOOLCMP(); EMIT_PUSHED_BOOLCMP(BooleanCmp.getResult(P(p)));

##################################
# Basic Integer ALU operations
##################################
#####
# REF_ADD
#####
r:	REF_ADD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ADDI, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	REF_ADD(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ADD, Binary.getResult(P(p)),                 \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	REF_ADD(r,REF_MOVE(INT_CONSTANT))
20
EMIT_INSTRUCTION
{                                                                             \
   int val = IV(Move.getVal(PR(p)));                                      \
   EMIT(MIR_Binary.create(PPC_ADDI, Move.getResult(PR(p)),                    \
                          R(Binary.getVal1(P(p))), CAL16(val)));              \
   EMIT(MIR_Binary.mutate(P(p), PPC_ADDIS, Binary.getResult(P(p)),            \
                          Move.getResult(PR(p)).copyRO(), CAU16(val)));       \
}

r:	REF_ADD(r,REF_MOVE(INT_CONSTANT))
U16(IV(Move.getVal(PR(p))))?10:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ADDIS, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), CAU16(IV(Move.getVal(PR(p))))));

#####
# REF_SUB
#####
r:	REF_SUB(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SUBF, Binary.getResult(P(p)),                \
                       R(Binary.getVal2(P(p))), Binary.getVal1(P(p))));

r:	REF_SUB(INT_CONSTANT,r)
SI16(IV(Binary.getVal1(P(p))))?11:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SUBFIC, Binary.getResult(P(p)),              \
                       R(Binary.getVal2(P(p))), Binary.getVal1(P(p))));

#####
# INT_MUL
#####
r:	INT_MUL(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_MULLI, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_MUL(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_MULLW, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# INT_DIV
#####
r:	INT_DIV(r,r)
20
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_DIVW, GuardedBinary.getResult(P(p)),  \
                       R(GuardedBinary.getVal1(P(p))), GuardedBinary.getVal2(P(p))));

r:	INT_DIV(r,REF_MOVE(INT_CONSTANT))
20
EMIT_INSTRUCTION
INT_DIV_IMM(P(p), GuardedBinary.getResult(P(p)), R(GuardedBinary.getVal1(P(p))), \
                  Move.getResult(PR(p)), IC(Move.getVal(PR(p))));

#####
# INT_REM
#####
r:	INT_REM(r,r)
20
EMIT_INSTRUCTION
INT_REM(P(p), GuardedBinary.getResult(P(p)), R(GuardedBinary.getVal1(P(p))), R(GuardedBinary.getVal2(P(p))));

r:	INT_REM(r,REF_MOVE(INT_CONSTANT))
20
EMIT_INSTRUCTION
INT_REM_IMM(P(p), GuardedBinary.getResult(P(p)), R(GuardedBinary.getVal1(P(p))), \
	          Move.getResult(PR(p)), IC(Move.getVal(PR(p))));

#####
# REF_NEG
#####
r:	REF_NEG(r)
11
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_NEG, Unary.getResult(P(p)), Unary.getVal(P(p))));

#####
# INT_SHL
#####
rz:	INT_SHL(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SLWI, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

rz:	INT_SHL(r,r)
20
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SLW, Binary.getResult(P(p)), \
                       R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p)))));

rz:	INT_SHL(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
10
EMIT_INSTRUCTION
USHR_SHL(P(p), Binary.getResult(P(p)), R(Binary.getVal1(PL(p))), IC(Binary.getVal2(PL(p))),      \
               IC(Binary.getVal2(P(p))));

#####
# INT_SHR
#####
rs:	INT_SHR(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SRAWI, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

rs:	INT_SHR(r,r)
20
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SRAW, Binary.getResult(P(p)), \
                       R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p)))));

#guaranteed to be correct also on 64-bit: INT_CONSTANT of REF_AND is immediate, so sign is always zero
rp:	INT_SHR(REF_AND(r,INT_CONSTANT),INT_CONSTANT)
POSITIVE_MASK(IV(Binary.getVal2(PL(p))))?10:INFINITE
EMIT_INSTRUCTION
AND_USHR(P(p), Binary.getResult(P(p)),                      \
                     R(Binary.getVal1(PL(p))), IC(Binary.getVal2(PL(p))),      \
                     IC(Binary.getVal2(P(p))));

#not always correct: can be signed: SHR --> USHR ???
#r:	INT_SHR(REF_AND(r,REF_MOVE(INT_CONSTANT)),INT_CONSTANT)
#POSITIVE_MASK(Move.getVal(PLR(p)))?10:INFINITE
#EMIT_INSTRUCTION
#AND_USHR(P(p), Binary.getResult(P(p)),                      \
#                     R(Binary.getVal1(PL(p))), IC(Move.getVal(PLR(p))),        \
#                     IC(Binary.getVal2(P(p))));
#
#####
# INT_USHR
#####
#assumption for rp : INT_CONSTANT of USHR <> 0, should be taken care of by Simplifier
rp:	INT_USHR(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SRWI, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

rz:	INT_USHR(r,r)
20
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SRW, Binary.getResult(P(p)), \
                       R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p)))));

#assumption for rp : INT_CONSTANT of USHR <> 0, should be taken care of by Simplifier
rp:	INT_USHR(REF_AND(r,INT_CONSTANT),INT_CONSTANT)
POSITIVE_MASK(IV(Binary.getVal2(PL(p))))?10:INFINITE
EMIT_INSTRUCTION
AND_USHR(P(p), Binary.getResult(P(p)), R(Binary.getVal1(PL(p))), \
	       IC(Binary.getVal2(PL(p))), IC(Binary.getVal2(P(p))));

#assumption for rp : INT_CONSTANT of USHR <> 0, should be taken care of by Simplifier
rp:	INT_USHR(REF_AND(r,REF_MOVE(INT_CONSTANT)),INT_CONSTANT)
POSITIVE_MASK(IV(Move.getVal(PLR(p))))?10:INFINITE
EMIT_INSTRUCTION
AND_USHR(P(p), Binary.getResult(P(p)), R(Binary.getVal1(PL(p))), \
               IC(Move.getVal(PLR(p))), IC(Binary.getVal2(P(p))));

#assumption for rp : INT_CONSTANT of USHR <> 0, should be taken care of by Simplifier
rp:	INT_USHR(INT_SHL(r,INT_CONSTANT),INT_CONSTANT)
10
EMIT_INSTRUCTION
SHL_USHR(P(p), Binary.getResult(P(p)), R(Binary.getVal1(PL(p))), \
	       IC(Binary.getVal2(PL(p))), IC(Binary.getVal2(P(p))));

#####
# REF_AND
#####
r:	REF_AND(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_AND, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

czr:	REF_AND(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ANDIr, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), IC(Binary.getVal2(P(p)))));

#assumption for rp : INT_CONSTANT is always a positive immediate, should be taken care of by NormalizeConstants
rp:	REF_AND(r,INT_CONSTANT)
MASK(IV(Binary.getVal2(P(p))))?10:INFINITE
EMIT_INSTRUCTION
{                                                                             \
   int mask = IV(Binary.getVal2(P(p)));                                   \
   EMIT(MIR_RotateAndMask.create(PPC_RLWINM, Binary.getResult(P(p)),          \
                                 R(Binary.getVal1(P(p))), IC(0),               \
                                 IC(MaskBegin(mask)), IC(MaskEnd(mask))));                        \
}

r:	REF_AND(REF_NOT(r),REF_NOT(r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_NOR, Binary.getResult(P(p)),                 \
                       R(Unary.getVal(PL(p))), Unary.getVal(PR(p))));

r:	REF_AND(r,REF_NOT(r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ANDC, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Unary.getVal(PR(p))));

rp:	REF_AND(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
POSITIVE_MASK(IV(Binary.getVal2(P(p))))?10:INFINITE
EMIT_INSTRUCTION
USHR_AND(P(p), Binary.getResult(P(p)), R(Binary.getVal1(PL(p))), \
               IC(Binary.getVal2(P(p))), IC(Binary.getVal2(PL(p))));

#assumption for rp : INT_CONSTANT of USHR <> 0, should be taken care of by Simplifier
rp:	REF_AND(INT_USHR(r,INT_CONSTANT),REF_MOVE(INT_CONSTANT))
POSITIVE_MASK(IV(Move.getVal(PR(p))))?10:INFINITE
EMIT_INSTRUCTION
USHR_AND(P(p), Binary.getResult(P(p)), R(Binary.getVal1(PL(p))), \
               IC(Move.getVal(PR(p))), IC(Binary.getVal2(PL(p))));

#####
# REF_OR
#####
r:	REF_OR(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_OR, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	REF_OR(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ORI, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	REF_OR(REF_NOT(r),REF_NOT(r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_NAND, Binary.getResult(P(p)), R(Unary.getVal(PL(p))), Unary.getVal(PR(p))));

r:	REF_OR(r,REF_NOT(r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ORC, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Unary.getVal(PR(p))));

#####
# REF_XOR
#####
r:	REF_XOR(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_XOR, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	REF_XOR(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_XORI, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# REF_NOT
#####
r:	REF_NOT(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_NOR, Unary.getResult(P(p)), R(Unary.getVal(P(p))), Unary.getVal(P(p))));

r:	REF_NOT(REF_OR(r,r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_NOR, Unary.getResult(P(p)), R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p))));

r:	REF_NOT(REF_AND(r,r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_NAND, Unary.getResult(P(p)), R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p))));

r:	REF_NOT(REF_XOR(r,r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_EQV, Unary.getResult(P(p)), R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p))));

##################################
# Basic Floating-Point ALU operations
##################################
#####
# FLOAT_ADD
#####
r:	FLOAT_ADD(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FADDS, Binary.getResult(P(p)), \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# DOUBLE_ADD
#####
r:	DOUBLE_ADD(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FADD, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# FLOAT_MUL
#####
r:	FLOAT_MUL(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FMULS, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# DOUBLE_MUL
#####
r:	DOUBLE_MUL(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FMUL, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# FLOAT_SUB
#####
r:	FLOAT_SUB(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FSUBS, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# DOUBLE_SUB
#####
r:	DOUBLE_SUB(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FSUB, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# FLOAT_DIV
#####
r:	FLOAT_DIV(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FDIVS, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# DOUBLE_DIV
#####
r:	DOUBLE_DIV(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FDIV, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# FLOAT_NEG
#####
r:	FLOAT_NEG(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_FNEG, Unary.getResult(P(p)), Unary.getVal(P(p))));

#####
# DOUBLE_NEG
#####
r:	DOUBLE_NEG(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_FNEG, Unary.getResult(P(p)), Unary.getVal(P(p))));

#####
# FLOAT_SQRT
#####
r:	FLOAT_SQRT(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_FSQRTS, Unary.getResult(P(p)), Unary.getVal(P(p))));

#####
# DOUBLE_SQRT
#####
r:	DOUBLE_SQRT(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_FSQRT, Unary.getResult(P(p)), Unary.getVal(P(p))));

#####
# FMA and friends
#####
r: 	FLOAT_ADD(FLOAT_MUL(r, r), r)
burs.ir.strictFP(P(p),PL(p))?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMADDS, Binary.getResult(P(p)),             \
		        R(Binary.getVal1(PL(p))), R(Binary.getVal2(PL(p))),   \
		        R(Binary.getVal2(P(p)))));

r: 	DOUBLE_ADD(DOUBLE_MUL(r, r), r)
burs.ir.strictFP(P(p),PL(p))?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMADD, Binary.getResult(P(p)),              \
		        R(Binary.getVal1(PL(p))), R(Binary.getVal2(PL(p))),   \
		        R(Binary.getVal2(P(p)))));

r:	FLOAT_ADD(r, FLOAT_MUL(r,r))
burs.ir.strictFP(P(p),PR(p))?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMADDS, Binary.getResult(P(p)),             \
			R(Binary.getVal1(PR(p))), R(Binary.getVal2(PR(p))),   \
			R(Binary.getVal1(P(p)))));

r:	DOUBLE_ADD(r, DOUBLE_MUL(r,r))
burs.ir.strictFP(P(p),PR(p))?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMADD, Binary.getResult(P(p)),              \
			R(Binary.getVal1(PR(p))), R(Binary.getVal2(PR(p))),   \
			R(Binary.getVal1(P(p)))));

r: 	FLOAT_SUB(FLOAT_MUL(r, r), r)
burs.ir.strictFP(P(p),PL(p))?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMSUBS, Binary.getResult(P(p)),             \
		        R(Binary.getVal1(PL(p))), R(Binary.getVal2(PL(p))),   \
		        R(Binary.getVal2(P(p)))));

r: 	DOUBLE_SUB(DOUBLE_MUL(r, r), r)
burs.ir.strictFP(P(p),PL(p))?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMSUB, Binary.getResult(P(p)),              \
		        R(Binary.getVal1(PL(p))), R(Binary.getVal2(PL(p))),   \
		        R(Binary.getVal2(P(p)))));

r: 	FLOAT_NEG(FLOAT_ADD(FLOAT_MUL(r, r), r))
burs.ir.strictFP(P(p),PL(p),PLL(p))?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMADDS, Unary.getResult(P(p)),             \
		        R(Binary.getVal1(PLL(p))), R(Binary.getVal2(PLL(p))), \
		        R(Binary.getVal2(PL(p)))));

r: 	DOUBLE_NEG(DOUBLE_ADD(DOUBLE_MUL(r, r), r))
burs.ir.strictFP(P(p),PL(p),PLL(p))?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMADD, Unary.getResult(P(p)),              \
		        R(Binary.getVal1(PLL(p))), R(Binary.getVal2(PLL(p))), \
		        R(Binary.getVal2(PL(p)))));

r:	FLOAT_NEG(FLOAT_ADD(r, FLOAT_MUL(r,r)))
burs.ir.strictFP(P(p),PL(p),PLR(p))?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMADDS, Unary.getResult(P(p)),             \
			R(Binary.getVal1(PLR(p))), R(Binary.getVal2(PLR(p))), \
			R(Binary.getVal1(PL(p)))));

r:	DOUBLE_NEG(DOUBLE_ADD(r, DOUBLE_MUL(r,r)))
burs.ir.strictFP(P(p),PL(p),PLR(p))?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMADD, Unary.getResult(P(p)),             \
			R(Binary.getVal1(PLR(p))), R(Binary.getVal2(PLR(p))),\
			R(Binary.getVal1(PL(p)))));

r: 	FLOAT_NEG(FLOAT_SUB(FLOAT_MUL(r, r), r))
burs.ir.strictFP(P(p),PL(p),PLL(p))?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMSUBS, Unary.getResult(P(p)),             \
		        R(Binary.getVal1(PLL(p))), R(Binary.getVal2(PLL(p))), \
		        R(Binary.getVal2(PL(p)))));

r: 	DOUBLE_NEG(DOUBLE_SUB(DOUBLE_MUL(r, r), r))
burs.ir.strictFP(P(p),PL(p),PLL(p))?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMSUB, Unary.getResult(P(p)),              \
		        R(Binary.getVal1(PLL(p))), R(Binary.getVal2(PLL(p))), \
		        R(Binary.getVal2(PL(p)))));

##################################
# Basic Conversion operations
##################################
#####
# INT_2BYTE
#####
rs:	INT_2BYTE(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_EXTSB, Unary.getResult(P(p)), Unary.getVal(P(p))));

#####
# INT_2USHORT
#####
rp:	INT_2USHORT(r)
20
EMIT_INSTRUCTION
EMIT(MIR_RotateAndMask.create(PPC_RLWINM, Unary.getResult(P(p)), null,        \
                              R(Unary.getVal(P(p))), IC(0), IC(16), IC(31)));

#####
# INT_2SHORT
#####
rs:	INT_2SHORT(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_EXTSH, Unary.getResult(P(p)), Unary.getVal(P(p))));

#####
# INT_2FLOAT
#####
r:	INT_2FLOAT(r)
10
EMIT_INSTRUCTION
INT_2DOUBLE(P(p), Unary.getResult(P(p)), R(Unary.getVal(P(p))));

#####
# INT_2DOUBLE
#####
r:	INT_2DOUBLE(r)
10
EMIT_INSTRUCTION
INT_2DOUBLE(P(p), Unary.getResult(P(p)), R(Unary.getVal(P(p))));

#####
# FLOAT_2INT
#####
r:	FLOAT_2INT(r)
10
EMIT_INSTRUCTION
EMIT(P(p));  // Leave for ComplexLIR2MIRExpansion

#####
# FLOAT_2DOUBLE
#####
r:	FLOAT_2DOUBLE(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), PPC_FMR, Unary.getResult(P(p)), R(Unary.getVal(P(p)))));

#####
# DOUBLE_2INT
#####
r:	DOUBLE_2INT(r)
10
EMIT_INSTRUCTION
EMIT(P(p));  // Leave for ComplexLIR2MIRExpansionLeave

#####
# DOUBLE_2FLOAT
#####
r:	DOUBLE_2FLOAT(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_FRSP, Unary.getResult(P(p)), Unary.getVal(P(p))));

#####
# FLOAT_AS_INT_BITS
#####
r:	FLOAT_AS_INT_BITS(r)
20
EMIT_INSTRUCTION
FPR2GPR_32(P(p));

#####
# INT_BITS_AS_FLOAT
#####
r:	INT_BITS_AS_FLOAT(r)
20
EMIT_INSTRUCTION
GPR2FPR_32(P(p));

##################################
# Moves (register to register moves)
##################################
######
# REF_MOVE
######
r:	REF_MOVE(r)
11
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), PPC_MOVE, Move.getResult(P(p)), R(Move.getVal(P(p)))));

rs:	REF_MOVE(INT_CONSTANT)
SI16(IV(Move.getVal(P(p))))?11:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_LDI, Move.getResult(P(p)), Move.getVal(P(p))));

rs:	REF_MOVE(INT_CONSTANT)
U16(IV(Move.getVal(P(p))))?11:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_LDIS, Move.getResult(P(p)), SRI(IV(Move.getVal(P(p))), 16)));

rs:	REF_MOVE(INT_CONSTANT)
22
EMIT_INSTRUCTION
{                                                                             \
   int one = IV(Move.getVal(P(p)));                                       \
   EMIT(MIR_Unary.create(PPC_LDIS, Move.getResult(P(p)), CAU16(one)));        \
   EMIT(MIR_Binary.mutate(P(p), PPC_ADDI, Move.getResult(P(p)).copyRO(),      \
                          Move.getResult(P(p)).copyRO(), CAL16(one)));        \
}

######
# FLOAT_MOVE
######
r:	FLOAT_MOVE(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), PPC_FMR, Move.getResult(P(p)), R(Move.getVal(P(p)))));

######
# DOUBLE_MOVE
######
r:	DOUBLE_MOVE(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), PPC_FMR, Move.getResult(P(p)), R(Move.getVal(P(p)))));

##################################
# Loads (memory to register moves)
##################################
#####
# BYTE_LOAD
#####
rs:	BYTE_LOAD(r,INT_CONSTANT)
22
EMIT_INSTRUCTION
BYTE_LOAD(P(p), PPC_LBZ, Load.getResult(P(p)), R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
          Load.getLocation(P(p)), Load.getGuard(P(p)));

rs:	BYTE_LOAD(r,r)
22
EMIT_INSTRUCTION
BYTE_LOAD(P(p), PPC_LBZX, Load.getResult(P(p)), R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
          Load.getLocation(P(p)), Load.getGuard(P(p)));

rp:	REF_AND(BYTE_LOAD(r,r),INT_CONSTANT)
VR(p) == 0xff ? 10 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(PL(p), PPC_LBZX, Binary.getResult(P(p)), R(Load.getAddress(PL(p))), \
                     Load.getOffset(PL(p)), Load.getLocation(PL(p)), \
                     Load.getGuard(PL(p))));

rp:	REF_AND(BYTE_LOAD(r,INT_CONSTANT),INT_CONSTANT)
VR(p) == 0xff ? 10 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(PL(p), PPC_LBZ, Binary.getResult(P(p)), R(Load.getAddress(PL(p))), \
                     Load.getOffset(PL(p)), Load.getLocation(PL(p)), \
                     Load.getGuard(PL(p))));

#####
# UBYTE_LOAD
#####
rp:	UBYTE_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LBZ, Load.getResult(P(p)),            \
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
                     Load.getLocation(P(p)), Load.getGuard(P(p))));

rp:	UBYTE_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LBZX, Load.getResult(P(p)),           \
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
	             Load.getLocation(P(p)), Load.getGuard(P(p))));

#####
# SHORT_LOAD
#####
rs:	SHORT_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LHA, Load.getResult(P(p)),            \
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
   	             Load.getLocation(P(p)), Load.getGuard(P(p))));

rs:	SHORT_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LHAX, Load.getResult(P(p)),           \
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
  	             Load.getLocation(P(p)), Load.getGuard(P(p))));

#####
# USHORT_LOAD
#####
rp:	USHORT_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LHZ, Load.getResult(P(p)),            \
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
	             Load.getLocation(P(p)), Load.getGuard(P(p))));

rp:	USHORT_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LHZX, Load.getResult(P(p)),           \
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
		     Load.getLocation(P(p)), Load.getGuard(P(p))));

#####
# FLOAT_LOAD
#####
r:	FLOAT_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LFS, Load.getResult(P(p)),            \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p))));

r:      FLOAT_LOAD(r,REF_MOVE(ADDRESS_CONSTANT))
FITS(Move.getVal(PR(p)),32,22)
EMIT_INSTRUCTION
{                                                                             \
   Address val = AV(Move.getVal(PR(p)));                                      \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PR(p)),                   \
                          R(Load.getAddress(P(p))), CAU16(val)));             \
   EMIT(MIR_Load.mutate(P(p), PPC_LFS, Load.getResult(P(p)),         \
                                 Move.getResult(PR(p)).copyRO(), CAL16(val),  \
			         Load.getLocation(P(p)),                      \
                                 Load.getGuard(P(p))));                      \
}

r:	FLOAT_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LFSX, Load.getResult(P(p)),           \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p))));

#####
# DOUBLE_LOAD
#####
r:	DOUBLE_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LFD, Load.getResult(P(p)),            \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p))));

r:      DOUBLE_LOAD(r,REF_MOVE(ADDRESS_CONSTANT))
FITS(Move.getVal(PR(p)),32,22)
EMIT_INSTRUCTION
{                                                                             \
   Address val = AV(Move.getVal(PR(p)));                                      \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PR(p)),                   \
                          R(Load.getAddress(P(p))), CAU16(val)));             \
   EMIT(MIR_Load.mutate(P(p), PPC_LFD, Load.getResult(P(p)),         \
                                 Move.getResult(PR(p)).copyRO(), CAL16(val),  \
				 Load.getLocation(P(p)),                      \
                                 Load.getGuard(P(p))));                      \
}

r:	DOUBLE_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LFDX, Load.getResult(P(p)),           \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p))));

#####
# INT_LOAD
# A few more cases than for other load operators to handle pointer arithmetic introduced by use of magic
#####
rs:      INT_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LInt, Load.getResult(P(p)),            \
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
                     Load.getLocation(P(p)), Load.getGuard(P(p))));

rs:      INT_LOAD(r,REF_MOVE(ADDRESS_CONSTANT))
FITS(Move.getVal(PR(p)),32,22)
EMIT_INSTRUCTION
{                                                                             \
   Address val = AV(Move.getVal(PR(p)));                                      \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PR(p)),                   \
                          R(Load.getAddress(P(p))), CAU16(val)));             \
   EMIT(MIR_Load.mutate(P(p), PPC_LInt, Load.getResult(P(p)),         \
                                 Move.getResult(PR(p)).copyRO(), CAL16(val),           \
                                 Load.getLocation(P(p)),                      \
                                 Load.getGuard(P(p))));                      \
}

rs:      INT_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LIntX, Load.getResult(P(p)),           \
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
                     Load.getLocation(P(p)), Load.getGuard(P(p))));

rs:      INT_LOAD(REF_ADD(r,r),INT_CONSTANT)
isZERO(VR(p), 11)
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LIntX, Load.getResult(P(p)),           \
                              R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), \
                              Load.getLocation(P(p)), Load.getGuard(P(p))));

rs:      INT_LOAD(REF_ADD(r,INT_CONSTANT),INT_CONSTANT)
SI16(VR(p)+VLR(p)) ? 14 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LInt, Load.getResult(P(p)),            \
                              R(Binary.getVal1(PL(p))), IC(VR(p)+VLR(p)), \
                              Load.getLocation(P(p)), Load.getGuard(P(p))));

#####
# BYTE_STORE
#####
stm:	BYTE_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STB, R(Store.getValue(P(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
                               Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	BYTE_STORE(r,OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STBX, R(Store.getValue(P(p))),       \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STB, R(Unary.getVal(PL(p))),         \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STBX, R(Unary.getVal(PL(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

#####
# SHORT_STORE
#####
stm:	SHORT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STH, R(Store.getValue(P(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	SHORT_STORE(r,OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STHX, R(Store.getValue(P(p))),       \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	SHORT_STORE(INT_2SHORT(r),OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STH, R(Unary.getVal(PL(p))),         \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	SHORT_STORE(INT_2SHORT(r),OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STHX, R(Unary.getVal(PL(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	SHORT_STORE(INT_2USHORT(r),OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STH, R(Unary.getVal(PL(p))),         \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	SHORT_STORE(INT_2USHORT(r),OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STHX, R(Unary.getVal(PL(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

#####
# INT_STORE
# A few more cases than for other store operators to handle pointer arithmetic introduced by use of magic
#####
stm:	INT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STW, R(Store.getValue(P(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	INT_STORE(r,OTHER_OPERAND(r,REF_MOVE(ADDRESS_CONSTANT)))
FITS(Move.getVal(PRR(p)),32,22)
EMIT_INSTRUCTION
{                                                                             \
   Address val = AV(Move.getVal(PRR(p)));                                     \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PRR(p)),                  \
                          R(Store.getAddress(P(p))), CAU16(val)));            \
   EMIT(MIR_Store.mutate(P(p), PPC_STW, R(Store.getValue(P(p))),     \
                                  Move.getResult(PRR(p)).copyRO(), CAL16(val),\
				  Store.getLocation(P(p)),                    \
                                  Store.getGuard(P(p))));                    \
}

stm:	INT_STORE(r,OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STWX, R(Store.getValue(P(p))),       \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	INT_STORE(r,OTHER_OPERAND(REF_ADD(r,INT_CONSTANT),INT_CONSTANT))
SI16(VRR(p)+VRLR(p))?14:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STW, R(Store.getValue(P(p))),        \
                               R(Binary.getVal1(PRL(p))),                     \
                               IC(VRR(p) + VRLR(p)), \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

#####
# FLOAT_STORE
#####
stm:	FLOAT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STFS, R(Store.getValue(P(p))),       \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:      FLOAT_STORE(r,OTHER_OPERAND(r,REF_MOVE(ADDRESS_CONSTANT)))
FITS(Move.getVal(PRR(p)),32,22)
EMIT_INSTRUCTION
{                                                                             \
   Address val = AV(Move.getVal(PRR(p)));                                     \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PRR(p)),                  \
                          R(Store.getAddress(P(p))), CAU16(val)));            \
   EMIT(MIR_Store.mutate(P(p), PPC_STFS, R(Store.getValue(P(p))),    \
                                  Move.getResult(PRR(p)).copyRO(), CAL16(val),\
				  Store.getLocation(P(p)),                    \
                                  Store.getGuard(P(p))));                    \
}

stm:	FLOAT_STORE(r,OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STFSX, R(Store.getValue(P(p))),      \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

#####
# DOUBLE_STORE
#####
stm:	DOUBLE_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STFD, R(Store.getValue(P(p))),       \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:      DOUBLE_STORE(r,OTHER_OPERAND(r,REF_MOVE(ADDRESS_CONSTANT)))
FITS(Move.getVal(PRR(p)),32,22)
EMIT_INSTRUCTION
{                                                                             \
   Address val = AV(Move.getVal(PRR(p)));                                     \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PRR(p)),                  \
                          R(Store.getAddress(P(p))), CAU16(val)));            \
   EMIT(MIR_Store.mutate(P(p), PPC_STFD, R(Store.getValue(P(p))),    \
                                  Move.getResult(PRR(p)).copyRO(), CAL16(val),\
				  Store.getLocation(P(p)),                    \
                                  Store.getGuard(P(p))));                    \
}

stm:	DOUBLE_STORE(r,OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STFDX, R(Store.getValue(P(p))),      \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

##################################
# Control flow
##################################
#####
# INT_IFCMP
#####
stm:	INT_IFCMP(r,r)
20
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
CMP(P(p), R(IfCmp.getVal1(P(p))), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)), false);

stm:	INT_IFCMP(r,INT_CONSTANT)
20
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
CMP(P(p), R(IfCmp.getVal1(P(p))), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)), true);

stm:	INT_IFCMP(INT_2BYTE(r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
CMP_ZERO(P(p), PPC_EXTSBr, Unary.getResult(PL(p)),         \
                     Unary.getVal(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_2SHORT(r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
CMP_ZERO(P(p), PPC_EXTSHr, Unary.getResult(PL(p)),         \
                     Unary.getVal(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_USHR(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
CMP_ZERO(P(p), PPC_SRWr, Binary.getResult(PL(p)),          \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_SHL(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
CMP_ZERO(P(p), PPC_SLWr, Binary.getResult(PL(p)),          \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_SHR(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
CMP_ZERO(P(p), PPC_SRAWr, Binary.getResult(PL(p)),         \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
CMP_ZERO(P(p), PPC_SRWIr, Binary.getResult(PL(p)),         \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_SHL(r,INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
CMP_ZERO(P(p), PPC_SLWIr, Binary.getResult(PL(p)),         \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_SHR(r,INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
CMP_ZERO(P(p), PPC_SRAWIr, Binary.getResult(PL(p)),        \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(REF_AND(r,INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
CMP_ZERO(P(p), PPC_ANDIr, Binary.getResult(PL(p)),         \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

# IfCmp(boolcmp, 0/1)
stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
VR(p) == 0 && IfCmp.getCond(P(p)).isNOT_EQUAL()?20:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
EMIT_BOOLCMP_BRANCH(IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
VR(p) == 0 && IfCmp.getCond(P(p)).isEQUAL()?20:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
FLIP_BOOLCMP(); EMIT_BOOLCMP_BRANCH(IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
VR(p) == 1 && IfCmp.getCond(P(p)).isEQUAL()?20:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
EMIT_BOOLCMP_BRANCH(IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
VR(p) == 1 && (IfCmp.getCond(P(p)).isNOT_EQUAL())?26:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
FLIP_BOOLCMP(); EMIT_BOOLCMP_BRANCH(IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

#####
# INT_IFCMP2: TODO interesting rules
#####
stm:	INT_IFCMP2(r,r)
20
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp2.getGuardResult(P(p)), new TrueGuardOperand()))); \
CMP2(P(p), R(IfCmp2.getVal1(P(p))), IfCmp2.getVal2(P(p)), IfCmp2.getCond1(P(p)), IfCmp2.getCond2(P(p)), false);

stm:	INT_IFCMP2(r,INT_CONSTANT)
20
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp2.getGuardResult(P(p)), new TrueGuardOperand()))); \
CMP2(P(p), R(IfCmp2.getVal1(P(p))), IfCmp2.getVal2(P(p)), IfCmp2.getCond1(P(p)), IfCmp2.getCond2(P(p)), true);

#####
# FLOAT_IFCMP
#####
stm:   FLOAT_IFCMP(r,r)
20
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
DOUBLE_IFCMP(P(p), R(IfCmp.getVal1(P(p))), IfCmp.getVal2(P(p)));

#####
# DOUBLE_IFCMP
#####
stm:   DOUBLE_IFCMP(r,r)
20
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \
DOUBLE_IFCMP(P(p), R(IfCmp.getVal1(P(p))), IfCmp.getVal2(P(p)));

#####
# FLOAT_CMPL
#####
stm:	FLOAT_CMPL(r,r)
40
EMIT_INSTRUCTION
EMIT (P(p)); //  Leave for ComplexLIR2MIRExpansion

#####
# FLOAT_CMPG
#####
stm:	FLOAT_CMPG(r,r)
40
EMIT_INSTRUCTION
EMIT (P(p)); //  Leave for ComplexLIR2MIRExpansion

#####
# DOUBLE_CMPL
#####
stm:	DOUBLE_CMPL(r,r)
40
EMIT_INSTRUCTION
EMIT (P(p)); //  Leave for ComplexLIR2MIRExpansion

#####
# DOUBLE_CMPG
#####
stm:	DOUBLE_CMPG(r,r)
40
EMIT_INSTRUCTION
EMIT (P(p)); //  Leave for ComplexLIR2MIRExpansion

#####
# GOTO
#####
stm:	GOTO
11
EMIT_INSTRUCTION
EMIT(MIR_Branch.mutate(P(p), PPC_B, Goto.getTarget(P(p))));

##################################
# Calling convention
##################################
#####
# RETURN
#####
stm:	RETURN(NULL)
10
EMIT_INSTRUCTION
RETURN(P(p), null);

stm:	RETURN(r)
10
EMIT_INSTRUCTION
RETURN(P(p), Return.getVal(P(p)));

#####
# CALL
#####
r:	CALL(r,any)
10
EMIT_INSTRUCTION
CALL(P(p));

# a recursive call that has been optimized to a branch to entry block
r:	CALL(BRANCH_TARGET,any)
10
EMIT_INSTRUCTION
CALL(P(p));

r:	SYSCALL(r,any)
10
EMIT_INSTRUCTION
SYSCALL(P(p));

###########
# Rules for special registers
###########
r:	GET_TIME_BASE
11
EMIT_INSTRUCTION
EMIT(P(p));  // Leave for ComplexLIR2MIRExpansion

##########
# DUMMY RULES WHILE SWITCHING OVER TO NEW STYLE
# TODO: DELTE THESE!
##########
r:	OTHER_OPERAND(r,r)
0
NOFLAGS
// do nothing

###############
# on stack replace
###############
r:  YIELDPOINT_OSR(any, any)
11
EMIT_INSTRUCTION
OSR(burs, P(p));

#####
# PREPARE
#####
r:      PREPARE_INT(r, r)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LWARX, Prepare.getResult(P(p)),   \
                              R(Prepare.getAddress(P(p))), Prepare.getOffset(P(p)),           \
                              Prepare.getLocation(P(p)),                  \
                              Prepare.getGuard(P(p))));

r:      PREPARE_LONG(r, r)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LAddrARX, Prepare.getResult(P(p)),   \
                              R(Prepare.getAddress(P(p))), Prepare.getOffset(P(p)),           \
                              Prepare.getLocation(P(p)),                  \
                              Prepare.getGuard(P(p))));

#####
# ATTEMPT (atomic compare-exchange)
#####
r:      ATTEMPT_INT(r, r)
11
EMIT_INSTRUCTION
EMIT(P(p));  // Leave for ComplexLIR2MIRExpansion

r:      ATTEMPT_LONG(r, r)
11
EMIT_INSTRUCTION
EMIT(P(p));  // Leave for ComplexLIR2MIRExpansion

