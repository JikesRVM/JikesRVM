#
#  This file is part of the Jikes RVM project (http://jikesrvm.org).
#
#  This file is licensed to You under the Eclipse Public License (EPL);
#  You may not use this file except in compliance with the License. You
#  may obtain a copy of the License at
#
#      http://www.opensource.org/licenses/eclipse-1.0.php
#
#  See the COPYRIGHT.txt file distributed with this work for information
#  regarding copyright ownership.
#
# BURS rules for IA32
#
# The format of PRODUCTION is 'non-terminal:	rule'
PRODUCTION
# COST is a Java expression that evaluates to an integer.
# The following conventions are more or less followed:
#   Each instruction generated has a base cost of 10
#   A basic (r,r) or (r,riv) costs 3 more
#   A (m,riv) costs 7
#   A (r,m) costs 5
#   Better basic opcodes decrease cost by 2
COST
# For definition of FLAGS bits see BURS_TreeNode.java
FLAGS
# Code
TEMPLATE

##################################
# Definitions of non-terminals and
# mapping of leaves into non-terminals
##################################
# the non-terminal r can be mapped to non-terminal stm at no cost
stm:	r
0
NOFLAGS
// No code emitted

# the terminal REGISTER maps to non-terminal r
r:	REGISTER
0
NOFLAGS
// No code emitted

# the nonterminal czr can map to non-terminal r
# czr indicates that (1) a register result is produced
# and (2) as a side-effect of producing that result the condition registers
# are set as if the result was compared to 0.
r:	czr
0
NOFLAGS
// No code emitted

# the nonterminal czr can map to non-terminal cz
# cz indicates that the condition registers like a compare instruction
cz:	czr
0
NOFLAGS
// No code emitted

# the nonterminal szpr can map to non-terminal r
# szpr indicates that (1) a register result is produced
# and (2) that the condition registers SF, ZF, PF are set based on the result.
# are set as if the result was compared to 0.
r:	szpr
0
NOFLAGS
// No code emitted

# the nonterminal szpr can map to non-terminal szp
# szp indicates that the condition registers SF, ZF, PF are set.
szp:	szpr
0
NOFLAGS
// No code emitted

# the non-terminal riv is either an r or an INT_CONSTANT
riv:	r
0
NOFLAGS
// No code emitted

riv:	INT_CONSTANT
0
NOFLAGS
// No code emitted

# the non-terminal rlv is either an r or an lv
rlv:	r
0
NOFLAGS
// No code emitted

rlv:	LONG_CONSTANT
0
NOFLAGS
// No code emitted

# A non-terminal that can be anything
any:	NULL
0
NOFLAGS
// No code emitted

any:	riv
0
NOFLAGS
// No code emitted

any:	ADDRESS_CONSTANT
0
NOFLAGS
// No code emitted

any:	LONG_CONSTANT
0
NOFLAGS
// No code emitted

any:	OTHER_OPERAND(any, any)
0
NOFLAGS
// No code emitted

##################################
# Allow Load/Store instructions to be recognized as potential memory operands
##################################
sload8:	BYTE_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), B));

sload8:	BYTE_ALOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), B_S, B));

uload8:	UBYTE_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), B));

uload8:	UBYTE_ALOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), B_S, B));

load8:	sload8
0
NOFLAGS
// no code emitted

load8:	uload8
0
NOFLAGS
// no code emitted

sload16: SHORT_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), W));

sload16: SHORT_ALOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), W_S, W));

uload16: USHORT_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), W));

uload16: USHORT_ALOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), W_S, W));

load16:	sload16
0
NOFLAGS
// no code emitted

load16:	uload16
0
NOFLAGS
// no code emitted

load32:	INT_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), DW));

load32:	INT_ALOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), DW_S, DW));

load16_32:      load16
0
NOFLAGS
// no code emitted

load16_32:      load32
0
NOFLAGS
// no code emitted

load8_16_32:	load16_32
0
NOFLAGS
// no code emitted

load8_16_32:	load8
0
NOFLAGS
// no code emitted

load64:	LONG_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), QW));

load64:	LONG_ALOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), QW_S, QW));

##################################
# Various integer computations for pointer arithmetic
##################################
address1scaledreg:	address1reg
0
NOFLAGS
//nothing to do

address:	address1scaledreg
0
NOFLAGS
//nothing to do

address1scaledreg:	INT_SHL(r, INT_CONSTANT)
LEA_SHIFT(Binary.getVal2(P(p)), 0)
EMIT_INSTRUCTION
pushAddress(null, Binary.getVal1(P(p)).asRegister(), LEA_SHIFT(Binary.getVal2(P(p))), Offset.zero());

address1reg:	INT_ADD(r, INT_CONSTANT)
0
EMIT_INSTRUCTION
pushAddress(R(Binary.getVal1(P(p))), null, B_S, Offset.fromIntSignExtend(VR(p)));

address1reg:	INT_MOVE(r)
0
EMIT_INSTRUCTION
pushAddress(R(Move.getVal(P(p))), null, B_S, Offset.zero());

address:	INT_ADD(r, r)
0
EMIT_INSTRUCTION
pushAddress(R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p))), B_S, Offset.zero());

address1reg:	INT_ADD(address1reg, INT_CONSTANT)
0
EMIT_INSTRUCTION
augmentAddress(Binary.getVal2(P(p)));

address1scaledreg:	INT_ADD(address1scaledreg, INT_CONSTANT)
0
EMIT_INSTRUCTION
augmentAddress(Binary.getVal2(P(p)));

address:	INT_ADD(r, address1scaledreg)
0
EMIT_INSTRUCTION
augmentAddress(Binary.getVal1(P(p)));

address:	INT_ADD(address1scaledreg, r)
0
EMIT_INSTRUCTION
augmentAddress(Binary.getVal2(P(p)));

address:	INT_ADD(address1scaledreg, INT_CONSTANT)
0
EMIT_INSTRUCTION
augmentAddress(Binary.getVal2(P(p)));

address:	INT_ADD(address1scaledreg, address1reg)
0
EMIT_INSTRUCTION
combineAddresses();

address:	INT_ADD(address1reg, address1scaledreg)
0
EMIT_INSTRUCTION
combineAddresses();

##################################
# Some cases where an LEA can replace several add/shift operations
##################################
r:	INT_ADD(address1scaledreg, r)
11
EMIT_INSTRUCTION
augmentAddress(Binary.getVal2(P(p))); \\
EMIT_Lea(P(p), Binary.getResult(P(p)), consumeAddress(DW, null, null));

r:	INT_ADD(r, address1scaledreg)
11
EMIT_INSTRUCTION
augmentAddress(Binary.getVal1(P(p))); \\
EMIT_Lea(P(p), Binary.getResult(P(p)), consumeAddress(DW, null, null));

r:	INT_ADD(address1scaledreg, address1reg)
11
EMIT_INSTRUCTION
combineAddresses(); \\
EMIT_Lea(P(p), Binary.getResult(P(p)), consumeAddress(DW, null, null));

r:	INT_ADD(address1reg, address1scaledreg)
11
EMIT_INSTRUCTION
combineAddresses(); \\
EMIT_Lea(P(p), Binary.getResult(P(p)), consumeAddress(DW, null, null));

r:	INT_ADD(address, INT_CONSTANT)
11
EMIT_INSTRUCTION
augmentAddress(Binary.getVal2(P(p))); \\
EMIT_Lea(P(p), Binary.getResult(P(p)), consumeAddress(DW, null, null));

r:	INT_MOVE(address)
20
EMIT_INSTRUCTION
EMIT_Lea(P(p), Move.getResult(P(p)), consumeAddress(DW, null, null));

##################################
# A few operators are passed through unchanged
##################################
stm:	IG_PATCH_POINT
10
EMIT_INSTRUCTION
EMIT(InlineGuard.mutate(P(p), IG_PATCH_POINT, null, null, null, InlineGuard.getTarget(P(p)), InlineGuard.getBranchProfile(P(p))));

stm:	UNINT_BEGIN
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	UNINT_END
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	YIELDPOINT_PROLOGUE
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	YIELDPOINT_EPILOGUE
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	YIELDPOINT_BACKEDGE
10
EMIT_INSTRUCTION
EMIT(P(p));

##################################
#
##################################
stm:	LOWTABLESWITCH(r)
10
EMIT_INSTRUCTION
LOWTABLESWITCH(P(p));

stm:	RESOLVE
10
EMIT_INSTRUCTION
RESOLVE(P(p));

##################################
# NOPs can simply be dropped
##################################
stm:	NOP
10
NOFLAGS
// drop on floor

#####
# GUARD_MOVE
#####
# note: ignoring guard registers, thus no uses
r:	GUARD_MOVE
11
EMIT_INSTRUCTION
EMIT(P(p));

#####
# GUARD_COMBINE
#####
# note: ignoring guard registers, thus no uses
r:	GUARD_COMBINE
11
EMIT_INSTRUCTION
EMIT(P(p));

#####
# NULL_CHECK
#####
stm:	NULL_CHECK(riv)
11
EMIT_INSTRUCTION
EMIT(P(p));

#####
# IR_PROLOGUE:
#####
stm:	IR_PROLOGUE
11
EMIT_INSTRUCTION
PROLOGUE(P(p));

###########
# Rules for exceptions
###########
r:	GET_CAUGHT_EXCEPTION
11
EMIT_INSTRUCTION
GET_EXCEPTION_OBJECT(P(p));

stm:	SET_CAUGHT_EXCEPTION(r)
11
EMIT_INSTRUCTION
SET_EXCEPTION_OBJECT(P(p));

##################################
# Trap operations
##################################
#####
# TRAP
#####
stm:	TRAP
10
EMIT_INSTRUCTION
EMIT(MIR_Trap.mutate(P(p), IA32_INT, Trap.getGuardResult(P(p)), Trap.getTCode(P(p))));

#####
# TRAP_IF
#####
stm:	TRAP_IF(r, INT_CONSTANT)
10
EMIT_INSTRUCTION
TRAP_IF_IMM(P(p), false);

stm:	TRAP_IF(r, LONG_CONSTANT)
10
EMIT_INSTRUCTION
TRAP_IF_IMM(P(p), true);

stm:	TRAP_IF(r, r)
10
EMIT_INSTRUCTION
EMIT(MIR_TrapIf.mutate(P(p), IA32_TRAPIF, \\
                       TrapIf.getGuardResult(P(p)), \\
		       TrapIf.getVal1(P(p)), \\
		       TrapIf.getVal2(P(p)), \\
		       COND(TrapIf.getCond(P(p))), \\
		       TrapIf.getTCode(P(p))));

### Memory operands ###
stm:	TRAP_IF(load32, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_TrapIf.mutate(P(p), IA32_TRAPIF, \\
                       TrapIf.getGuardResult(P(p)), \\
		       consumeMO(), \\
		       TrapIf.getVal2(P(p)), \\
		       COND(TrapIf.getCond(P(p))), \\
		       TrapIf.getTCode(P(p))));

stm:	TRAP_IF(riv, load32)
15
EMIT_INSTRUCTION
EMIT(MIR_TrapIf.mutate(P(p), IA32_TRAPIF, \\
                       TrapIf.getGuardResult(P(p)), \\
		       TrapIf.getVal1(P(p)), \\
	               consumeMO(), \\
		       COND(TrapIf.getCond(P(p))), \\
		       TrapIf.getTCode(P(p))));

##################################
# Basic Boolean ALU operations
##################################
#####
# BOOLEAN_NOT
#####
r:	BOOLEAN_NOT(r)
13
EMIT_INSTRUCTION
EMIT_Commutative(IA32_XOR, P(p), Unary.getResult(P(p)), Unary.getVal(P(p)), IC(1));

### Memory operands ###
stm:	BYTE_STORE(BOOLEAN_NOT(UBYTE_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_XOR, P(p), MO_S(P(p), B), MO_S(P(p), B), IC(1));

stm:	BYTE_ASTORE(BOOLEAN_NOT(UBYTE_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_XOR, P(p), MO_AS(P(p), B_S, B), MO_AS(P(p), B_S, B), IC(1));

#####
# BOOLEAN_CMP_INT
#####
r:	BOOLEAN_CMP_INT(r,riv)
39
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), \\
   BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p)), \\
   BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP_INT(r,riv)
13
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p))); \\
EMIT(MIR_Compare.mutate(P(p), IA32_CMP, BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p))));

r:	BOOLEAN_CMP_INT(r,INT_CONSTANT)
VR(p) == 0 && CMP_TO_TEST(BooleanCmp.getCond(P(p))) ? 37:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p),MIR_Test.create(IA32_TEST, BooleanCmp.getVal1(P(p)), BooleanCmp.getVal1(P(p)).copy())));\\
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP_INT(r,INT_CONSTANT)
VR(p) == 0 && CMP_TO_TEST(BooleanCmp.getCond(P(p))) ? 11:INFINITE
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p))); \\
EMIT(CPOS(P(p),MIR_Test.create(IA32_TEST, BooleanCmp.getVal1(P(p)), BooleanCmp.getVal1(P(p)).copy())));

# Special case where a boolean_cmp can become a shift
r:	BOOLEAN_CMP_INT(r,INT_CONSTANT)
VR(p) == 0 && BooleanCmp.getCond(P(p)).isLESS() ? 11 : INFINITE
EMIT_INSTRUCTION
EMIT_Commutative(IA32_SHR, P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getVal1(P(p)), IC(31));

r:	BOOLEAN_CMP_INT(load32,INT_CONSTANT)
VR(p) == 0 && BooleanCmp.getCond(P(p)).isLESS() ? 16 : INFINITE
EMIT_INSTRUCTION
EMIT_Commutative(IA32_SHR, P(p), BooleanCmp.getResult(P(p)), consumeMO(), IC(31));

r:	BOOLEAN_CMP_INT(r,INT_CONSTANT)
VR(p) == 0 && BooleanCmp.getCond(P(p)).isGREATER_EQUAL() ? 22 : INFINITE
EMIT_INSTRUCTION
RegisterOperand result = BooleanCmp.getResult(P(p)); \\
EMIT_Commutative(IA32_SHR, P(p), result, BooleanCmp.getVal1(P(p)), IC(31)); \\
EMIT(CPOS(P(p),MIR_BinaryAcc.create(IA32_XOR, result.copyRO(), IC(1))));

r:	BOOLEAN_CMP_INT(load32,INT_CONSTANT)
VR(p) == 0 && BooleanCmp.getCond(P(p)).isGREATER_EQUAL() ? 27 : INFINITE
EMIT_INSTRUCTION
RegisterOperand result = BooleanCmp.getResult(P(p)); \\
EMIT_Commutative(IA32_SHR, P(p), result, consumeMO(), IC(31)); \\
EMIT(CPOS(P(p),MIR_BinaryAcc.create(IA32_XOR, result.copyRO(), IC(1))));

r:	BOOLEAN_CMP_INT(cz, INT_CONSTANT)
isZERO(VR(p), 26)
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP_INT(cz, INT_CONSTANT)
isZERO(VR(p), 0)
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p)));

r:	BOOLEAN_CMP_INT(szp, INT_CONSTANT)
VR(p) == 0 && EQ_NE(BooleanCmp.getCond(P(p)))?26:INFINITE
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP_INT(szp, INT_CONSTANT)
VR(p) == 0 && EQ_NE(BooleanCmp.getCond(P(p)))?0:INFINITE
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p)));

## bit tests
r:	BOOLEAN_CMP_INT(bittest, INT_CONSTANT)
(VR(p) == 0 || VR(p) == 1) && EQ_NE(BooleanCmp.getCond(P(p))) ? 26 : INFINITE
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BIT_TEST(VR(p),BooleanCmp.getCond(P(p))));

boolcmp:	BOOLEAN_CMP_INT(bittest, INT_CONSTANT)
(VR(p) == 0 || VR(p) == 1) && EQ_NE(BooleanCmp.getCond(P(p))) ? 0 : INFINITE
EMIT_INSTRUCTION
pushCOND(BIT_TEST(VR(p),BooleanCmp.getCond(P(p))));

## chaining of boolcmps
r:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
(VR(p) == 0 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()) || \
(VR(p) == 1 && BooleanCmp.getCond(P(p)).isEQUAL()) ? 26 : INFINITE
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), consumeCOND());

boolcmp:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
(VR(p) == 0 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()) || \
(VR(p) == 1 && BooleanCmp.getCond(P(p)).isEQUAL()) ? 0 : INFINITE
NOFLAGS
// use already pushed condition

r:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
(VR(p) == 1 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()) || \
(VR(p) == 0 && BooleanCmp.getCond(P(p)).isEQUAL()) ? 26 : INFINITE
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), consumeCOND().flipCode());

boolcmp:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
(VR(p) == 1 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()) || \
(VR(p) == 0 && BooleanCmp.getCond(P(p)).isEQUAL()) ? 0 : INFINITE
EMIT_INSTRUCTION
pushCOND(consumeCOND().flipCode()); // invert already pushed condition

### Memory operands ###
r:	BOOLEAN_CMP_INT(load32,riv)
41
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(PL(p), BooleanCmp.getResult(P(p)), \\
            consumeMO(), BooleanCmp.getVal2(P(p)), \\
	    BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP_INT(load32,riv)
15
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p))); \\
EMIT(MIR_Compare.mutate(PL(p), IA32_CMP, consumeMO(), BooleanCmp.getVal2(P(p))));

r:	BOOLEAN_CMP_INT(r,load32)
41
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(PR(p), BooleanCmp.getResult(P(p)), \\
            BooleanCmp.getVal1(P(p)), consumeMO(), \\
	    BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP_INT(riv,load32)
15
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p)).flipOperands()); \\
EMIT(MIR_Compare.mutate(PR(p), IA32_CMP, consumeMO(), BooleanCmp.getVal1(P(p))));

stm:	BYTE_STORE(boolcmp, OTHER_OPERAND(riv,riv))
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Set.mutate(P(p), IA32_SET__B, MO_S(P(p),B), COND(consumeCOND())));

stm:	BYTE_ASTORE(boolcmp, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Set.mutate(P(p), IA32_SET__B, MO_AS(P(p),B_S,B), COND(consumeCOND())));

#####
# BOOLEAN_CMP_LONG
#####
r:	BOOLEAN_CMP_LONG(rlv,rlv)
8*13
EMIT_INSTRUCTION
BOOLEAN_CMP_LONG(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p)), BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP_LONG(rlv,rlv)
11*13
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p))); \\
LONG_CMP(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p))); \\
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, BooleanCmp.getResult(P(p)), IC(0))));

##################################
# Conditional moves
##################################
r: CMP_CMOV(r, OTHER_OPERAND(riv, any))
(13 + 30)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP,  CondMove.getVal1(P(p)), CondMove.getVal2(P(p))))); \\
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \\
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_CMOV(r, OTHER_OPERAND(INT_CONSTANT, any))
VRL(p) == 0 && CMP_TO_TEST(CondMove.getCond(P(p))) ? (11 + 30):INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Test.create(IA32_TEST, CondMove.getVal1(P(p)), CondMove.getVal1(P(p)).copy()))); \\
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \\
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# Special case where a conditional move can become a shift
r: CMP_CMOV(r, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(INT_CONSTANT, INT_CONSTANT)))
(VRL(p) == 0 && CondMove.getCond(P(p)).isLESS() && VRRL(p) == -1 && VRRR(p) == 0) || \
(VRL(p) == 0 && CondMove.getCond(P(p)).isGREATER_EQUAL() && VRRL(p) == 0 && VRRR(p) == -1) ? 13 : INFINITE
EMIT_INSTRUCTION
EMIT_Commutative(IA32_SAR, P(p), CondMove.getResult(P(p)), CondMove.getVal1(P(p)), IC(31));

r: CMP_CMOV(load32, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(INT_CONSTANT, INT_CONSTANT)))
(VRL(p) == 0 && CondMove.getCond(P(p)).isLESS() && VRRL(p) == -1 && VRRR(p) == 0) || \
(VRL(p) == 0 && CondMove.getCond(P(p)).isGREATER_EQUAL() && VRRL(p) == 0 && VRRR(p) == -1) ? 18 : INFINITE
EMIT_INSTRUCTION
EMIT_Commutative(IA32_SAR, P(p), CondMove.getResult(P(p)), consumeMO(), IC(31));

r: CMP_CMOV(r, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(INT_CONSTANT, INT_CONSTANT)))
(VRL(p) == 0 && CondMove.getCond(P(p)).isLESS() && VRRL(p) == 0 && VRRR(p) == -1) || \
(VRL(p) == 0 && CondMove.getCond(P(p)).isGREATER_EQUAL() && VRRL(p) == -1 && VRRR(p) == 0) ? 26 : INFINITE
EMIT_INSTRUCTION
RegisterOperand result = CondMove.getResult(P(p)); \\
EMIT_Commutative(IA32_SAR, P(p), result, CondMove.getVal1(P(p)), IC(31)); \\
EMIT(CPOS(P(p),MIR_UnaryAcc.create(IA32_NOT, result.copyRO())));

r: CMP_CMOV(load32, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(INT_CONSTANT, INT_CONSTANT)))
(VRL(p) == 0 && CondMove.getCond(P(p)).isLESS() && VRRL(p) == 0 && VRRR(p) == -1) || \
(VRL(p) == 0 && CondMove.getCond(P(p)).isGREATER_EQUAL() && VRRL(p) == -1 && VRRR(p) == 0) ? 31 : INFINITE
EMIT_INSTRUCTION
RegisterOperand result = CondMove.getResult(P(p)); \\
EMIT_Commutative(IA32_SAR, P(p), result, consumeMO(), IC(31)); \\
EMIT(CPOS(P(p),MIR_UnaryAcc.create(IA32_NOT, result.copyRO())));

# Because uload is only used for booleans (0/1) we can get away
# with this for both signed and unsigned loads.
r: CMP_CMOV(load8, OTHER_OPERAND(INT_CONSTANT, any))
FITS(CondMove.getVal2(P(p)), 8, (15 + 30))
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal2(P(p))))); \\
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \\
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# We only use uload8 for boolean values, so if the IR is well-typed,
# then r must contain either 0 or 1 and we can do this.
r: CMP_CMOV(uload8, OTHER_OPERAND(riv, any))
(15 + 30)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal2(P(p))))); \\
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \\
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# We only use uload8 for boolean values, so if the IR is well-typed,
# then r must contain either 0 or 1 and we can do this.
r: CMP_CMOV(riv, OTHER_OPERAND(uload8, any))
(15 + 30)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal2(P(p))))); \\
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \\
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_CMOV(sload16, OTHER_OPERAND(INT_CONSTANT, any))
FITS(CondMove.getVal2(P(p)), 8, (15 + 30))
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal2(P(p))))); \\
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \\
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_CMOV(load32, OTHER_OPERAND(riv, any))
(15 + 30)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal2(P(p))))); \\
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \\
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_CMOV(riv, OTHER_OPERAND(load32, any))
(15 + 30)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal1(P(p))))); \\
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)).flipOperands(), \\
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# CMP_CMOV((boolcmp, 0/1), tv, fv)
r: CMP_CMOV(boolcmp, OTHER_OPERAND(INT_CONSTANT, any))
(VRL(p) == 0 && CondMove.getCond(P(p)).isNOT_EQUAL()) || \
(VRL(p) == 1 && CondMove.getCond(P(p)).isEQUAL()) ? 30 : INFINITE
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(P(p), CondMove.getResult(P(p)), consumeCOND(), \\
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_CMOV(boolcmp, OTHER_OPERAND(INT_CONSTANT, any))
(VRL(p) == 1 && CondMove.getCond(P(p)).isNOT_EQUAL()) || \
(VRL(p) == 0 && CondMove.getCond(P(p)).isEQUAL()) ? 30 : INFINITE
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(P(p), CondMove.getResult(P(p)), consumeCOND().flipCode(), \\
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# CMP_CMOV((bittest, 0/1), tv, fv)
r: CMP_CMOV(bittest, OTHER_OPERAND(INT_CONSTANT, any))
(VRL(p) == 0 || VRL(p) == 1) && EQ_NE(CondMove.getCond(P(p))) ? 30 : INFINITE
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(P(p), CondMove.getResult(P(p)), BIT_TEST(VRL(p), CondMove.getCond(P(p))), \\
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# CMOV((cz, 0), tv ,fv); condition code already set
r: CMP_CMOV(cz, OTHER_OPERAND(INT_CONSTANT, any))
isZERO(VRL(p), 30)
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \\
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# CMOV((szp, 0), tv ,fv); condition code already set
r: CMP_CMOV(szp, OTHER_OPERAND(INT_CONSTANT, any))
isZERO(VRL(p), 30)
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \\
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

#####
# LCMP_CMOV
#####
r: LCMP_CMOV(r, OTHER_OPERAND(rlv, any))
(8*13 + 30)
EMIT_INSTRUCTION
LCMP_CMOV(P(p), CondMove.getResult(P(p)), CondMove.getVal1(P(p)), CondMove.getVal2(P(p)),\\
          CondMove.getCond(P(p)), CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

##################################
# Basic Integer ALU operations
##################################
#####
# INT_ADD
#####
czr:	INT_ADD(r, riv)
13
EMIT_INSTRUCTION
EMIT_Commutative(IA32_ADD, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

r:	INT_ADD(r, riv)
!Binary.getResult(P(p)).similar(Binary.getVal1(P(p))) && \
!Binary.getResult(P(p)).similar(Binary.getVal2(P(p))) ? 11 : INFINITE
EMIT_INSTRUCTION
if (Binary.getVal2(P(p)).isIntConstant()) { \\
 pushAddress(R(Binary.getVal1(P(p))), null, B_S, Offset.fromIntSignExtend(VR(p))); \\
} else { \\
 pushAddress(R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p))), B_S, Offset.zero()); \\
} \\
EMIT_Lea(P(p), Binary.getResult(P(p)), consumeAddress(DW, null, null));

### Memory operands ###
czr:	INT_ADD(riv, load32)
15
EMIT_INSTRUCTION
EMIT_Commutative(IA32_ADD, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), consumeMO());

czr:	INT_ADD(load32, riv)
15
EMIT_INSTRUCTION
EMIT_Commutative(IA32_ADD, P(p), Binary.getResult(P(p)), Binary.getVal2(P(p)), consumeMO());

stm:	INT_STORE(INT_ADD(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_ADD, P(p), MO_S(P(p), DW), MO_S(P(p), DW), Binary.getVal2(PL(p)));

stm:	INT_STORE(INT_ADD(riv,INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLR(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_ADD, P(p), MO_S(P(p), DW), MO_S(P(p), DW), Binary.getVal1(PL(p)));

stm:	INT_ASTORE(INT_ADD(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_ADD, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW), Binary.getVal2(PL(p)));

stm:	INT_ASTORE(INT_ADD(riv,INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLR(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_ADD, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW), Binary.getVal1(PL(p)));

#####
# INT_SUB
#####
czr:	INT_SUB(riv, r)
13
EMIT_INSTRUCTION
EMIT_NonCommutative(IA32_SUB, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

# NB the simplifier means we shouldn't generate the following case
# r:	INT_SUB(riv, INT_CONSTANT)
#
# Cases where we could use negate then add to avoid register pressure
r:	INT_SUB(riv, r)
Binary.getResult(P(p)).similar(Binary.getVal2(P(p))) ? 13-2 : INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_UnaryAcc.create(IA32_NEG, Binary.getResult(P(p))))); \\
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, Binary.getResult(P(p)), Binary.getVal1(P(p))));

r:	INT_SUB(load32, r)
Binary.getResult(P(p)).similar(Binary.getVal2(P(p))) ? 15-2 : INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_UnaryAcc.create(IA32_NEG, Binary.getResult(P(p))))); \\
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, Binary.getResult(P(p)), consumeMO()));

### Memory operands ###
czr:	INT_SUB(riv, load32)
15
EMIT_INSTRUCTION
EMIT_NonCommutative(IA32_SUB, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), consumeMO());

czr:	INT_SUB(load32, riv)
15
EMIT_INSTRUCTION
EMIT_NonCommutative(IA32_SUB, P(p), Binary.getResult(P(p)), consumeMO(), Binary.getVal2(P(p)));

stm:	INT_STORE(INT_SUB(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SUB, MO_S(P(p), DW), Binary.getVal2(PL(p))));

stm:	INT_STORE(INT_SUB(riv, INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLR(p), 27)
EMIT_INSTRUCTION
MemoryOperand result = MO_S(P(p), DW); \\
EMIT(CPOS(P(p), MIR_UnaryAcc.create(IA32_NEG, result))); \\
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, result.copy(), Binary.getVal1(PL(p))));

stm:	INT_ASTORE(INT_SUB(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SUB, MO_AS(P(p), DW_S, DW), Binary.getVal2(PL(p))));

stm:	INT_ASTORE(INT_SUB(riv, INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLR(p), 27)
EMIT_INSTRUCTION
MemoryOperand result = MO_AS(P(p), DW_S, DW); \\
EMIT(CPOS(P(p), MIR_UnaryAcc.create(IA32_NEG, result))); \\
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, result.copy(), Binary.getVal1(PL(p))));

#####
# INT_MUL
#####
r:	INT_MUL(riv, riv)
13
EMIT_INSTRUCTION
EMIT_Commutative(IA32_IMUL2, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

### Memory operands ###
r:	INT_MUL(riv, load32)
15
EMIT_INSTRUCTION
EMIT_Commutative(IA32_IMUL2, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), consumeMO());

r:	INT_MUL(load32, riv)
15
EMIT_INSTRUCTION
EMIT_Commutative(IA32_IMUL2, P(p), Binary.getResult(P(p)), Binary.getVal2(P(p)), consumeMO());

# TODO: consider adding rules for the many IMUL forms, such as reg1 = reg2 * imm
#####
# INT_DIV
#####
r:	INT_DIV(riv, riv)
52
EMIT_INSTRUCTION
INT_DIVIDES(P(p), GuardedBinary.getResult(P(p)), GuardedBinary.getVal1(P(p)), \\
	                GuardedBinary.getVal2(P(p)), true);

### Memory operands ###
r:	INT_DIV(riv, load32)
55
EMIT_INSTRUCTION
INT_DIVIDES(P(p), GuardedBinary.getResult(P(p)), GuardedBinary.getVal1(P(p)), \\
	                consumeMO(), true);

#####
# INT_REM
#####
r:	INT_REM(riv, riv)
52
EMIT_INSTRUCTION
INT_DIVIDES(P(p), GuardedBinary.getResult(P(p)), GuardedBinary.getVal1(P(p)), \\
	                GuardedBinary.getVal2(P(p)), false);

### Memory operands ###
r:	INT_REM(riv, load32)
55
EMIT_INSTRUCTION
INT_DIVIDES(P(p), GuardedBinary.getResult(P(p)), GuardedBinary.getVal1(P(p)), \\
	                consumeMO(), false);

#####
# INT_NEG
#####
szpr:	INT_NEG(r)
13
EMIT_INSTRUCTION
EMIT_Unary(IA32_NEG, P(p), Unary.getResult(P(p)), Unary.getVal(P(p)));

### Memory operands ###
stm:	INT_STORE(INT_NEG(INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT_Unary(IA32_NEG, P(p), MO_S(P(p), DW), MO_S(P(p), DW));

stm:	INT_ASTORE(INT_NEG(INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT_Unary(IA32_NEG, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW));

#####
# INT_SHL
#####
szpr:	INT_SHL(riv, INT_AND(r, INT_CONSTANT))
VRR(p) == 31 ? 23 : INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getVal1(PR(p))))); \\
EMIT_NonCommutative(IA32_SHL, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));

szpr:	INT_SHL(riv, riv)
23
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getVal2(P(p))))); \\
EMIT_NonCommutative(IA32_SHL, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));

szpr:	INT_SHL(r, INT_CONSTANT)
13
EMIT_INSTRUCTION
if (VM.VerifyAssertions) VM._assert((VR(p) & 0x7FFFFFFF) <= 31); \
if(Binary.getVal2(P(p)).asIntConstant().value == 1) { \\
 EMIT_NonCommutative(IA32_ADD, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal1(P(p)).copy()); \\
} else { \\
 EMIT_NonCommutative(IA32_SHL, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p))); \\
}

r:	INT_SHL(r, INT_CONSTANT)
!Binary.getResult(P(p)).similar(Binary.getVal1(P(p))) && \
(Binary.getVal2(P(p)).asIntConstant().value & 0x1f) <= 3 ? 11 : INFINITE
EMIT_INSTRUCTION
pushAddress(null, Binary.getVal1(P(p)).asRegister(), LEA_SHIFT(Binary.getVal2(P(p))), Offset.zero()); \\
EMIT_Lea(P(p), Binary.getResult(P(p)), consumeAddress(DW, null, null));

# Are shifts being used to mask out lower bits?
szpr:	INT_SHL(INT_SHR(r, INT_CONSTANT), INT_CONSTANT)
(VR(p) == VLR(p)) ? 23 : INFINITE
EMIT_INSTRUCTION
EMIT_Commutative(IA32_AND, P(p), Binary.getResult(P(p)), Binary.getVal1(PL(p)), IC(0xffffffff << VR(p)));

### Memory operands ###
stm:	INT_STORE(INT_SHL(INT_LOAD(riv,riv),INT_AND(r,INT_CONSTANT)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 31 ? 27 : INFINITE)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getVal1(PLR(p))))); \\
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_S(P(p), DW), new RegisterOperand(getECX(), TypeReference.Int)));

stm:	INT_STORE(INT_SHL(INT_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
if (VM.VerifyAssertions) VM._assert((VLR(p) & 0x7FFFFFFF) <= 31); \\
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_S(P(p), DW), Binary.getVal2(PL(p))));

stm:	INT_ASTORE(INT_SHL(INT_ALOAD(riv,riv),INT_AND(r, INT_CONSTANT)),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 31 ? 27 : INFINITE)
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getVal1(PLR(p)))); \\
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_AS(P(p), DW_S, DW), new RegisterOperand(getECX(), TypeReference.Int)));

stm:	INT_ASTORE(INT_SHL(INT_ALOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLR(p) == 31 ? 17 : INFINITE)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_AS(P(p), DW_S, DW), Binary.getVal2(PL(p))));

#####
# INT_SHR:
#####
szpr:	INT_SHR(riv, INT_AND(r, INT_CONSTANT))
VRR(p) == 31 ? 23 : INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getVal1(PR(p))))); \\
EMIT_NonCommutative(IA32_SAR, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));

szpr:	INT_SHR(riv, riv)
23
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getVal2(P(p))))); \\
EMIT_NonCommutative(IA32_SAR, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));

szpr:	INT_SHR(riv, INT_CONSTANT)
13
EMIT_INSTRUCTION
if (VM.VerifyAssertions) VM._assert((VR(p) & 0x7FFFFFFF) <= 31); \\
EMIT_NonCommutative(IA32_SAR, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

### Memory operands ###
stm:	INT_STORE(INT_SHR(INT_LOAD(riv,riv),INT_AND(r,INT_CONSTANT)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 31 ? 27 : INFINITE)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getVal1(PLR(p))))); \\
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_S(P(p), DW), new RegisterOperand(getECX(), TypeReference.Int)));

stm:	INT_STORE(INT_SHR(INT_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
if (VM.VerifyAssertions) VM._assert((VLR(p) & 0x7FFFFFFF) <= 31); \\
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_S(P(p), DW), Binary.getVal2(PL(p))));

stm:	INT_ASTORE(INT_SHR(INT_ALOAD(riv,riv),INT_AND(r, INT_CONSTANT)),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 31 ? 27 : INFINITE)
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getVal1(PLR(p)))); \\
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_AS(P(p), DW_S, DW), new RegisterOperand(getECX(), TypeReference.Int)));

stm:	INT_ASTORE(INT_SHR(INT_ALOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLR(p) == 31 ? 17 : INFINITE)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_AS(P(p), DW_S, DW), Binary.getVal2(PL(p))));

#####
# INT_USHR
#####
szpr:	INT_USHR(riv, INT_AND(r, INT_CONSTANT))
VRR(p) == 31 ? 23 : INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getVal1(PR(p))))); \\
EMIT_NonCommutative(IA32_SHR, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));

szpr:	INT_USHR(riv, riv)
23
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getVal2(P(p))))); \\
EMIT_NonCommutative(IA32_SHR, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));

szpr:	INT_USHR(riv, INT_CONSTANT)
13
EMIT_INSTRUCTION
if (VM.VerifyAssertions) VM._assert((VR(p) & 0x7FFFFFFF) <= 31); \\
EMIT_NonCommutative(IA32_SHR, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

### Memory operands ###
stm:	INT_STORE(INT_USHR(INT_LOAD(riv,riv),INT_AND(r,INT_CONSTANT)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 31 ? 27 : INFINITE)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getVal1(PLR(p))))); \\
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_S(P(p), DW), new RegisterOperand(getECX(), TypeReference.Int)));

stm:	INT_STORE(INT_USHR(INT_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
if (VM.VerifyAssertions) VM._assert((VLR(p) & 0x7FFFFFFF) <= 31); \\
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_S(P(p), DW), Binary.getVal2(PL(p))));

stm:	INT_ASTORE(INT_USHR(INT_ALOAD(riv,riv),INT_AND(r, INT_CONSTANT)),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 31 ? 27 : INFINITE)
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getVal1(PLR(p)))); \\
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_AS(P(p), DW_S, DW), new RegisterOperand(getECX(), TypeReference.Int)));

stm:	INT_ASTORE(INT_USHR(INT_ALOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLR(p) == 31 ? 17 : INFINITE)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_AS(P(p), DW_S, DW), Binary.getVal2(PL(p))));

#####
# Rotates
#####
r:	INT_OR(INT_SHL(r,INT_CONSTANT),INT_USHR(r,INT_CONSTANT))
Binary.getVal1(PL(p)).similar(Binary.getVal1(PR(p))) && \
((-VLR(p)) & 0x1f) == (VRR(p)&0x1f) ? 13 : INFINITE
EMIT_INSTRUCTION
EMIT_NonCommutative(IA32_ROL, P(p), Binary.getResult(P(p)), Binary.getVal1(PL(p)).copy(), IC(VLR(p)&0x1f));

r:      INT_OR(INT_USHR(r,INT_CONSTANT),INT_SHL(r,INT_CONSTANT))
Binary.getVal1(PL(p)).similar(Binary.getVal1(PR(p))) && \
((-VRR(p)) & 0x1f) == (VLR(p)&0x1f) ? 13 : INFINITE
EMIT_INSTRUCTION
EMIT_NonCommutative(IA32_ROL, P(p), Binary.getResult(P(p)), Binary.getVal1(PL(p)).copy(), IC(VRR(p)&0x1f));

r:      INT_OR(INT_SHL(r,INT_CONSTANT),INT_USHR(r,INT_CONSTANT))
Binary.getVal1(PL(p)).similar(Binary.getVal1(PR(p))) && \
((-VLR(p)) & 0x1f) == (VRR(p)&0x1f) && ((VLR(p)&0x1f) == 31) ? 11 : INFINITE
EMIT_INSTRUCTION
EMIT_NonCommutative(IA32_ROR, P(p), Binary.getResult(P(p)), Binary.getVal1(PL(p)).copy(), IC(1));

r:      INT_OR(INT_USHR(r,INT_CONSTANT),INT_SHL(r,INT_CONSTANT))
Binary.getVal1(PL(p)).similar(Binary.getVal1(PR(p))) && \
((-VRR(p)) & 0x1f) == (VLR(p)&0x1f) && ((VRR(p)&0x1f) == 31) ? 11 : INFINITE
EMIT_INSTRUCTION
EMIT_NonCommutative(IA32_ROR, P(p), Binary.getResult(P(p)), Binary.getVal1(PL(p)).copy(), IC(1));

r:      INT_OR(INT_SHL(r,INT_AND(r,INT_CONSTANT)),INT_USHR(r,INT_AND(INT_NEG(r),INT_CONSTANT)))
Binary.getVal1(PL(p)).similar(Binary.getVal1(PR(p))) && \
(VLRR(p) == 31) && (VRRR(p) == 31) && \
Binary.getVal1(PLR(p)).similar(Unary.getVal(PRRL(p))) ? 23 : INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getVal1(PLR(p))))); \\
EMIT_NonCommutative(IA32_ROL, P(p), Binary.getResult(P(p)), Binary.getVal1(PL(p)).copy(), new RegisterOperand(getECX(), TypeReference.Int));

r:      INT_OR(INT_USHR(r,INT_AND(INT_NEG(r),INT_CONSTANT)),INT_SHL(r,INT_AND(r,INT_CONSTANT)))
Binary.getVal1(PL(p)).similar(Binary.getVal1(PR(p))) && \
(VLRR(p) == 31) && (VRRR(p) == 31) && \
Binary.getVal1(PRR(p)).similar(Unary.getVal(PLRL(p))) ? 23 : INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getVal1(PRR(p))))); \\
EMIT_NonCommutative(IA32_ROL, P(p), Binary.getResult(P(p)), Binary.getVal1(PL(p)).copy(), new RegisterOperand(getECX(), TypeReference.Int));

r:      INT_OR(INT_SHL(r,INT_AND(INT_NEG(r),INT_CONSTANT)),INT_USHR(r,INT_AND(r,INT_CONSTANT)))
Binary.getVal1(PL(p)).similar(Binary.getVal1(PR(p))) && \
(VLRR(p) == 31) && (VRRR(p) == 31) && \
Binary.getVal1(PRR(p)).similar(Unary.getVal(PLRL(p))) ? 23 : INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getVal1(PRR(p))))); \\
EMIT_NonCommutative(IA32_ROR, P(p), Binary.getResult(P(p)), Binary.getVal1(PL(p)).copy(), new RegisterOperand(getECX(), TypeReference.Int));

r:      INT_OR(INT_USHR(r,INT_AND(r,INT_CONSTANT)),INT_SHL(r,INT_AND(INT_NEG(r),INT_CONSTANT)))
Binary.getVal1(PL(p)).similar(Binary.getVal1(PR(p))) && \
(VLRR(p) == 31) && (VRRR(p) == 31) && \
Binary.getVal1(PLR(p)).similar(Unary.getVal(PRRL(p))) ? 23 : INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getVal1(PLR(p))))); \\
EMIT_NonCommutative(IA32_ROR, P(p), Binary.getResult(P(p)), Binary.getVal1(PL(p)).copy(), new RegisterOperand(getECX(), TypeReference.Int));

#####
# INT_AND
#####
szpr:	INT_AND(riv, riv)
13
EMIT_INSTRUCTION
EMIT_Commutative(IA32_AND, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

szp:	INT_AND(r, riv)
11
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(P(p), IA32_TEST, Binary.getVal1(P(p)), Binary.getVal2(P(p))));

### Memory operands ###
szpr:	INT_AND(riv, load32)
15
EMIT_INSTRUCTION
EMIT_Commutative(IA32_AND, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), consumeMO());

szpr:	INT_AND(load32, riv)
15
EMIT_INSTRUCTION
EMIT_Commutative(IA32_AND, P(p), Binary.getResult(P(p)), Binary.getVal2(P(p)), consumeMO());

szp:	INT_AND(load8_16_32, riv)
11
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(P(p), IA32_TEST, consumeMO(), Binary.getVal2(P(p))));

szp:	INT_AND(riv, load8_16_32)
11
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(P(p), IA32_TEST, consumeMO(), Binary.getVal1(P(p))));

stm:	INT_STORE(INT_AND(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_AND, P(p), MO_S(P(p), DW), MO_S(P(p), DW), Binary.getVal2(PL(p)) );

stm:	INT_STORE(INT_AND(riv,INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLR(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_AND, P(p), MO_S(P(p), DW), MO_S(P(p), DW), Binary.getVal1(PL(p)) );

stm:	INT_ASTORE(INT_AND(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_AND, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW), Binary.getVal2(PL(p)) );

stm:	INT_ASTORE(INT_AND(riv,INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLR(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_AND, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW), Binary.getVal1(PL(p)) );

#####
# INT_OR
#####
szpr:	INT_OR(riv, riv)
13
EMIT_INSTRUCTION
EMIT_Commutative(IA32_OR, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

### Memory operands ###
szpr:	INT_OR(riv, load32)
15
EMIT_INSTRUCTION
EMIT_Commutative(IA32_OR, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), consumeMO() );

szpr:	INT_OR(load32, riv)
15
EMIT_INSTRUCTION
EMIT_Commutative(IA32_OR, P(p), Binary.getResult(P(p)), Binary.getVal2(P(p)), consumeMO() );

stm:	INT_STORE(INT_OR(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_OR, P(p), MO_S(P(p), DW), MO_S(P(p), DW), Binary.getVal2(PL(p)) );

stm:	INT_STORE(INT_OR(riv, INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLR(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_OR, P(p), MO_S(P(p), DW), MO_S(P(p), DW), Binary.getVal1(PL(p)) );

stm:	INT_ASTORE(INT_OR(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_OR, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW), Binary.getVal2(PL(p)) );

stm:	INT_ASTORE(INT_OR(riv, INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLR(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_OR, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW), Binary.getVal1(PL(p)) );

#####
# INT_XOR
#####
szpr:	INT_XOR(riv, riv)
13
EMIT_INSTRUCTION
EMIT_Commutative(IA32_XOR, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

### Memory operands ###
szpr:	INT_XOR(riv, load32)
15
EMIT_INSTRUCTION
EMIT_Commutative(IA32_XOR, P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), consumeMO() );

szpr:	INT_XOR(load32, riv)
15
EMIT_INSTRUCTION
EMIT_Commutative(IA32_XOR, P(p), Binary.getResult(P(p)), Binary.getVal2(P(p)), consumeMO() );

stm:	INT_STORE(INT_XOR(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_XOR, P(p), MO_S(P(p), DW), MO_S(P(p), DW), Binary.getVal2(PL(p)) );

stm:	INT_STORE(INT_XOR(riv,INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLR(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_XOR, P(p), MO_S(P(p), DW), MO_S(P(p), DW), Binary.getVal1(PL(p)) );

stm:	INT_ASTORE(INT_XOR(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_XOR, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW), Binary.getVal2(PL(p)) );

stm:	INT_ASTORE(INT_XOR(riv,INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLR(p), 17)
EMIT_INSTRUCTION
EMIT_Commutative(IA32_XOR, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW), Binary.getVal1(PL(p)) );

#####
# INT_NOT
#####
r:	INT_NOT(r)
13
EMIT_INSTRUCTION
EMIT_Unary(IA32_NOT, P(p), Unary.getResult(P(p)), Unary.getVal(P(p)));

### Memory operands ###
stm:	INT_STORE(INT_NOT(INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT_Unary(IA32_NOT, P(p), MO_S(P(p), DW), MO_S(P(p), DW));

stm:	INT_ASTORE(INT_NOT(INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT_Unary(IA32_NOT, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW));

##################################
# Basic Long ALU operations
##################################
#####
# LONG_ADD
#####
r:	LONG_ADD(r, rlv)
23
EMIT_INSTRUCTION
LONG_ADD(P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

#####
# LONG_SUB
#####
r:	LONG_SUB(rlv, rlv)
23
EMIT_INSTRUCTION
LONG_SUB(P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

#####
# LONG_MUL
#####
r:	LONG_MUL(rlv, rlv)
23
EMIT_INSTRUCTION
LONG_MUL(P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

#####
# LONG_NEG
#####
r:	LONG_NEG(r)
23
EMIT_INSTRUCTION
LONG_NEG(P(p), Unary.getResult(P(p)), Unary.getVal(P(p)));

#####
# LONG_SHL
#####
r:	LONG_SHL(rlv, riv)
20
EMIT_INSTRUCTION
LONG_SHL(P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)), false);

r:	LONG_SHL(rlv, INT_AND(riv, INT_CONSTANT))
20
EMIT_INSTRUCTION
if (VM.VerifyAssertions) VM._assert((VRR(p) & 0x7FFFFFFF) <= 63); \\
LONG_SHL(P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal1(PR(p)), true);

#####
# LONG_SHR
#####
r:	LONG_SHR(rlv, riv)
20
EMIT_INSTRUCTION
LONG_SHR(P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)), false);

r:	LONG_SHR(rlv, INT_AND(riv, INT_CONSTANT))
20
EMIT_INSTRUCTION
if (VM.VerifyAssertions) VM._assert((VRR(p) & 0x7FFFFFFF) <= 63); \\
LONG_SHR(P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal1(PR(p)), true);

#####
# LONG_USHR
#####
r:	LONG_USHR(rlv, riv)
20
EMIT_INSTRUCTION
LONG_USHR(P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)), false);

r:	LONG_USHR(rlv, INT_AND(riv, INT_CONSTANT))
20
EMIT_INSTRUCTION
if (VM.VerifyAssertions) VM._assert((VRR(p) & 0x7FFFFFFF) <= 63); \\
LONG_USHR(P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal1(PR(p)), true);

#####
# LONG_AND
#####
r:	LONG_AND(rlv, rlv)
23
EMIT_INSTRUCTION
LONG_AND(P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

#####
# LONG_OR
#####
r:	LONG_OR(rlv, rlv)
23
EMIT_INSTRUCTION
LONG_OR(P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

#####
# LONG_XOR
#####
r:	LONG_XOR(r, rlv)
23
EMIT_INSTRUCTION
LONG_XOR(P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

#####
# LONG_NOT
#####
r:	LONG_NOT(r)
23
EMIT_INSTRUCTION
LONG_NOT(P(p), Unary.getResult(P(p)), Unary.getVal(P(p)));

##################################
# Basic Conversion operations
##################################
#####
# INT_2BYTE
#####
r:	INT_2BYTE(r)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, Unary.getResult(P(p)), Unary.getVal(P(p))));

r:	INT_2BYTE(load8_16_32)
17
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, Unary.getResult(P(p)), consumeMO()));

stm:	BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), B), Unary.getVal(PL(p))));

stm:	BYTE_ASTORE(INT_2BYTE(r),OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), B_S, B), Unary.getVal(PL(p))));

#####
# INT_2USHORT
#####
szpr:	INT_2USHORT(r)
23
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, Unary.getResult(P(p)), Unary.getVal(P(p))))); \\
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, Unary.getResult(P(p)).copyRO(), IC(0xFFFF)));

r:	INT_2USHORT(load16_32)
25
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, Unary.getResult(P(p)), setSize(consumeMO(),2)));

stm:	SHORT_STORE(INT_2USHORT(r), OTHER_OPERAND(riv,riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), Unary.getVal(PL(p))));

stm:	SHORT_ASTORE(INT_2USHORT(r), OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), Unary.getVal(PL(p))));

#####
# INT_2SHORT
#####
r:	INT_2SHORT(r)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__W, Unary.getResult(P(p)), Unary.getVal(P(p))));

r:	INT_2SHORT(load16_32)
17
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__W, Unary.getResult(P(p)), consumeMO()));

stm:	SHORT_STORE(INT_2SHORT(r), OTHER_OPERAND(riv,riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), Unary.getVal(PL(p))));

stm:	SHORT_ASTORE(INT_2SHORT(r), OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), Unary.getVal(PL(p))));

#####
# INT_2LONG
#####
r:	INT_2LONG(r)
33
EMIT_INSTRUCTION
INT_2LONG(P(p), Unary.getResult(P(p)), Unary.getVal(P(p)), true);

r:	INT_2LONG(load32)
38
EMIT_INSTRUCTION
INT_2LONG(P(p), Unary.getResult(P(p)), consumeMO(), true);

r:      LONG_AND(INT_2LONG(r), LONG_CONSTANT)
(Binary.getVal2(P(p)).asLongConstant().upper32() == 0) && \
(Binary.getVal2(P(p)).asLongConstant().lower32() == -1)? 23 : INFINITE
EMIT_INSTRUCTION
INT_2LONG(P(p), Binary.getResult(P(p)), Unary.getVal(PL(p)), false);

r:      LONG_AND(INT_2LONG(load32), LONG_CONSTANT)
(Binary.getVal2(P(p)).asLongConstant().upper32() == 0) && \
(Binary.getVal2(P(p)).asLongConstant().lower32() == -1)? 28 : INFINITE
EMIT_INSTRUCTION
INT_2LONG(P(p), Binary.getResult(P(p)), consumeMO(), false);

r:      LONG_SHL(INT_2LONG(r), INT_CONSTANT)
VR(p) == 32 ? 23 : INFINITE
EMIT_INSTRUCTION
Register hr = Binary.getResult(P(p)).getRegister(); \\
Register lr = regpool.getSecondReg(hr); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, new RegisterOperand(hr, TypeReference.Int), Unary.getVal(PL(p)).copy())); \\
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(lr, TypeReference.Int), IC(0))));

r:      LONG_SHL(INT_2LONG(load64), INT_CONSTANT)
VR(p) == 32 ? 23 : INFINITE
EMIT_INSTRUCTION
Register hr = Binary.getResult(P(p)).getRegister(); \\
Register lr = regpool.getSecondReg(hr); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, new RegisterOperand(hr, TypeReference.Int), setSize(consumeMO(),4))); \\
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(lr, TypeReference.Int), IC(0))));

#####
# ADDR_2LONG
#####
r:	ADDR_2LONG(r)
33
EMIT_INSTRUCTION
INT_2LONG(P(p), Unary.getResult(P(p)), Unary.getVal(P(p)), false);

r:	ADDR_2LONG(load32)
38
EMIT_INSTRUCTION
INT_2LONG(P(p), Unary.getResult(P(p)), consumeMO(), false);

#####
# LONG_2INT
#####
r:	LONG_2INT(r)
13
EMIT_INSTRUCTION
Register lh = regpool.getSecondReg(R(Unary.getVal(P(p))).getRegister()); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), new RegisterOperand(lh, TypeReference.Int)));

stm:	INT_STORE(LONG_2INT(r), OTHER_OPERAND(riv,riv))
15
EMIT_INSTRUCTION
Register lh = regpool.getSecondReg(R(Unary.getVal(PL(p))).getRegister()); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), DW), new RegisterOperand(lh, TypeReference.Int)));

stm:	INT_ASTORE(LONG_2INT(r), OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
Register lh = regpool.getSecondReg(R(Unary.getVal(PL(p))).getRegister()); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), DW_S, DW), new RegisterOperand(lh, TypeReference.Int)));

r:	LONG_2INT(load64)
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), setSize(consumeMO(),4)));

#load32:      LONG_2INT(load64)
#0
#EMIT_INSTRUCTION
#pushMO(setSize(consumeMO(),4));
#
r:	LONG_2INT(LONG_USHR(r, INT_CONSTANT))
VLR(p) == 32 ? 13 : INFINITE
EMIT_INSTRUCTION
Register uh = Binary.getVal1(PL(p)).asRegister().getRegister(); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), new RegisterOperand(uh, TypeReference.Int)));

r:      LONG_2INT(LONG_SHR(r, INT_CONSTANT))
VLR(p) == 32 ? 13 : INFINITE
EMIT_INSTRUCTION
Register uh = Binary.getVal1(PL(p)).asRegister().getRegister(); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), new RegisterOperand(uh, TypeReference.Int)));

r:      LONG_2INT(LONG_USHR(load64, INT_CONSTANT))
VLR(p) == 32 ? 15 : INFINITE
EMIT_INSTRUCTION
MemoryOperand mo = consumeMO(); \\
mo.disp = mo.disp.plus(4); \\
mo = setSize(mo,4); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), mo));

r:      LONG_2INT(LONG_SHR(load64, INT_CONSTANT))
VLR(p) == 32 ? 15 : INFINITE
EMIT_INSTRUCTION
MemoryOperand mo = consumeMO(); \\
mo.disp = mo.disp.plus(4); \\
mo = setSize(mo,4); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), mo));

load32:      LONG_2INT(LONG_USHR(load64, INT_CONSTANT))
VLR(p) == 32 ? 0 : INFINITE
EMIT_INSTRUCTION
MemoryOperand mo = consumeMO(); \\
mo.disp = mo.disp.plus(4); \\
mo = setSize(mo,4); \\
pushMO(mo);

load32:      LONG_2INT(LONG_SHR(load64, INT_CONSTANT))
VLR(p) == 32 ? 0 : INFINITE
EMIT_INSTRUCTION
MemoryOperand mo = consumeMO(); \\
mo.disp = mo.disp.plus(4); \\
mo = setSize(mo,4); \\
pushMO(mo);

##################################
# Moves (register to register moves)
##################################
######
# INT_MOVE
######
r:	INT_MOVE(riv)
13
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Move.getResult(P(p)), Move.getVal(P(p))));

# INT_MOVEs can also 'preserve' nonterminals other than r
czr:	INT_MOVE(czr)
11
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Move.getResult(P(p)), Move.getVal(P(p))));

cz:	INT_MOVE(cz)
0
NOFLAGS
//nothing to do

szpr:	INT_MOVE(szpr)
11
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Move.getResult(P(p)), Move.getVal(P(p))));

szp:	INT_MOVE(szp)
0
NOFLAGS
//nothing to do

address1reg:	INT_MOVE(address1reg)
0
NOFLAGS
//nothing to do

address1scaledreg:	INT_MOVE(address1scaledreg)
0
NOFLAGS
//nothing to do

address:	INT_MOVE(address)
0
NOFLAGS
//nothing to do

sload8:	INT_MOVE(sload8)
0
NOFLAGS
//nothing to do

uload8:	INT_MOVE(uload8)
0
NOFLAGS
//nothing to do

load8:	INT_MOVE(load8)
0
NOFLAGS
//nothing to do

sload16: INT_MOVE(sload16)
0
NOFLAGS
//nothing to do

uload16: INT_MOVE(uload16)
0
NOFLAGS
//nothing to do

load16:	INT_MOVE(load16)
0
NOFLAGS
//nothing to do

load32:	INT_MOVE(load32)
0
NOFLAGS
// nothing to do

load64:	LONG_MOVE(load64)
0
NOFLAGS
// nothing to do

#####
# LONG_MOVE
#####
r:	LONG_MOVE(r)
23
EMIT_INSTRUCTION
Register res1 = Move.getResult(P(p)).getRegister();           \\
Register res2 = regpool.getSecondReg(res1);              \\
Register val1 = Move.getVal(P(p)).asRegister().getRegister(); \\
Register val2 = regpool.getSecondReg(val1);              \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, new RegisterOperand(res1, TypeReference.Int), \\
                     new RegisterOperand(val1, TypeReference.Int)));               \\
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(res2, TypeReference.Int), \\
                     new RegisterOperand(val2, TypeReference.Int))));

r:	LONG_MOVE(LONG_CONSTANT)
21
EMIT_INSTRUCTION
Register res1 = Move.getResult(P(p)).getRegister();   \\
Register res2 = regpool.getSecondReg(res1);      \\
LongConstantOperand val = LC(Move.getVal(P(p))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, new RegisterOperand(res1, TypeReference.Int), IC(val.upper32()))); \\
EMIT(CPOS(P(p),MIR_Move.create(IA32_MOV, new RegisterOperand(res2, TypeReference.Int), IC(val.lower32()))));

##################################
# Loads (memory to register moves)
##################################
#####
# GET_CURRENT_PROCESSOR (TODO: generalize)
#####
r:	GET_CURRENT_PROCESSOR
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Nullary.getResult(P(p)), new RegisterOperand(getESI(), TypeReference.Int)));

#####
# BYTE_LOAD
#####
r:	BYTE_LOAD(riv, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, Load.getResult(P(p)), MO_L(P(p), B)));

#####
# BYTE_ALOAD
#####
r:	BYTE_ALOAD(riv, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, ALoad.getResult(P(p)), MO_AL(P(p), B_S, B)));

#####
# UBYTE_LOAD
#####
r:	UBYTE_LOAD(riv, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__B, Load.getResult(P(p)), MO_L(P(p), B)));

#####
# UBYTE_ALOAD
#####
r:	UBYTE_ALOAD(riv, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__B, ALoad.getResult(P(p)), MO_AL(P(p), B_S, B)));

#####
# other load8 patterns
#####
# load8_16_32 & 0xff ===> uload8
uload8:	INT_AND(load8_16_32, INT_CONSTANT)
VR(p) == 0xff ? 0 : INFINITE
EMIT_INSTRUCTION
pushMO(setSize(consumeMO(),1));

r:	INT_AND(load8_16_32, INT_CONSTANT)
VR(p) == 0xff ? 15 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__B, Binary.getResult(P(p)), setSize(consumeMO(),1)));

# int2byte(load8_16_32)
r:	INT_2BYTE(load8_16_32)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, Unary.getResult(P(p)), setSize(consumeMO(),1)));

# load8 << 24 >>> 24 ===> uload8
r:	INT_USHR(INT_SHL(load8_16_32, INT_CONSTANT), INT_CONSTANT)
VR(p) == 24 && VLLR(p) == 24 ? 15 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__B, Binary.getResult(P(p)), setSize(consumeMO(),1)));

#####
# SHORT_LOAD
#####
r:	SHORT_LOAD(riv, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__W, Load.getResult(P(p)), MO_L(P(p), W)));

#####
# SHORT_ALOAD
#####
r:	SHORT_ALOAD(riv, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__W, ALoad.getResult(P(p)), MO_AL(P(p), W_S, W)));

#####
# USHORT_LOAD
#####
r:	USHORT_LOAD(riv, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, Load.getResult(P(p)), MO_L(P(p), W)));

#####
# USHORT_ALOAD
#####
r:	USHORT_ALOAD(riv, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, ALoad.getResult(P(p)), MO_AL(P(p), W_S, W)));

#####
# other load16 patterns
#####
# load16_32 & 0xffff ===> uload16
r:	INT_AND(load16_32, INT_CONSTANT)
VR(p) == 0xffff ? 15 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, Binary.getResult(P(p)), setSize(consumeMO(),2)));

# int2ushort(load16_32) ===> uload16
r:	INT_2USHORT(load16_32)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, Unary.getResult(P(p)), setSize(consumeMO(),2)));

# int2short(load16_32) ===> sload16
r:	INT_2USHORT(load16_32)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__W, Unary.getResult(P(p)), setSize(consumeMO(),2)));

# load16_32 << 16 >>> 16 ===> uload16 (_201_compress)
r:	INT_USHR(INT_SHL(load16_32, INT_CONSTANT), INT_CONSTANT)
VR(p) == 16 && VLR(p) == 16 ? 15 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, Binary.getResult(P(p)), setSize(consumeMO(),2)));

#####
# INT_LOAD
# A few more cases than for other load operators to handle pointer arithmetic introduced by use of magic
#####
r:	INT_LOAD(riv, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), MO_L(P(p), DW)));

r:	INT_LOAD(riv, address1scaledreg)
15
EMIT_INSTRUCTION
augmentAddress(Load.getAddress(P(p))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), \\
		     consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	INT_LOAD(address1scaledreg, riv)
15
EMIT_INSTRUCTION
augmentAddress(Load.getOffset(P(p))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), \\
	             consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	INT_LOAD(address1scaledreg, address1reg)
15
EMIT_INSTRUCTION
combineAddresses(); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), \\
	             consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	INT_LOAD(address1reg, address1scaledreg)
15
EMIT_INSTRUCTION
combineAddresses(); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), \\
	             consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	INT_LOAD(address, INT_CONSTANT)
15
EMIT_INSTRUCTION
augmentAddress(Load.getOffset(P(p))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), \\
	             consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));

#####
#INT_ALOAD
#####
r:	INT_ALOAD(riv, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, ALoad.getResult(P(p)), MO_AL(P(p), DW_S, DW)));

#####
# LONG_LOAD
#####
r:	LONG_LOAD(riv, riv)
30
EMIT_INSTRUCTION
RegisterOperand hres = Load.getResult(P(p)); \\
RegisterOperand lres = new RegisterOperand(regpool.getSecondReg(hres.getRegister()), TypeReference.Int); \\
hres.setType(TypeReference.Int); \\
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, hres, MO_L(P(p), DW, DW).copy()))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, lres, MO_L(P(p), DW)));

#####
# LONG_ALOAD
#####
r:	LONG_ALOAD(riv, riv)
30
EMIT_INSTRUCTION
RegisterOperand hres = ALoad.getResult(P(p)); \\
RegisterOperand lres = new RegisterOperand(regpool.getSecondReg(hres.getRegister()), TypeReference.Int); \\
hres.setType(TypeReference.Int); \\
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, hres, MO_AL(P(p), QW_S, DW, DW).copy()))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, lres, MO_AL(P(p), QW_S, DW)));

#####
# PREPARE_INT (just a normal load on IA32)
#####
r:	PREPARE_INT(riv, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \\
	             MO(Prepare.getAddress(P(p)), Prepare.getOffset(P(p)), DW, \\
	                Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE_INT(r, address1scaledreg)
15
EMIT_INSTRUCTION
augmentAddress(Prepare.getAddress(P(p))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \\
		     consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE_INT(address1scaledreg, r)
15
EMIT_INSTRUCTION
augmentAddress(Prepare.getOffset(P(p))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \\
	             consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE_INT(address1scaledreg, address1reg)
15
EMIT_INSTRUCTION
combineAddresses(); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \\
	             consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE_INT(address1reg, address1scaledreg)
15
EMIT_INSTRUCTION
combineAddresses(); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \\
	             consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE_INT(address, INT_CONSTANT)
15
EMIT_INSTRUCTION
augmentAddress(Prepare.getOffset(P(p))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \\
	             consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE_INT(INT_CONSTANT, address)
15
EMIT_INSTRUCTION
augmentAddress(Prepare.getAddress(P(p))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \\
	             consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

#####
# PREPARE_LONG (just a normal load on IA32)
#####
r:	PREPARE_LONG(riv, riv)
30
EMIT_INSTRUCTION
RegisterOperand hres = Prepare.getResult(P(p)); \\
hres.setType(TypeReference.Int); \\
MemoryOperand hmo = MO(Prepare.getAddress(P(p)), Prepare.getOffset(P(p)), DW, \\
                       Prepare.getLocation(P(p)), Prepare.getGuard(P(p)), DW); \\
RegisterOperand lres = new RegisterOperand(regpool.getSecondReg(hres.getRegister()), TypeReference.Int); \\
MemoryOperand lmo = MO(Prepare.getAddress(P(p)) != null ? Prepare.getAddress(P(p)).copy() : null, \\
                       Prepare.getOffset(P(p)) != null ? Prepare.getOffset(P(p)).copy() : null, \\
                       DW, \\
                       Prepare.getLocation(P(p)) != null ? (LocationOperand)Prepare.getLocation(P(p)).copy() : null, \\
                       Prepare.getGuard(P(p)) != null ? Prepare.getGuard(P(p)).copy() : null); \\
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, hres, hmo))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, lres, lmo));

##################################
# Stores (register to memory moves)
##################################
#####
# ATTEMPT_INT (atomic compare-exchange)
#####
r:	ATTEMPT_INT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
ATTEMPT(Attempt.getResult(P(p)), \\
              MO(Attempt.getAddress(P(p)), Attempt.getOffset(P(p)), DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \\
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT_INT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(P(p))); \\
ATTEMPT(Attempt.getResult(P(p)), \\
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \\
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(P(p))); \\
ATTEMPT(Attempt.getResult(P(p)), \\
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \\
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
combineAddresses(); \\
ATTEMPT(Attempt.getResult(P(p)), \\
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \\
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT_INT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
combineAddresses(); \\
ATTEMPT(Attempt.getResult(P(p)), \\
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \\
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT_INT(address, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(P(p))); \\
ATTEMPT(Attempt.getResult(P(p)), \\
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \\
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT_INT(INT_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(P(p))); \\
ATTEMPT(Attempt.getResult(P(p)), \\
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \\
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isZERO(VR(p), 54)
EMIT_INSTRUCTION
ATTEMPT_IFCMP(MO(Attempt.getAddress(PL(p)), Attempt.getOffset(PL(p)), DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \\
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \\
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isZERO(VR(p), 54)
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(PL(p))); \\
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \\
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \\
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isZERO(VR(p), 54)
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(PL(p))); \\
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \\
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \\
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isZERO(VR(p),54)
EMIT_INSTRUCTION
combineAddresses(); \\
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \\
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \\
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isZERO(VR(p),54)
EMIT_INSTRUCTION
combineAddresses(); \\
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \\
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \\
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(address, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isZERO(VR(p), 54)
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(PL(p))); \\
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \\
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \\
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(INT_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isZERO(VR(p),54)
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(PL(p))); \\
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \\
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \\
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv,riv))), INT_CONSTANT)
isONE(VR(p), 54)
EMIT_INSTRUCTION
ATTEMPT_IFCMP(MO(Attempt.getAddress(PL(p)), Attempt.getOffset(PL(p)), DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \\
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \\
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isONE(VR(p), 54)
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(PL(p))); \\
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \\
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \\
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isONE(VR(p), 54)
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(PL(p))); \\
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \\
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \\
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isONE(VR(p), 54)
EMIT_INSTRUCTION
combineAddresses(); \\
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \\
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \\
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isONE(VR(p), 54)
EMIT_INSTRUCTION
combineAddresses(); \\
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \\
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \\
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(address, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isONE(VR(p), 54)
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(PL(p))); \\
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \\
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \\
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(INT_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isONE(VR(p), 54)
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(PL(p))); \\
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \\
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \\
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

#####
# ATTEMPT_LONG (atomic compare-exchange)
#####
r:	ATTEMPT_LONG(riv, OTHER_OPERAND(riv, OTHER_OPERAND(rlv, rlv)))
67
EMIT_INSTRUCTION
ATTEMPT_LONG(Attempt.getResult(P(p)), \\
              MO(Attempt.getAddress(P(p)), Attempt.getOffset(P(p)), DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \\
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

#####
# BYTE_STORE
#####
stm:	BYTE_STORE(riv, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), B), Store.getValue(P(p))));

# Can avoid sign/zero extension when we are just doing a transfer of bits
# from one memory location to another.
stm:	BYTE_STORE(load8, OTHER_OPERAND(riv, riv))
25
EMIT_INSTRUCTION
Register tmp = regpool.getInteger(); \\
EMIT(CPOS(PL(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Int), consumeMO()))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), B), new RegisterOperand(tmp, TypeReference.Int)));

#####
# BYTE_ASTORE
#####
stm:	BYTE_ASTORE(riv, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), B_S, B), AStore.getValue(P(p))));

# Can avoid sign/zero extension when we are just doing a transfer of bits
# from one memory location to another.
stm:	BYTE_ASTORE(load8, OTHER_OPERAND(riv, riv))
25
EMIT_INSTRUCTION
Register tmp = regpool.getInteger(); \\
EMIT(CPOS(PL(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Int), consumeMO()))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), B_S, B), new RegisterOperand(tmp, TypeReference.Int)));

#####
# SHORT_STORE
#####
stm:	SHORT_STORE(riv, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), Store.getValue(P(p))));

# Can avoid sign/zero extension when we are just doing a transfer of bits
# from one memory location to another.
stm:	SHORT_STORE(load16, OTHER_OPERAND(riv, riv))
25
EMIT_INSTRUCTION
Register tmp = regpool.getInteger(); \\
EMIT(CPOS(PL(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Int), consumeMO()))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), new RegisterOperand(tmp, TypeReference.Int)));

#####
# SHORT_ASTORE
#####
stm:	SHORT_ASTORE(riv, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), AStore.getValue(P(p))));

# Can avoid sign/zero extension when we are just doing a transfer of bits
# from one memory location to another.
stm:	SHORT_ASTORE(load16, OTHER_OPERAND(riv, riv))
25
EMIT_INSTRUCTION
Register tmp = regpool.getInteger(); \\
EMIT(CPOS(PL(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Int), consumeMO()))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), new RegisterOperand(tmp, TypeReference.Int)));

#####
# INT_STORE
# A few more cases than for other store operators to handle pointer arithmetic introduced by use of magic
#####
stm:	INT_STORE(riv, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), DW), Store.getValue(P(p))));

stm:	INT_STORE(riv, OTHER_OPERAND(riv, address1scaledreg))
15
EMIT_INSTRUCTION
augmentAddress(Store.getAddress(P(p))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, \\
                     consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), \\
		     Store.getValue(P(p))));

stm:	INT_STORE(riv, OTHER_OPERAND(address1scaledreg, riv))
15
EMIT_INSTRUCTION
augmentAddress(Store.getOffset(P(p))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, \\
                     consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), \\
		     Store.getValue(P(p))));

stm:	INT_STORE(riv, OTHER_OPERAND(address1scaledreg, address1reg))
15
EMIT_INSTRUCTION
combineAddresses(); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV,  \\
                    consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), \\
                    Store.getValue(P(p))));

stm:	INT_STORE(riv, OTHER_OPERAND(address1reg, address1scaledreg))
15
EMIT_INSTRUCTION
combineAddresses(); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV,  \\
                    consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), \\
                    Store.getValue(P(p))));

stm:	INT_STORE(riv, OTHER_OPERAND(address, INT_CONSTANT))
15
EMIT_INSTRUCTION
augmentAddress(Store.getOffset(P(p))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV,  \\
	             consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), \\
		     Store.getValue(P(p))));

#####
# INT_ASTORE
#####
stm:	INT_ASTORE(riv, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p))));

#####
# LONG_STORE
#####
stm:	LONG_STORE(r, OTHER_OPERAND(riv, riv))
30
EMIT_INSTRUCTION
RegisterOperand hval = (RegisterOperand)Store.getValue(P(p)); \\
hval.setType(TypeReference.Int); \\
RegisterOperand lval = new RegisterOperand(regpool.getSecondReg(hval.getRegister()), TypeReference.Int); \\
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_S(P(p), DW, DW).copy(), hval))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), DW), lval));

stm:	LONG_STORE(LONG_CONSTANT, OTHER_OPERAND(riv, riv))
26
EMIT_INSTRUCTION
LongConstantOperand val = LC(Store.getValue(P(p))); \\
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_S(P(p), DW, DW).copy(), IC(val.upper32())))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), DW), IC(val.lower32())));

#####
# LONG_ASTORE
#####
stm:	LONG_ASTORE(r, OTHER_OPERAND(riv, riv))
30
EMIT_INSTRUCTION
RegisterOperand hval = (RegisterOperand)AStore.getValue(P(p)); \\
hval.setType(TypeReference.Int); \\
RegisterOperand lval = new RegisterOperand(regpool.getSecondReg(hval.getRegister()), TypeReference.Int); \\
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_AS(P(p), QW_S, DW, DW).copy(), hval))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), QW_S, DW), lval));

stm:	LONG_ASTORE(LONG_CONSTANT, OTHER_OPERAND(riv, riv))
26
EMIT_INSTRUCTION
LongConstantOperand val = LC(AStore.getValue(P(p))); \\
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_AS(P(p), QW_S, DW, DW).copy(), IC(val.upper32())))); \\
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), QW_S, DW), IC(val.lower32())));

##################################
# Control flow
##################################
#####
# INT_IFCMP
#####
stm:	INT_IFCMP(r,riv)
26
EMIT_INSTRUCTION
IFCMP(P(p), IfCmp.getGuardResult(P(p)), IfCmp.getVal1(P(p)), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(r, INT_CONSTANT)
VR(p) == 0 && CMP_TO_TEST(IfCmp.getCond(P(p))) ? 24:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \\
EMIT(CPOS(P(p), MIR_Test.create(IA32_TEST, IfCmp.getVal1(P(p)), IfCmp.getVal1(P(p)).copy()))); \\
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(IfCmp.getCond(P(p))), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

# Because uload is only used for booleans (0/1) we can get away
# with this for both signed and unsigned loads.
stm:	INT_IFCMP(load8, INT_CONSTANT)
FITS(IfCmp.getVal2(P(p)), 8, 28)
EMIT_INSTRUCTION
IFCMP(P(p), IfCmp.getGuardResult(P(p)), consumeMO(), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)));

# We only use uload8 for boolean values, so if the IR is well-typed,
# then r must contain either 0 or 1 and we can do this.
stm:	INT_IFCMP(uload8, r)
28
EMIT_INSTRUCTION
IFCMP(P(p), IfCmp.getGuardResult(P(p)), consumeMO(), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)));

# We only use uload8 for boolean values, so if the IR is well-typed,
# then r must contain either 0 or 1 and we can do this.
stm:	INT_IFCMP(r, uload8)
28
EMIT_INSTRUCTION
IFCMP(P(p), IfCmp.getGuardResult(P(p)), IfCmp.getVal1(P(p)), consumeMO(), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(sload16, INT_CONSTANT)
FITS(IfCmp.getVal2(P(p)), 8, 28)
EMIT_INSTRUCTION
IFCMP(P(p), IfCmp.getGuardResult(P(p)), consumeMO(), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(load32, riv)
28
EMIT_INSTRUCTION
IFCMP(P(p), IfCmp.getGuardResult(P(p)), consumeMO(), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(r, load32)
28
EMIT_INSTRUCTION
IFCMP(P(p), IfCmp.getGuardResult(P(p)), IfCmp.getVal1(P(p)), consumeMO(), IfCmp.getCond(P(p)));

# IfCmp(boolcmp, 0/1)
stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
(VR(p) == 0 && IfCmp.getCond(P(p)).isNOT_EQUAL()) || \
(VR(p) == 1 && IfCmp.getCond(P(p)).isEQUAL()) ? 13:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \\
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(consumeCOND()), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
(VR(p) == 0 && IfCmp.getCond(P(p)).isEQUAL()) || \
(VR(p) == 1 && IfCmp.getCond(P(p)).isNOT_EQUAL()) ? 13:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \\
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(consumeCOND().flipCode()), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

# IfCmp(cz, 0); condition code already set
stm:	INT_IFCMP(cz, INT_CONSTANT)
isZERO(VR(p), 11)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \\
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(IfCmp.getCond(P(p))), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

# IfCmp(szp, 0); condition code already set
stm:	INT_IFCMP(szp, INT_CONSTANT)
VR(p) == 0 && EQ_NE(IfCmp.getCond(P(p)))?11:INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \\
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(IfCmp.getCond(P(p))), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

# IfCmp(bittest, 0/1); condition code already set
stm:	INT_IFCMP(bittest, INT_CONSTANT)
(VR(p) == 0 || VR(p) == 1) && EQ_NE(IfCmp.getCond(P(p))) ? 11 : INFINITE
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getGuardResult(P(p)), new TrueGuardOperand()))); \\
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(BIT_TEST(VR(p), IfCmp.getCond(P(p)))), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

#####
# INT_IFCMP2: TODO interesting rules
#####
stm:	INT_IFCMP2(r,riv)
26
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp2.getGuardResult(P(p)), new TrueGuardOperand()))); \\
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, IfCmp2.getVal1(P(p)), IfCmp2.getVal2(P(p))))); \\
EMIT(MIR_CondBranch2.mutate(P(p), IA32_JCC2,                                  \\
	                    COND(IfCmp2.getCond1(P(p))), IfCmp2.getTarget1(P(p)),IfCmp2.getBranchProfile1(P(p)), \\
	                    COND(IfCmp2.getCond2(P(p))), IfCmp2.getTarget2(P(p)), IfCmp2.getBranchProfile2(P(p))));

stm:	INT_IFCMP2(load32,riv)
28
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp2.getGuardResult(P(p)), new TrueGuardOperand()))); \\
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), IfCmp2.getVal2(P(p))))); \\
EMIT(MIR_CondBranch2.mutate(P(p), IA32_JCC2,                                  \\
	                    COND(IfCmp2.getCond1(P(p))), IfCmp2.getTarget1(P(p)),IfCmp2.getBranchProfile1(P(p)), \\
	                    COND(IfCmp2.getCond2(P(p))), IfCmp2.getTarget2(P(p)), IfCmp2.getBranchProfile2(P(p))));

stm:	INT_IFCMP2(riv,load32)
28
EMIT_INSTRUCTION
EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp2.getGuardResult(P(p)), new TrueGuardOperand()))); \\
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), IfCmp2.getVal1(P(p))))); \\
EMIT(MIR_CondBranch2.mutate(P(p), IA32_JCC2,                                  \\
	                    COND(IfCmp2.getCond1(P(p)).flipOperands()), IfCmp2.getTarget1(P(p)),IfCmp2.getBranchProfile1(P(p)), \\
	                    COND(IfCmp2.getCond2(P(p)).flipOperands()), IfCmp2.getTarget2(P(p)), IfCmp2.getBranchProfile2(P(p))));

#####
# LONG_IFCMP
#####
stm:	LONG_IFCMP(rlv,rlv)
30
EMIT_INSTRUCTION
EMIT(P(p)); //  Leave for ComplexLIR2MIRExpansion

#####
# LONG_CMP
#####
r:	LONG_CMP(rlv,rlv)
10*13
EMIT_INSTRUCTION
LONG_CMP(P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

#####
# GOTO
#####
stm:	GOTO
11
EMIT_INSTRUCTION
EMIT(MIR_Branch.mutate(P(p), IA32_JMP, Goto.getTarget(P(p))));

#####
# PREFETCH
#####
stm:	PREFETCH(r)
11
EMIT_INSTRUCTION
EMIT(MIR_CacheOp.mutate(P(p), IA32_PREFETCHNTA, R(CacheOp.getRef(P(p)))));

#####
# PAUSE
#####
stm:	PAUSE
11
EMIT_INSTRUCTION
EMIT(MIR_Empty.mutate(P(p), IA32_PAUSE));

##################################
# Calling convention
##################################
#####
# RET
#####
stm:	RETURN(NULL)
13
EMIT_INSTRUCTION
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, null, null));

stm:	RETURN(INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, Return.getVal(P(p)), null));

stm:	RETURN(r)
13
EMIT_INSTRUCTION
RegisterOperand ret = R(Return.getVal(P(p)));            \\
RegisterOperand ret2 = null;	                            \\
if (ret.getType().isLongType()) {                                 \\
  ret.setType(TypeReference.Int);                           \\
  ret2 = new RegisterOperand(regpool.getSecondReg(ret.getRegister()), TypeReference.Int); \\
}                                                            \\
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, ret, ret2));

stm:	RETURN(LONG_CONSTANT)
11
EMIT_INSTRUCTION
LongConstantOperand val = LC(Return.getVal(P(p))); \\
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, IC(val.upper32()), IC(val.lower32())));

#####
# CALL
#####
r:	CALL(r, any)
13
EMIT_INSTRUCTION
CALL(P(p), Call.getAddress(P(p)));

# a recursive call that has been optimized to a branch to entry block
r:	CALL(BRANCH_TARGET, any)
13
EMIT_INSTRUCTION
CALL(P(p), Call.getAddress(P(p)));

r:	CALL(INT_LOAD(riv, riv), any)
11
EMIT_INSTRUCTION
CALL(P(p), MO_L(PL(p), DW));

r:	CALL(INT_CONSTANT, any)
23
EMIT_INSTRUCTION
RegisterOperand temp = regpool.makeTemp(TypeReference.Int); \\
EMIT(MIR_Move.create(IA32_MOV, temp, Call.getAddress(P(p)))); \\
CALL(P(p), temp.copyRO());

r:	SYSCALL(r, any)
13
EMIT_INSTRUCTION
SYSCALL(P(p), Call.getAddress(P(p)));

r:	SYSCALL(INT_LOAD(riv, riv), any)
11
EMIT_INSTRUCTION
SYSCALL(P(p), MO_L(PL(p), DW));

r:	SYSCALL(INT_CONSTANT, any)
23
EMIT_INSTRUCTION
RegisterOperand temp = regpool.makeTemp(TypeReference.Int); \\
EMIT(MIR_Move.create(IA32_MOV, temp, Call.getAddress(P(p)))); \\
SYSCALL(P(p), temp.copyRO());

#####
# RDTSC
#####
r:      GET_TIME_BASE
15
EMIT_INSTRUCTION
GET_TIME_BASE(P(p), Nullary.getResult(P(p)));

########
# osr instruction
########
stm:	YIELDPOINT_OSR(any, any)
10
EMIT_INSTRUCTION
OSR(burs, P(p));

########
# bit test instructions
########
# (base >>>/>> offset) & 1
# int_and
#    int_ushr              L
#       register           LL <-- base
#       int_and            LR <-- offset (if int constant)
#          register        LRL <-- offset
#          INT_CONSTANT 31 LRR
#    INT_CONSTANT 1        R
bittest:	INT_AND(INT_USHR(r,INT_AND(r,INT_CONSTANT)),INT_CONSTANT)
(VR(p) == 1) && (VLRR(p) == 31) ? 13:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(P(p), IA32_BT, Binary.getVal1(PL(p)).copy(), Binary.getVal1(PLR(p)).copy()));

bittest:	INT_AND(INT_USHR(load32,INT_AND(r,INT_CONSTANT)),INT_CONSTANT)
VR(p) == 1 ? 31:INFINITE
EMIT_INSTRUCTION
Register tmp = regpool.getInteger(); \\
if (VM.VerifyAssertions) VM._assert((VLRR(p) & 0x7FFFFFFF) <= 31); \\
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Int), Binary.getVal1(PLR(p))))); \\
EMIT(CPOS(P(p), MIR_BinaryAcc.create(IA32_AND, new RegisterOperand(tmp, TypeReference.Int), IC(VLRR(p))))); \\
EMIT(MIR_Test.mutate(P(p), IA32_BT, consumeMO(), new RegisterOperand(tmp, TypeReference.Int)));

bittest:	INT_AND(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
(VR(p) == 1) && (VLR(p) <= 31) ? 13:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(P(p), IA32_BT, Binary.getVal1(PL(p)).copy(), IC(VLR(p))));

bittest:	INT_AND(INT_SHR(r,INT_AND(r,INT_CONSTANT)),INT_CONSTANT)
(VR(p) == 1) && (VLRR(p) == 31) ? 13:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(P(p), IA32_BT, Binary.getVal1(PL(p)).copy(), Binary.getVal1(PLR(p)).copy()));

bittest:	INT_AND(INT_SHR(load32,INT_AND(r,INT_CONSTANT)),INT_CONSTANT)
VR(p) == 1 ? 31:INFINITE
EMIT_INSTRUCTION
Register tmp = regpool.getInteger(); \\
if (VM.VerifyAssertions) VM._assert((VLRR(p) & 0x7FFFFFFF) <= 31); \\
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Int), Binary.getVal1(PLR(p))))); \\
EMIT(CPOS(P(p), MIR_BinaryAcc.create(IA32_AND, new RegisterOperand(tmp, TypeReference.Int), IC(VLRR(p))))); \\
EMIT(MIR_Test.mutate(P(p), IA32_BT, consumeMO(), new RegisterOperand(tmp, TypeReference.Int)));

bittest:	INT_AND(INT_SHR(r,INT_CONSTANT),INT_CONSTANT)
(VR(p) == 1) && (VLR(p) <= 31) ? 13:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(P(p), IA32_BT, Binary.getVal1(PL(p)).copy(), IC(VLR(p))));

# int_and
#    int_shl               L
#       INT_CONSTANT 1     LL
#       int_and            LR
#          register        LRL <-- offset
#          INT_CONSTANT 31 LRR
#    register              R <-- base
bittest:	INT_AND(INT_SHL(INT_CONSTANT,INT_AND(riv,INT_CONSTANT)),r)
(VLL(p) == 1) && (VLRR(p) == 31)? 13:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(P(p), IA32_BT, Binary.getVal2(P(p)), Binary.getVal1(PLR(p)).copy()));

bittest:	INT_AND(INT_SHL(INT_CONSTANT,INT_AND(r, INT_CONSTANT)),load32)
VLL(p) == 1 ? 31:INFINITE
EMIT_INSTRUCTION
Register tmp = regpool.getInteger(); \\
if (VM.VerifyAssertions) VM._assert((VLRR(p) & 0x7FFFFFFF) <= 31); \\
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Int), Binary.getVal1(PLR(p))))); \\
EMIT(CPOS(P(p), MIR_BinaryAcc.create(IA32_AND, new RegisterOperand(tmp, TypeReference.Int), IC(VLRR(p))))); \\
EMIT(MIR_Test.mutate(P(p), IA32_BT, consumeMO(), new RegisterOperand(tmp, TypeReference.Int)));

# int_and
#    register              L <-- base
#    int_shl               R
#       INT_CONSTANT 1     RL
#       int_and            RR
#          register        RRL <-- offset
#          INT_CONSTANT 31 RRR
bittest:	INT_AND(r,INT_SHL(INT_CONSTANT,INT_AND(r, INT_CONSTANT)))
(VRL(p) == 1) && (VRRR(p) == 31) ? 13:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(P(p), IA32_BT, Binary.getVal1(P(p)), Binary.getVal1(PRR(p)).copy()));

bittest:	INT_AND(load32,INT_SHL(INT_CONSTANT,INT_AND(r, INT_CONSTANT)))
VRL(p) == 1 ? 31:INFINITE
EMIT_INSTRUCTION
Register tmp = regpool.getInteger(); \\
if (VM.VerifyAssertions) VM._assert((VRRR(p) & 0x7FFFFFFF) <= 31); \\
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Int), Binary.getVal1(PRR(p))))); \\
EMIT(CPOS(P(p), MIR_BinaryAcc.create(IA32_AND, new RegisterOperand(tmp, TypeReference.Int), IC(VRRR(p))))); \\
EMIT(MIR_Test.mutate(P(p), IA32_BT, consumeMO(), new RegisterOperand(tmp, TypeReference.Int)));
