/*
 * (C) Copyright IBM Corp. 2001
 */
//$Id$
package com.ibm.JikesRVM;

import com.ibm.JikesRVM.memoryManagers.VM_CollectorThread;

/**
 * A place to put code common to all runtime compilers.
 * This includes instrumentation code to get equivalent data for
 * each of the runtime compilers.
 * <p>
 * We collect the following data for each compiler
 * <ol>
 * <li>
 *   total number of methods complied by the compiler
 * <li>
 *   total compilation time in nanoseconds as computed by calls to VM_Time.now()
 *   This is accumulated as a double to avoid rounding errors. 
 * <li>
 *   total number of bytes of bytecodes compiled by the compiler
 *   (under the assumption that there is no padding in the bytecode
 *   array and thus VM_Method.getBytecodes().length is the number bytes
 *   of bytecode for a method)
 * <li>
 *   total number of machine code insructions generated by the compiler
 *   (under the assumption that there is no (excessive) padding in the
 *   machine code array and thus VM_Method.getInstructions().length
 *   is a close enough approximation of the number of machinecodes generated)
 * </ol>
 *   Note that even if 3. & 4. are inflated due to padding, the numbers will 
 *   still be an accurate measure of the space costs of the compile-only 
 *   approach.
 *
 * @author Dave Grove
 * @author Mike Hind
 */
public class VM_RuntimeCompilerInfrastructure
  implements VM_Constants, VM_Callbacks.ExitMonitor
{

  // Use these to encode the compiler for record()
  public static final byte BASELINE_COMPILER = 0;
  public static final byte OPT_COMPILER      = 2;

  // Data accumulators
  private static final String name[]         = {"Base\t","\t","Opt\t"};   // Output names
  private static int total_methods[]         = {0,0,0};                        // (1)
  private static double total_time[]         = {0.0,0.0,0.0};                  // (2)
  private static int total_bcodeLen[]        = {0,0,0};                        // (3)
  private static int total_mcodeLen[]        = {0,0,0};                        // (4)

  /**
   * To be called when the VM is about to exit.
   * @param value the exit value
   */
  public void notifyExit(int value) {
    report(true);
  }

  /**
   * This method records the time and sizes (bytecode and machine code) for
   * a compilation
   * @param compiler the compiler used
   * @param method the resulting VM_Method
   * @param compiledMethod the resulting compiled method
   * @param timer the timer hold the time used for compilation
   */
  public static void record(byte compiler, VM_Method method, 
			    VM_CompiledMethod compiledMethod, Timer timer) {

    // we don't count native methods.  They don't have any bytecodes
    if (timer.validTiming() && !method.isNative()) {
      total_methods[compiler]++;
      total_bcodeLen[compiler] += method.getBytecodes().length;
      total_mcodeLen[compiler] += compiledMethod.getInstructions().length;
      if (VM.MeasureCompilation) {
	total_time[compiler] += timer.elapsedTime();
      }
    }
  }

  /**
   * This method produces a summary report of compilation activities
   * @param explain Explains the metrics used in the report
   */
  public static void report (boolean explain) { 
    VM.sysWrite("\n\t\tCompilation Subsystem Report\n");
    VM.sysWrite("Comp\t#Meths\tTime\tbcb/ms\tmcb/bcb\tMCKB\tBCKB\n");
    for (int i=0; i<3; i++) {
      if (total_methods[i]>0) {
	VM.sysWrite(name[i]);
	// Number of methods
	VM.sysWrite(total_methods[i], false);
	VM.sysWrite("\t");
	// Compilation time
	VM.sysWrite(VM_Time.toMilliSecs(total_time[i]), false);
	VM.sysWrite("\t");
	// Bytecode bytes per millisecond
	printRatio(total_bcodeLen[i], VM_Time.toMilliSecs(total_time[i]), 2);
	VM.sysWrite("\t");
	// Ratio of machine code bytes to bytecode bytes
	printRatio(total_mcodeLen[i] << LG_INSTRUCTION_WIDTH, total_bcodeLen[i], 2);
	VM.sysWrite("\t");
	// Generated machine code Kbytes
	printRatio(total_mcodeLen[i] << LG_INSTRUCTION_WIDTH, 1024, 1);
	VM.sysWrite("\t");
	// Compiled bytecode Kbytes
	printRatio(total_bcodeLen[i], 1024, 1); 
	VM.sysWrite("\n");
      }
    }
    if (explain) {
      // Generate an explanation of the metrics reported
      VM.sysWrite("\t\t\tExplanation of Metrics\n");
      VM.sysWrite("#Meths:\t\tTotal number of methods compiled by the compiler\n");
      VM.sysWrite("Time:\t\tTotal compilation time in milliseconds\n");
      VM.sysWrite("bcb/ms:\t\tNumber of bytecode bytes complied per millisecond\n");
      VM.sysWrite("mcb/bcb:\tRatio of machine code bytes to bytecode bytes\n");
      VM.sysWrite("MCKB:\t\tTotal number of machine code bytes generated in kilobytes\n");
      VM.sysWrite("BCKB:\t\tTotal number of bytecode bytes compiled in kilobytes\n");
    }
    VM_RuntimeCompiler.detailedCompilationReport(explain);
  }
   

  /**
   * Prints the ratio of first two parameters using the number of digits
   * specified by the 3rd parameter.

   * NOTE: Printing a double or float requires a fair amount of work and
   * furthermore may result in class loading and/or allocation.  We could
   * call Math.round, but that might also cause classloading, so instead
   * we do something fairly simple, but slow and ugly that more or less
   * works in most cases.
   *
   * TODO: Move this somewhere else (general profiling utility file).
   *
   * @param numerator the numerator
   * @param denominator the denominator
   * @param places the number of decimal places to be used in the result
   */
  public static void printRatio(int numerator, int denominator, int places) {
    if (denominator == 0) return;
    int divide = 10;
    for (int i = 0; i<places; i++)
      divide = divide*10;
    float value = ((float)numerator)/((float)denominator) + (5.0f/(float)divide); //Add in fudge to get rounding
    int approx = (int)value;
    VM.sysWrite(approx, false);
    if (places > 0) VM.sysWrite(".");
    for (int i = 0; i<places; i++) {
      value = (value - (float)approx)*10.0f;
      approx = (int)(value);
      VM.sysWrite(approx, false);
    }
  }

  /**
   * Prints the percentage of total time taken by the first parameter.
   * @param phaseTime the time take by a phase
   * @param time the total time
   */
  public static void printPercentage(double phaseTime, double time) {
    printRatio(VM_Time.toMilliSecs(phaseTime)*100,
	       VM_Time.toMilliSecs(time), 2);
  }


  /**
   * This method will compile the passed method using our "quicker" compiler.
   * Currently, this is the baseline compiler.
   * @param method the method to compile
   */
  public static VM_CompiledMethod baselineCompile(VM_Method method) {
    Timer timer = null; // Only used if VM.MeasureCompilation 
    if (VM.MeasureCompilation) {
      timer = new Timer();
      timer.start();
    }

    VM_CompiledMethod cm = VM_BaselineCompiler.compile(method);

    if (VM.MeasureCompilation) {
      timer.finish();
      record(BASELINE_COMPILER, method, cm, timer);
    }
    
    return cm;
   }

  /**
   * A class to record compilation times
   */
  public static class Timer {
    private static final boolean EXCLUDE_GC = true; 
    private double startTime; 
    private double endTime;   
    private int gc_epoch;     
    private long startTick;   
    private long endTick;     

    public double elapsedTime() { return endTime - startTime; }
    public long elapsedTicks() { return endTick - startTick; }
    public boolean validTiming() { return !EXCLUDE_GC || gc_epoch != -1; }
    
    Timer() { }
    
    public void start() {
      if (EXCLUDE_GC) {
	gc_epoch = VM_CollectorThread.collectionCount;
      }
      if (VM.MeasureCompilation) {
	startTime = VM_Time.now();
      }
    }

    public void finish() {
      if (EXCLUDE_GC && gc_epoch != VM_CollectorThread.collectionCount) {
	VM.sysWrite("Not timing compilation due to intervening GC");
	gc_epoch = -1; // 
      } else {
	if (VM.MeasureCompilation) {
	  endTime = VM_Time.now();
	}
      }
    }
  }
}
