#
# (C) Copyright IBM Corp. 2001,2002,2004
#
#//$Id$
#
# @author Dave Grove
# @author Mauricio J. Serrano
#
# BURS rules that are common to PPC32 and PPC64
#
# The format of PRODUCTION is 'non-terminal:	rule'
PRODUCTION
# COST is a Java expression that evaluates to an integer.
# The following conventions are more or less followed:
# TODO: define conventions for PPC rules!
COST
# For definition of FLAGS bits see BURS_TreeNode.java
FLAGS
# Code
TEMPLATE

##################################
# Definitions of non-terminals and
# mapping of leaves into non-terminals
##################################
# the non-terminal r can be mapped to non-terminal stm at no cost
stm:	r
0
NOFLAGS
// No code emitted

# the terminal REGISTER maps to non-terminal r
r:	REGISTER
0
NOFLAGS
// No code emitted

# the nonterminal czr can map to non-terminal r
# czr indicates that (1) a register result is produced
# and (2) as a side-effect of producing that result the condition registers
# are set as if the result was compared to 0.
r:	czr
0
NOFLAGS
// No code emitted

# A non-terminal that can be anything
any:	NULL
0
NOFLAGS
// No code emitted

any:	r
0
NOFLAGS
// No code emitted

any:	INT_CONSTANT
0
NOFLAGS
// No code emitted

any:	LONG_CONSTANT
0
NOFLAGS
// No code emitted

any:	OTHER_OPERAND(any, any)
0
NOFLAGS
// No code emitted

##################################
# A few operators are passed through unchanged
##################################
stm:	RESOLVE
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	IG_PATCH_POINT
10
EMIT_INSTRUCTION
EMIT(InlineGuard.mutate(P(p), IG_PATCH_POINT, null, null, null, InlineGuard.getTarget(P(p)), InlineGuard.getBranchProfile(P(p))));

stm:	UNINT_BEGIN
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	UNINT_END
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	YIELDPOINT_PROLOGUE
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	YIELDPOINT_EPILOGUE
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	YIELDPOINT_BACKEDGE
10
EMIT_INSTRUCTION
EMIT(P(p));

##################################
# One operator is passed through nearly unchanged
##################################
stm:	LOWTABLESWITCH(r)
10
EMIT_INSTRUCTION
LOWTABLESWITCH(P(p));

##################################
# NOPs can simply be dropped
##################################
stm:	NOP
10
NOFLAGS
// drop on floor

#####
# GUARD_MOVE
#####
# note: ignoring guard registers, thus no uses
r:	GUARD_MOVE
11
EMIT_INSTRUCTION
EMIT(P(p));

#####
# GUARD_COMBINE
#####
# note: ignoring guard registers, thus no uses
r:	GUARD_COMBINE
11
EMIT_INSTRUCTION
EMIT(P(p));

#####
# NULL_CHECK
#####
stm:	NULL_CHECK(r)
11
EMIT_INSTRUCTION
EMIT(P(p)); 

#####
# IR_PROLOGUE:
#####
stm:	IR_PROLOGUE
11
EMIT_INSTRUCTION
PROLOGUE(P(p));

###########
# Rules for exceptions
###########
r:	GET_CAUGHT_EXCEPTION
11
EMIT_INSTRUCTION
GET_EXCEPTION_OBJECT(P(p));

stm:	SET_CAUGHT_EXCEPTION(r)
11
EMIT_INSTRUCTION
SET_EXCEPTION_OBJECT(P(p));

##################################
# Cache instructions
##################################
#####
# WRITE_FLOOR
#####
stm:	WRITE_FLOOR
11
EMIT_INSTRUCTION
EMIT(MIR_Empty.mutate(P(p), PPC_SYNC));

#####
# READ_CEILING
#####
stm:	READ_CEILING
11
EMIT_INSTRUCTION
EMIT(MIR_Empty.mutate(P(p), PPC_ISYNC));

#####
# DCBF
#####
stm:	DCBF(r)
11
EMIT_INSTRUCTION
EMIT(MIR_CacheOp.mutate(P(p), PPC_DCBF, R(0), R(CacheOp.getRef(P(p)))));

#####
# DCBST
#####
stm:	DCBST(r)
11
EMIT_INSTRUCTION
EMIT(MIR_CacheOp.mutate(P(p), PPC_DCBST, R(0), R(CacheOp.getRef(P(p)))));

#####
# ICBI
#####
stm:	ICBI(r)
11
EMIT_INSTRUCTION
EMIT(MIR_CacheOp.mutate(P(p), PPC_ICBI, R(0), R(CacheOp.getRef(P(p)))));

##################################
# Trap operations
##################################
#####
# TRAP
#####
stm:	TRAP
10
EMIT_INSTRUCTION
TRAP(P(p));

#####
# TRAP_IF
#####
stm:	TRAP_IF(r,r)
10
EMIT_INSTRUCTION
TRAP_IF(P(p));

stm:	TRAP_IF(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
TRAP_IF_IMM(P(p));

##################################
# Basic Boolean ALU operations 
##################################
#####
# BOOLEAN_NOT
#####
r:	BOOLEAN_NOT(r)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_XORI, Unary.getResult(P(p)), R(Unary.getVal(P(p))), IC(1)));

#####
# BOOLEAN_CMP
#####
r:	BOOLEAN_CMP(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
BOOLEAN_CMP_IMM(BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)), R(BooleanCmp.getVal1(P(p))), IC(BooleanCmp.getVal2(P(p))));

r:	BOOLEAN_CMP(r,r)
10
EMIT_INSTRUCTION
BOOLEAN_CMP(BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)), R(BooleanCmp.getVal1(P(p))), R(BooleanCmp.getVal2(P(p))));

boolcmp:	BOOLEAN_CMP(r,INT_CONSTANT)
0
EMIT_INSTRUCTION
PUSH_BOOLCMP(BooleanCmp.getCond(P(p)), BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p)));

boolcmp:	BOOLEAN_CMP(r,r)
0
EMIT_INSTRUCTION
PUSH_BOOLCMP(BooleanCmp.getCond(P(p)), BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p)));

## chaining of boolcmps
boolcmp:	BOOLEAN_CMP(boolcmp, INT_CONSTANT)
VR(p) == 1 && BooleanCmp.getCond(P(p)).isEQUAL()?0:INFINITE
NOFLAGS
// use already pushed boolean cmp

boolcmp:	BOOLEAN_CMP(boolcmp, INT_CONSTANT)
VR(p) == 1 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()?0:INFINITE
EMIT_INSTRUCTION
FLIP_BOOLCMP(); // invert condition

boolcmp:	BOOLEAN_CMP(boolcmp, INT_CONSTANT)
VR(p) == 0 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()?0:INFINITE
NOFLAGS
// use already pushed boolean cmp

boolcmp: BOOLEAN_CMP(boolcmp, INT_CONSTANT)
VR(p) == 0 && BooleanCmp.getCond(P(p)).isEQUAL()?0:INFINITE
EMIT_INSTRUCTION
FLIP_BOOLCMP(); // invert condition

## materialize boolcmp into a register
r:	BOOLEAN_CMP(boolcmp, INT_CONSTANT)
VR(p) == 1 && BooleanCmp.getCond(P(p)).isEQUAL()?10:INFINITE
EMIT_INSTRUCTION
EMIT_PUSHED_BOOLCMP(BooleanCmp.getResult(P(p)));

r:	BOOLEAN_CMP(boolcmp, INT_CONSTANT)
VR(p) == 1 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()?10:INFINITE
EMIT_INSTRUCTION
FLIP_BOOLCMP(); EMIT_PUSHED_BOOLCMP(BooleanCmp.getResult(P(p)));

r:	BOOLEAN_CMP(boolcmp, INT_CONSTANT)
VR(p) == 0 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()?10:INFINITE
EMIT_INSTRUCTION
EMIT_PUSHED_BOOLCMP(BooleanCmp.getResult(P(p)));

r: BOOLEAN_CMP(boolcmp, INT_CONSTANT)
VR(p) == 0 && BooleanCmp.getCond(P(p)).isEQUAL()?10:INFINITE
EMIT_INSTRUCTION
FLIP_BOOLCMP(); EMIT_PUSHED_BOOLCMP(BooleanCmp.getResult(P(p)));

##################################
# Basic Integer ALU operations 
##################################
#####
# INT_ADD
#####
r:	INT_ADD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ADDI, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_ADD(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ADD, Binary.getResult(P(p)),                 \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_ADD(r,INT_MOVE(INT_CONSTANT))
20
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand val = Move.getVal(PR(p));                                      \
   EMIT(MIR_Binary.create(PPC_ADDI, Move.getResult(PR(p)),                    \
                          R(Binary.getVal1(P(p))), CAL16(val)));              \
   EMIT(MIR_Binary.mutate(P(p), PPC_ADDIS, Binary.getResult(P(p)),            \
                          Move.getResult(PR(p)), CAU16(val)));                \
}

r:	INT_ADD(r,INT_MOVE(INT_CONSTANT))
U16(Move.getVal(PR(p)))?10:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ADDIS, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), CAU16(Move.getVal(PR(p)))));

#####
# INT_SUB
#####
r:	INT_SUB(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SUBF, Binary.getResult(P(p)),                \
                       R(Binary.getVal2(P(p))), Binary.getVal1(P(p))));

r:	INT_SUB(INT_MOVE(INT_CONSTANT),r)
SI16(Move.getVal(PL(p)))?11:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SUBFIC, Binary.getResult(P(p)),              \
                       R(Binary.getVal2(P(p))), Move.getVal(PL(p))));

#####
# INT_MUL
#####
r:	INT_MUL(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_MULLI, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_MUL(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_MULLW, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# INT_DIV
#####
r:	INT_DIV(r,r)
20
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_DIVW, GuardedBinary.getResult(P(p)),  \
                       R(GuardedBinary.getVal1(P(p))), GuardedBinary.getVal2(P(p))));

r:	INT_DIV(r,INT_MOVE(INT_CONSTANT))
20
EMIT_INSTRUCTION
INT_DIV_IMM(P(p), GuardedBinary.getResult(P(p)), R(GuardedBinary.getVal1(P(p))), \
                  Move.getResult(PR(p)), IC(Move.getVal(PR(p))));

#####
# INT_REM
#####
r:	INT_REM(r,r)
20
EMIT_INSTRUCTION
INT_REM(P(p), GuardedBinary.getResult(P(p)), R(GuardedBinary.getVal1(P(p))), R(GuardedBinary.getVal2(P(p))));

r:	INT_REM(r,INT_MOVE(INT_CONSTANT))
20
EMIT_INSTRUCTION
INT_REM_IMM(P(p), GuardedBinary.getResult(P(p)), R(GuardedBinary.getVal1(P(p))), \
	          Move.getResult(PR(p)), IC(Move.getVal(PR(p))));

#####
# INT_NEG
#####
r:	INT_NEG(r)
11
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_NEG, Unary.getResult(P(p)), Unary.getVal(P(p))));

#####
# INT_SHL
#####
r:	INT_SHL(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SLWI, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_SHL(r,r)
20
EMIT_INSTRUCTION
INT_SHIFT(P(p),PPC_SLW);

r:	INT_SHL(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
10
EMIT_INSTRUCTION
USHR_SHL(P(p), Binary.getResult(P(p)), R(Binary.getVal1(PL(p))), IC(Binary.getVal2(PL(p))),      \
               IC(Binary.getVal2(P(p))));

#####
# INT_SHR
#####
r:	INT_SHR(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SRAWI, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_SHR(r,r)
20
EMIT_INSTRUCTION
INT_SHIFT(P(p),PPC_SRAW);

r:	INT_SHR(INT_AND(r,INT_CONSTANT),INT_CONSTANT)
POSITIVE_MASK(Binary.getVal2(PL(p)))?10:INFINITE
EMIT_INSTRUCTION
AND_USHR(P(p), Binary.getResult(P(p)),                      \
                     R(Binary.getVal1(PL(p))), IC(Binary.getVal2(PL(p))),      \
                     IC(Binary.getVal2(P(p))));

r:	INT_SHR(INT_AND(r,INT_MOVE(INT_CONSTANT)),INT_CONSTANT)
POSITIVE_MASK(Move.getVal(PLR(p)))?10:INFINITE
EMIT_INSTRUCTION
AND_USHR(P(p), Binary.getResult(P(p)),                      \
                     R(Binary.getVal1(PL(p))), IC(Move.getVal(PLR(p))),        \
                     IC(Binary.getVal2(P(p))));

#####
# INT_USHR
#####
r:	INT_USHR(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SRWI, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_USHR(r,r)
20
EMIT_INSTRUCTION
INT_SHIFT(P(p),PPC_SRW);

r:	INT_USHR(INT_AND(r,INT_CONSTANT),INT_CONSTANT)
POSITIVE_MASK(Binary.getVal2(PL(p)))?10:INFINITE
EMIT_INSTRUCTION
AND_USHR(P(p), Binary.getResult(P(p)), R(Binary.getVal1(PL(p))), \
	       IC(Binary.getVal2(PL(p))), IC(Binary.getVal2(P(p))));

r:	INT_USHR(INT_AND(r,INT_MOVE(INT_CONSTANT)),INT_CONSTANT)
POSITIVE_MASK(Move.getVal(PLR(p)))?10:INFINITE
EMIT_INSTRUCTION
AND_USHR(P(p), Binary.getResult(P(p)), R(Binary.getVal1(PL(p))), \
               IC(Move.getVal(PLR(p))), IC(Binary.getVal2(P(p))));

r:	INT_USHR(INT_SHL(r,INT_CONSTANT),INT_CONSTANT)
10
EMIT_INSTRUCTION
SHL_USHR(P(p), Binary.getResult(P(p)), R(Binary.getVal1(PL(p))), \
	       IC(Binary.getVal2(PL(p))), IC(Binary.getVal2(P(p))));

#####
# INT_AND
#####
r:	INT_AND(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_AND, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

czr:	INT_AND(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ANDIr, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), IC(Binary.getVal2(P(p)))));

r:	INT_AND(r,INT_CONSTANT)
MASK(Binary.getVal2(P(p)))?10:INFINITE
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand mask = Binary.getVal2(P(p));                                   \
   EMIT(MIR_RotateAndMask.create(PPC_RLWINM, Binary.getResult(P(p)),          \
                                 R(Binary.getVal1(P(p))), IC(0),               \
                                 MB(mask), ME(mask)));                        \
}

czr:	INT_AND(r,INT_MOVE(INT_CONSTANT))
U16(Move.getVal(PR(p)))?11:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ANDISr, Binary.getResult(P(p)),              \
                       R(Binary.getVal1(P(p))), IC(OPT_Bits.PPCMaskUpper16(VRL(p)))));

r:	INT_AND(r,INT_MOVE(INT_CONSTANT))
MASK(Move.getVal(PR(p)))?10:INFINITE
EMIT_INSTRUCTION
AND_MASK(P(p), Binary.getResult(P(p)), R(Binary.getVal1(P(p))), IC(Move.getVal(PR(p))));

r:	INT_AND(INT_NOT(r),INT_NOT(r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_NOR, Binary.getResult(P(p)),                 \
                       R(Unary.getVal(PL(p))), Unary.getVal(PR(p))));

r:	INT_AND(r,INT_NOT(r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ANDC, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Unary.getVal(PR(p))));

r:	INT_AND(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
POSITIVE_MASK(Binary.getVal2(P(p)))?10:INFINITE
EMIT_INSTRUCTION
USHR_AND(P(p), Binary.getResult(P(p)), R(Binary.getVal1(PL(p))), \
               IC(Binary.getVal2(P(p))), IC(Binary.getVal2(PL(p))));

r:	INT_AND(INT_USHR(r,INT_CONSTANT),INT_MOVE(INT_CONSTANT))
POSITIVE_MASK(Move.getVal(PR(p)))?10:INFINITE
EMIT_INSTRUCTION
USHR_AND(P(p), Binary.getResult(P(p)), R(Binary.getVal1(PL(p))), \
               IC(Move.getVal(PR(p))), IC(Binary.getVal2(PL(p))));

#####
# INT_OR
#####
r:	INT_OR(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_OR, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_OR(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ORI, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_OR(r,INT_MOVE(INT_CONSTANT))
U16(Move.getVal(PR(p)))?10:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ORIS, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), SRI(Move.getVal(PR(p)), 16)));

r:	INT_OR(r,INT_MOVE(INT_CONSTANT))
20
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand c = Move.getVal(PR(p));                                        \
   EMIT(MIR_Binary.create(PPC_ORI, Binary.getResult(P(p)),                    \
                          R(Binary.getVal1(P(p))), ANDI(c, 0xffff)));         \
   EMIT(MIR_Binary.mutate(P(p), PPC_ORIS, Binary.getResult(P(p)),             \
                          Binary.getResult(P(p)), SRI(c, 16)));               \
}

r:	INT_OR(INT_NOT(r),INT_NOT(r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_NAND, Binary.getResult(P(p)), R(Unary.getVal(PL(p))), Unary.getVal(PR(p))));

r:	INT_OR(r,INT_NOT(r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ORC, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Unary.getVal(PR(p))));

#####
# INT_XOR
#####
r:	INT_XOR(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_XOR, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_XOR(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_XORI, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_XOR(r,INT_MOVE(INT_CONSTANT))
U16(Move.getVal(PR(p)))?10:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_XORIS, Binary.getResult(P(p)), \
                       R(Binary.getVal1(P(p))), SRI(Move.getVal(PR(p)), 16)));

#####
# INT_NOT
#####
r:	INT_NOT(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_NOR, Unary.getResult(P(p)), R(Unary.getVal(P(p))), Unary.getVal(P(p))));

r:	INT_NOT(INT_OR(r,r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_NOR, Unary.getResult(P(p)), R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p))));

r:	INT_NOT(INT_AND(r,r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_NAND, Unary.getResult(P(p)), R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p))));

r:	INT_NOT(INT_XOR(r,r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_EQV, Unary.getResult(P(p)), R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p))));

##################################
# Basic Floating-Point ALU operations 
##################################
#####
# FLOAT_ADD 
#####
r:	FLOAT_ADD(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FADDS, Binary.getResult(P(p)), \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# DOUBLE_ADD 
#####
r:	DOUBLE_ADD(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FADD, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# FLOAT_MUL 
#####
r:	FLOAT_MUL(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FMULS, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# DOUBLE_MUL 
#####
r:	DOUBLE_MUL(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FMUL, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# FLOAT_SUB 
#####
r:	FLOAT_SUB(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FSUBS, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# DOUBLE_SUB 
#####
r:	DOUBLE_SUB(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FSUB, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# FLOAT_DIV 
#####
r:	FLOAT_DIV(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FDIVS, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# DOUBLE_DIV 
#####
r:	DOUBLE_DIV(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FDIV, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#####
# FLOAT_NEG 
#####
r:	FLOAT_NEG(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_FNEG, Unary.getResult(P(p)), Unary.getVal(P(p))));

#####
# DOUBLE_NEG 
#####
r:	DOUBLE_NEG(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_FNEG, Unary.getResult(P(p)), Unary.getVal(P(p))));

#####
# FMA and friends
#####
r: 	FLOAT_ADD(FLOAT_MUL(r, r), r)
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMADDS, Binary.getResult(P(p)),             \
		        R(Binary.getVal1(PL(p))), R(Binary.getVal2(PL(p))),   \
		        R(Binary.getVal2(P(p)))));

r: 	DOUBLE_ADD(DOUBLE_MUL(r, r), r)
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMADD, Binary.getResult(P(p)),              \
		        R(Binary.getVal1(PL(p))), R(Binary.getVal2(PL(p))),   \
		        R(Binary.getVal2(P(p)))));

r:	FLOAT_ADD(r, FLOAT_MUL(r,r))
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMADDS, Binary.getResult(P(p)),             \
			R(Binary.getVal1(PR(p))), R(Binary.getVal2(PR(p))),   \
			R(Binary.getVal1(P(p)))));

r:	DOUBLE_ADD(r, DOUBLE_MUL(r,r))
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMADD, Binary.getResult(P(p)),              \
			R(Binary.getVal1(PR(p))), R(Binary.getVal2(PR(p))),   \
			R(Binary.getVal1(P(p)))));

r: 	FLOAT_SUB(FLOAT_MUL(r, r), r)
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMSUBS, Binary.getResult(P(p)),             \
		        R(Binary.getVal1(PL(p))), R(Binary.getVal2(PL(p))),   \
		        R(Binary.getVal2(P(p)))));

r: 	DOUBLE_SUB(DOUBLE_MUL(r, r), r)
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMSUB, Binary.getResult(P(p)),              \
		        R(Binary.getVal1(PL(p))), R(Binary.getVal2(PL(p))),   \
		        R(Binary.getVal2(P(p)))));

r: 	FLOAT_NEG(FLOAT_ADD(FLOAT_MUL(r, r), r))
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMADDS, Binary.getResult(P(p)),            \
		        R(Binary.getVal1(PLL(p))), R(Binary.getVal2(PLL(p))), \
		        R(Binary.getVal2(PL(p)))));

r: 	DOUBLE_NEG(DOUBLE_ADD(DOUBLE_MUL(r, r), r))
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMADD, Binary.getResult(P(p)),             \
		        R(Binary.getVal1(PLL(p))), R(Binary.getVal2(PLL(p))), \
		        R(Binary.getVal2(PL(p)))));

r:	FLOAT_NEG(FLOAT_ADD(r, FLOAT_MUL(r,r)))
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMADDS, Binary.getResult(P(p)),            \
			R(Binary.getVal1(PLR(p))), R(Binary.getVal2(PLR(p))), \
			R(Binary.getVal1(PL(p)))));

r:	DOUBLE_NEG(DOUBLE_ADD(r, DOUBLE_MUL(r,r)))
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMADD, Binary.getResult(P(p)),            \
			R(Binary.getVal1(PLR(p))), R(Binary.getVal2(PLR(p))),\
			R(Binary.getVal1(PL(p)))));

r: 	FLOAT_NEG(FLOAT_SUB(FLOAT_MUL(r, r), r))
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMSUBS, Binary.getResult(P(p)),            \
		        R(Binary.getVal1(PLL(p))), R(Binary.getVal2(PLL(p))), \
		        R(Binary.getVal2(PL(p)))));

r: 	DOUBLE_NEG(DOUBLE_SUB(DOUBLE_MUL(r, r), r))
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMSUB, Binary.getResult(P(p)),             \
		        R(Binary.getVal1(PLL(p))), R(Binary.getVal2(PLL(p))), \
		        R(Binary.getVal2(PL(p)))));

##################################
# Basic Conversion operations
##################################
#####
# INT_2BYTE
#####
r:	INT_2BYTE(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_EXTSB, Unary.getResult(P(p)), Unary.getVal(P(p))));

#####
# INT_2USHORT
#####
r:	INT_2USHORT(r)
20
EMIT_INSTRUCTION
EMIT(MIR_RotateAndMask.create(PPC_RLWINM, Unary.getResult(P(p)), null,        \
                              R(Unary.getVal(P(p))), IC(0), IC(16), IC(31)));

#####
# INT_2SHORT
#####
r:	INT_2SHORT(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_EXTSH, Unary.getResult(P(p)), Unary.getVal(P(p))));

#####
# INT_2FLOAT
#####
r:	INT_2FLOAT(r)
10
EMIT_INSTRUCTION
INT_2DOUBLE(P(p), Unary.getResult(P(p)), R(Unary.getVal(P(p))));

#####
# INT_2DOUBLE
#####
r:	INT_2DOUBLE(r)
10
EMIT_INSTRUCTION
INT_2DOUBLE(P(p), Unary.getResult(P(p)), R(Unary.getVal(P(p))));

#####
# FLOAT_2INT
#####
r:	FLOAT_2INT(r)
10
EMIT_INSTRUCTION
EMIT(P(p));  // Leave for OPT_ComplexLIR2MIRExpansion

#####
# FLOAT_2DOUBLE
#####
r:	FLOAT_2DOUBLE(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), PPC_FMR, Unary.getResult(P(p)), R(Unary.getVal(P(p)))));

#####
# DOUBLE_2INT
#####
r:	DOUBLE_2INT(r)
10
EMIT_INSTRUCTION
EMIT(P(p));  // Leave for OPT_ComplexLIR2MIRExpansionLeave

#####
# DOUBLE_2FLOAT
#####
r:	DOUBLE_2FLOAT(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_FRSP, Unary.getResult(P(p)), Unary.getVal(P(p))));

#####
# FLOAT_AS_INT_BITS
#####
r:	FLOAT_AS_INT_BITS(r)
20
EMIT_INSTRUCTION
FPR2GPR_32(P(p));

#####
# INT_BITS_AS_FLOAT
#####
r:	INT_BITS_AS_FLOAT(r)
20
EMIT_INSTRUCTION
GPR2FPR_32(P(p));

##################################
# Moves (register to register moves)
##################################
######
# INT_MOVE
######
r:	INT_MOVE(r)
11
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), PPC_MOVE, Move.getResult(P(p)), R(Move.getVal(P(p)))));

r:	INT_MOVE(INT_CONSTANT)
SI16(Move.getVal(P(p)))?11:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_LDI, Move.getResult(P(p)), Move.getVal(P(p))));

r:	INT_MOVE(INT_CONSTANT)
U16(Move.getVal(P(p)))?11:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_LDIS, Move.getResult(P(p)), SRI(Move.getVal(P(p)), 16)));

r:	INT_MOVE(INT_CONSTANT)
22
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand one = Move.getVal(P(p));                                       \
   EMIT(MIR_Unary.create(PPC_LDIS, Move.getResult(P(p)), CAU16(one)));        \
   EMIT(MIR_Binary.mutate(P(p), PPC_ADDI, Move.getResult(P(p)),               \
                          Move.getResult(P(p)), CAL16(one)));                 \
}

######
# FLOAT_MOVE
######
r:	FLOAT_MOVE(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), PPC_FMR, Move.getResult(P(p)), R(Move.getVal(P(p)))));

######
# DOUBLE_MOVE
######
r:	DOUBLE_MOVE(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), PPC_FMR, Move.getResult(P(p)), R(Move.getVal(P(p)))));

##################################
# Loads (memory to register moves)
##################################
#####
# BYTE_LOAD
#####
r:	BYTE_LOAD(r,INT_CONSTANT)
22
EMIT_INSTRUCTION
BYTE_LOAD(P(p), PPC_LBZ, Load.getResult(P(p)), R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
          Load.getLocation(P(p)), Load.getGuard(P(p)));

r:	BYTE_LOAD(r,r)
22
EMIT_INSTRUCTION
BYTE_LOAD(P(p), PPC_LBZX, Load.getResult(P(p)), R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
          Load.getLocation(P(p)), Load.getGuard(P(p)));

r:	INT_AND(BYTE_LOAD(r,r),INT_CONSTANT)
VR(p) == 0xff ? 10 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(PL(p), PPC_LBZX, Binary.getResult(P(p)), R(Load.getAddress(PL(p))), \
                     Load.getOffset(PL(p)), Load.getLocation(PL(p)), \
                     Load.getGuard(PL(p))));

r:	INT_AND(BYTE_LOAD(r,INT_CONSTANT),INT_CONSTANT)
VR(p) == 0xff ? 10 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(PL(p), PPC_LBZ, Binary.getResult(P(p)), R(Load.getAddress(PL(p))), \
                     Load.getOffset(PL(p)), Load.getLocation(PL(p)), \
                     Load.getGuard(PL(p))));

#####
# UBYTE_LOAD
#####
r:	UBYTE_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LBZ, Load.getResult(P(p)),            \
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
                     Load.getLocation(P(p)), Load.getGuard(P(p))));

r:	UBYTE_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LBZX, Load.getResult(P(p)),           \
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
	             Load.getLocation(P(p)), Load.getGuard(P(p))));

#####
# SHORT_LOAD
#####
r:	SHORT_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LHA, Load.getResult(P(p)),            \
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
   	             Load.getLocation(P(p)), Load.getGuard(P(p))));

r:	SHORT_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LHAX, Load.getResult(P(p)),           \
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
  	             Load.getLocation(P(p)), Load.getGuard(P(p))));

#####
# USHORT_LOAD
#####
r:	USHORT_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LHZ, Load.getResult(P(p)),            \
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
	             Load.getLocation(P(p)), Load.getGuard(P(p))));

r:	USHORT_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LHZX, Load.getResult(P(p)),           \
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
		     Load.getLocation(P(p)), Load.getGuard(P(p))));

#####
# FLOAT_LOAD
#####
r:	FLOAT_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LFS, Load.getResult(P(p)),            \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p))));

r:      FLOAT_LOAD(r,INT_MOVE(INT_CONSTANT))
22
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand val = Move.getVal(PR(p));                                      \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PR(p)),                   \
                          R(Load.getAddress(P(p))), CAU16(val)));             \
   EMIT(MIR_Load.mutate(P(p), PPC_LFS, Load.getResult(P(p)),         \
                                 Move.getResult(PR(p)), CAL16(val),           \
			         Load.getLocation(P(p)),                      \
                                 Load.getGuard(P(p))));                      \
}

r:	FLOAT_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LFSX, Load.getResult(P(p)),           \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p))));

#####
# DOUBLE_LOAD
#####
r:	DOUBLE_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LFD, Load.getResult(P(p)),            \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p))));

r:      DOUBLE_LOAD(r,INT_MOVE(INT_CONSTANT))
22
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand val = Move.getVal(PR(p));                                      \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PR(p)),                   \
                          R(Load.getAddress(P(p))), CAU16(val)));             \
   EMIT(MIR_Load.mutate(P(p), PPC_LFD, Load.getResult(P(p)),         \
                                 Move.getResult(PR(p)), CAL16(val),           \
				 Load.getLocation(P(p)),                      \
                                 Load.getGuard(P(p))));                      \
}

r:	DOUBLE_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LFDX, Load.getResult(P(p)),           \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p))));

#####
# BYTE_STORE
#####
stm:	BYTE_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STB, R(Store.getValue(P(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
                               Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	BYTE_STORE(r,OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STBX, R(Store.getValue(P(p))),       \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STB, R(Unary.getVal(PL(p))),         \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STBX, R(Unary.getVal(PL(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

#####
# SHORT_STORE
#####
stm:	SHORT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STH, R(Store.getValue(P(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	SHORT_STORE(r,OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STHX, R(Store.getValue(P(p))),       \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	SHORT_STORE(INT_2SHORT(r),OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STH, R(Unary.getVal(PL(p))),         \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	SHORT_STORE(INT_2SHORT(r),OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STHX, R(Unary.getVal(PL(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	SHORT_STORE(INT_2USHORT(r),OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STH, R(Unary.getVal(PL(p))),         \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	SHORT_STORE(INT_2USHORT(r),OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STHX, R(Unary.getVal(PL(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

#####
# INT_STORE
# A few more cases than for other store operators to handle pointer arithmetic introduced by use of magic
#####
stm:	INT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STW, R(Store.getValue(P(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	INT_STORE(r,OTHER_OPERAND(r,INT_MOVE(INT_CONSTANT)))
22
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand val = Move.getVal(PRR(p));                                     \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PRR(p)),                  \
                          R(Store.getAddress(P(p))), CAU16(val)));            \
   EMIT(MIR_Store.mutate(P(p), PPC_STW, R(Store.getValue(P(p))),     \
                                  Move.getResult(PRR(p)), CAL16(val),         \
				  Store.getLocation(P(p)),                    \
                                  Store.getGuard(P(p))));                    \
}

stm:	INT_STORE(r,OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STWX, R(Store.getValue(P(p))),       \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:	INT_STORE(r,OTHER_OPERAND(INT_ADD(r,INT_CONSTANT),INT_CONSTANT))
SI16(VRR(p)+VRLR(p))?14:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STW, R(Store.getValue(P(p))),        \
                               R(Binary.getVal1(PRL(p))),                     \
                               IC(VRR(p) + VRLR(p)), \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

#####
# FLOAT_STORE
#####
stm:	FLOAT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STFS, R(Store.getValue(P(p))),       \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:      FLOAT_STORE(r,OTHER_OPERAND(r,INT_MOVE(INT_CONSTANT)))
22
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand val = Move.getVal(PRR(p));                                     \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PRR(p)),                  \
                          R(Store.getAddress(P(p))), CAU16(val)));            \
   EMIT(MIR_Store.mutate(P(p), PPC_STFS, R(Store.getValue(P(p))),    \
                                  Move.getResult(PRR(p)), CAL16(val),         \
				  Store.getLocation(P(p)),                    \
                                  Store.getGuard(P(p))));                    \
}

stm:	FLOAT_STORE(r,OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STFSX, R(Store.getValue(P(p))),      \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

#####
# DOUBLE_STORE
#####
stm:	DOUBLE_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STFD, R(Store.getValue(P(p))),       \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

stm:      DOUBLE_STORE(r,OTHER_OPERAND(r,INT_MOVE(INT_CONSTANT)))
22
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand val = Move.getVal(PRR(p));                                     \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PRR(p)),                  \
                          R(Store.getAddress(P(p))), CAU16(val)));            \
   EMIT(MIR_Store.mutate(P(p), PPC_STFD, R(Store.getValue(P(p))),    \
                                  Move.getResult(PRR(p)), CAL16(val),         \
				  Store.getLocation(P(p)),                    \
                                  Store.getGuard(P(p))));                    \
}

stm:	DOUBLE_STORE(r,OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(MIR_Store.mutate(P(p), PPC_STFDX, R(Store.getValue(P(p))),      \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p))));

##################################
# Control flow
##################################
#####
# INT_IFCMP
#####
stm:	INT_IFCMP(r,r)
20
EMIT_INSTRUCTION
CMP(P(p), R(IfCmp.getVal1(P(p))), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)), false);

stm:	INT_IFCMP(r,INT_CONSTANT)
20
EMIT_INSTRUCTION
CMP(P(p), R(IfCmp.getVal1(P(p))), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)), true);

stm:	INT_IFCMP(INT_NEG(r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_NEGr, Unary.getResult(PL(p)),           \
                     Unary.getVal(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_NOT(r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_XORr, Unary.getResult(PL(p)),           \
                     R(Unary.getVal(PL(p))), Unary.getVal(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_2BYTE(r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_EXTSBr, Unary.getResult(PL(p)),         \
                     Unary.getVal(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_2SHORT(r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_EXTSHr, Unary.getResult(PL(p)),         \
                     Unary.getVal(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_ADD(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_ADDr, Binary.getResult(PL(p)),          \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_AND(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_ANDr, Binary.getResult(PL(p)),          \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_OR(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_ORr, Binary.getResult(PL(p)),           \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_XOR(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_XORr, Binary.getResult(PL(p)),          \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_USHR(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_SRWr, Binary.getResult(PL(p)),          \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_SHL(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_SLWr, Binary.getResult(PL(p)),          \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_SHR(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_SRAWr, Binary.getResult(PL(p)),         \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_AND(r,INT_MOVE(INT_CONSTANT)),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))&&U16(Move.getVal(PLR(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_ANDISr, Binary.getResult(PL(p)),        \
                     R(Binary.getVal1(PL(p))),                               \
                     SRI(Move.getVal(PLR(p)), 16), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_AND(r,INT_MOVE(INT_CONSTANT)),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))&&MASK(Move.getVal(PLR(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO_AND_MASK(P(p), Binary.getResult(PL(p)),           \
                              R(Binary.getVal1(PL(p))),                      \
                              IC(Move.getVal(PLR(p))), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_ADD(r,INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_ADDICr, Binary.getResult(PL(p)),        \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_AND(r,INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_ANDIr, Binary.getResult(PL(p)),         \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_SRWIr, Binary.getResult(PL(p)),         \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_SHL(r,INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_SLWIr, Binary.getResult(PL(p)),         \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_SHR(r,INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_SRAWIr, Binary.getResult(PL(p)),        \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_AND(r,INT_NOT(r)),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_ANDCr, Binary.getResult(PL(p)),         \
                     R(Binary.getVal1(PL(p))), Unary.getVal(PLR(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(INT_OR(r,INT_NOT(r)),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(P(p), PPC_ORCr, Binary.getResult(PL(p)),          \
                     R(Binary.getVal1(PL(p))), Unary.getVal(PLR(p)), IfCmp.getCond(P(p)));

# IfCmp(boolcmp, 0/1)
stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
VR(p) == 0 && IfCmp.getCond(P(p)).isNOT_EQUAL()?20:INFINITE
EMIT_INSTRUCTION
EMIT_BOOLCMP_BRANCH(IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
VR(p) == 0 && IfCmp.getCond(P(p)).isEQUAL()?20:INFINITE
EMIT_INSTRUCTION
FLIP_BOOLCMP(); EMIT_BOOLCMP_BRANCH(IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
VR(p) == 1 && IfCmp.getCond(P(p)).isEQUAL()?20:INFINITE
EMIT_INSTRUCTION
EMIT_BOOLCMP_BRANCH(IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
VR(p) == 1 && (IfCmp.getCond(P(p)).isNOT_EQUAL())?26:INFINITE
EMIT_INSTRUCTION
FLIP_BOOLCMP(); EMIT_BOOLCMP_BRANCH(IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

#####
# INT_IFCMP2: TODO interesting rules
#####
stm:	INT_IFCMP2(r,r)
20
EMIT_INSTRUCTION
CMP2(P(p), R(IfCmp2.getVal1(P(p))), IfCmp2.getVal2(P(p)), IfCmp2.getCond1(P(p)), IfCmp2.getCond2(P(p)), false);

stm:	INT_IFCMP2(r,INT_CONSTANT)
20
EMIT_INSTRUCTION
CMP2(P(p), R(IfCmp2.getVal1(P(p))), IfCmp2.getVal2(P(p)), IfCmp2.getCond1(P(p)), IfCmp2.getCond2(P(p)), true);

#####
# FLOAT_IFCMPL
#####
stm:	FLOAT_IFCMPL(r,r)
20
EMIT_INSTRUCTION
DOUBLE_IFCMP(P(p), FLOAT_CMPL, R(IfCmp.getVal1(P(p))), IfCmp.getVal2(P(p)));

#####
# FLOAT_IFCMPG
#####
stm:	FLOAT_IFCMPG(r,r)
20
EMIT_INSTRUCTION
DOUBLE_IFCMP(P(p), FLOAT_CMPG, R(IfCmp.getVal1(P(p))), IfCmp.getVal2(P(p)));

#####
# DOUBLE_IFCMPL
#####
stm:	DOUBLE_IFCMPL(r,r)
20
EMIT_INSTRUCTION
DOUBLE_IFCMP(P(p), DOUBLE_CMPL, R(IfCmp.getVal1(P(p))), IfCmp.getVal2(P(p)));

#####
# DOUBLE_IFCMPG
#####
stm:	DOUBLE_IFCMPG(r,r)
20
EMIT_INSTRUCTION
DOUBLE_IFCMP(P(p), DOUBLE_CMPG, R(IfCmp.getVal1(P(p))), IfCmp.getVal2(P(p)));

#####
# FLOAT_CMPL
#####
stm:	FLOAT_CMPL(r,r)
40
EMIT_INSTRUCTION
EMIT (P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

#####
# FLOAT_CMPG
#####
stm:	FLOAT_CMPG(r,r)
40
EMIT_INSTRUCTION
EMIT (P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

#####
# DOUBLE_CMPL
#####
stm:	DOUBLE_CMPL(r,r)
40
EMIT_INSTRUCTION
EMIT (P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

#####
# DOUBLE_CMPG
#####
stm:	DOUBLE_CMPG(r,r)
40
EMIT_INSTRUCTION
EMIT (P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

#####
# GOTO
#####
stm:	GOTO
11
EMIT_INSTRUCTION
EMIT(MIR_Branch.mutate(P(p), PPC_B, Goto.getTarget(P(p))));

##################################
# Calling convention
##################################
#####
# RETURN
#####
stm:	RETURN(NULL)
10
EMIT_INSTRUCTION
RETURN(P(p), null);

stm:	RETURN(r)
10
EMIT_INSTRUCTION
RETURN(P(p), Return.getVal(P(p)));

#####
# CALL
#####
r:	CALL(r,any)
10
EMIT_INSTRUCTION
CALL(P(p));

# a recursive call that has been optimized to a branch to entry block
r:	CALL(BRANCH_TARGET,any)
10
EMIT_INSTRUCTION
CALL(P(p));

r:	SYSCALL(r,any)
10
EMIT_INSTRUCTION
SYSCALL(P(p));

###########
# Rules for special registers
###########
r:	GET_TIME_BASE
11
EMIT_INSTRUCTION
EMIT(P(p));  // Leave for OPT_ComplexLIR2MIRExpansion

##########
# DUMMY RULES WHILE SWITCHING OVER TO NEW STYLE
# TODO: DELTE THESE!
##########
r:	OTHER_OPERAND(r,r)
0
NOFLAGS
// do nothing

###############
# on stack replace 
###############
r:  YIELDPOINT_OSR(any, any)
11
EMIT_INSTRUCTION
OSR(burs, P(p));

#####
# PREPARE
#####
r:      PREPARE_INT(r, r)
11
EMIT_INSTRUCTION
EMIT(MIR_Load.mutate(P(p), PPC_LWARX, Prepare.getResult(P(p)),   \
                              R(Prepare.getAddress(P(p))), Prepare.getOffset(P(p)),           \
                              Prepare.getLocation(P(p)),                  \
                              Prepare.getGuard(P(p))));

#####
# ATTEMPT (atomic compare-exchange)
#####
r:      ATTEMPT_INT(r, r)
11
EMIT_INSTRUCTION
EMIT(P(p));  // Leave for OPT_ComplexLIR2MIRExpansion

#####
# INT_2ADDR
#####
r:	INT_2ADDRSigExt(r)
10
EMIT_INSTRUCTION
INT_2ADDRSigExt(P(p), Unary.getResult(P(p)), R(Unary.getVal(P(p)))); 

r:	INT_2ADDRZerExt(r)
10
EMIT_INSTRUCTION
INT_2ADDRZerExt(P(p), Unary.getResult(P(p)), R(Unary.getVal(P(p)))); 

#####
# ADDR_2INT
#####
r:	ADDR_2INT(r)
10
EMIT_INSTRUCTION
ADDR_2INT(P(p), Unary.getResult(P(p)), R(Unary.getVal(P(p))));

