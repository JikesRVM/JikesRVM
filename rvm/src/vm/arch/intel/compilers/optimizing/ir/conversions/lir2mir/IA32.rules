#
# (C) Copyright IBM Corp. 2001,2002
#
#//$Id$
#
# @author Dave Grove
# @author Ian Rogers
#
# BURS rules for IA32
#
# The format of PRODUCTION is 'non-terminal:	rule'
PRODUCTION
# COST is a Java expression that evaluates to an integer.
# The following conventions are more or less followed:
#   Each instruction generated has a base cost of 10
#   A basic (r,r) or (r,riv) costs 3 more
#   A (m,riv) costs 7
#   A (r,m) costs 5
#   Better basic opcodes (inc instead of add 1) decrease cost by 2
COST
# For definition of FLAGS bits see BURS_TreeNode.java
FLAGS
# Code
TEMPLATE

##################################
# Definitions of non-terminals and
# mapping of leaves into non-terminals
##################################
# the non-terminal r can be mapped to non-terminal stm at no cost
stm:	r
0
NOFLAGS
// No code emitted

# the terminal REGISTER maps to non-terminal r
r:	REGISTER
0
NOFLAGS
// No code emitted

# the nonterminal czr can map to non-terminal r
# czr indicates that (1) a register result is produced
# and (2) as a side-effect of producing that result the condition registers
# are set as if the result was compared to 0.
r:	czr
0
NOFLAGS
// No code emitted

# the nonterminal czr can map to non-terminal cz
# cz indicates that the condition registers like a compare instruction
cz:	czr
0
NOFLAGS
// No code emitted

# the nonterminal szpr can map to non-terminal r
# szpr indicates that (1) a register result is produced
# and (2) that the condition registers SF, ZF, PF are set based on the result.
# are set as if the result was compared to 0.
r:	szpr
0
NOFLAGS
// No code emitted

# the nonterminal szpr can map to non-terminal szp
# szp indicates that the condition registers SF, ZF, PF are set.
szp:	szpr
0
NOFLAGS
// No code emitted

# the non-terminal riv is either an r or an INT_CONSTANT
riv:	r
0
NOFLAGS
// No code emitted

riv:	INT_CONSTANT
0
NOFLAGS
// No code emitted

# the non-terminal rlv is either an r or an lv
rlv:	r
0
NOFLAGS
// No code emitted

rlv:	LONG_CONSTANT
0
NOFLAGS
// No code emitted

# A non-terminal that can be anything
any:	NULL
0
NOFLAGS
// No code emitted

any:	riv
0
NOFLAGS
// No code emitted

any:	ADDRESS_CONSTANT
0
NOFLAGS
// No code emitted

any:	LONG_CONSTANT
0
NOFLAGS
// No code emitted

any:	OTHER_OPERAND(any, any)
0
NOFLAGS
// No code emitted

##################################
# Allow Load/Store instructions to be recognized as potential memory operands 
##################################
sload8:	BYTE_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), B));

sload8:	BYTE_ALOAD(r, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), B_S, B));

uload8:	UBYTE_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), B));

uload8:	UBYTE_ALOAD(r, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), B_S, B));

load8:	sload8
0
NOFLAGS
// no code emitted

load8:	uload8
0
NOFLAGS
// no code emitted

sload16: SHORT_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), W));

sload16: SHORT_ALOAD(r, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), W_S, W));

uload16: USHORT_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), W));

uload16: USHORT_ALOAD(r, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), W_S, W));

load16:	sload16
0
NOFLAGS
// no code emitted

load16:	uload16
0
NOFLAGS
// no code emitted

load32:	INT_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), DW));

load32:	INT_ALOAD(r, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), DW_S, DW));

load64:	LONG_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), QW));

load64:	LONG_ALOAD(r, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), QW_S, QW));

fpload:	FLOAT_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), DW));

fpload:	FLOAT_ALOAD(r, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), DW_S, DW));

fpload:	DOUBLE_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), QW));

fpload:	DOUBLE_ALOAD(r, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), QW_S, QW));

fpload:	MATERIALIZE_FP_CONSTANT(riv)
0
EMIT_INSTRUCTION
pushMO(MO_MC(P(p)));

##################################
# Various integer computations for pointer arithmetic
##################################
address1scaledreg:	address1reg
0
NOFLAGS
//nothing to do

address:	address1scaledreg
0
NOFLAGS
//nothing to do

address1reg:	INT_ADD_ACC(r, INT_CONSTANT)
0
EMIT_INSTRUCTION
pushAddress(BinaryAcc.getResult(P(p)), null, B_S, Offset.fromIntSignExtend(VR(p)));

address:	INT_ADD_ACC(r, r)
0
EMIT_INSTRUCTION
pushAddress(BinaryAcc.getResult(P(p)), R(BinaryAcc.getValue(P(p))), B_S, Offset.zero());

address1reg:	INT_ADD_ACC(address1reg, INT_CONSTANT)
0
EMIT_INSTRUCTION
augmentAddress(BinaryAcc.getValue(P(p)));

address1scaledreg:	INT_SHL_ACC(r, INT_CONSTANT)
LEA_SHIFT(BinaryAcc.getValue(P(p)), 0)
EMIT_INSTRUCTION
pushAddress(null, BinaryAcc.getResult(P(p)), LEA_SHIFT(BinaryAcc.getValue(P(p))), Offset.zero());

address1scaledreg:	INT_SHL_ACC(INT_MOVE(r), INT_CONSTANT)
LEA_SHIFT(BinaryAcc.getValue(P(p)), 0)
EMIT_INSTRUCTION
pushAddress(null, R(Move.getVal(PL(p))), LEA_SHIFT(BinaryAcc.getValue(P(p))), Offset.zero());

address1scaledreg:	INT_ADD_ACC(address1scaledreg, INT_CONSTANT)
0
EMIT_INSTRUCTION
augmentAddress(BinaryAcc.getValue(P(p)));

address:	INT_ADD_ACC(r, address1scaledreg)
0
EMIT_INSTRUCTION
augmentAddress(BinaryAcc.getResult(P(p)));

address:	INT_ADD_ACC(address1scaledreg, r)
0
EMIT_INSTRUCTION
augmentAddress(BinaryAcc.getValue(P(p)));

address:	INT_ADD_ACC(address1scaledreg, INT_CONSTANT)
0
EMIT_INSTRUCTION
augmentAddress(BinaryAcc.getValue(P(p)));

address:	INT_ADD_ACC(address1scaledreg, address1reg)
0
EMIT_INSTRUCTION
combineAddresses();

address:	INT_ADD_ACC(address1reg, address1scaledreg)
0
EMIT_INSTRUCTION
combineAddresses();

##################################
# Some cases where an LEA can replace several add/shift operations
##################################
r:	INT_ADD_ACC(address1scaledreg, r)
20
EMIT_INSTRUCTION
augmentAddress(BinaryAcc.getValue(P(p))); \
EMIT(MIR_Lea.mutate(P(p), IA32_LEA, BinaryAcc.getResult(P(p)), consumeAddress(DW, null, null)));

r:	INT_ADD_ACC(r, address1scaledreg)
20
EMIT_INSTRUCTION
augmentAddress(BinaryAcc.getResult(P(p))); \
EMIT(MIR_Lea.mutate(P(p), IA32_LEA, BinaryAcc.getResult(P(p)), consumeAddress(DW, null, null)));

r:	INT_ADD_ACC(address1scaledreg, address1reg)
20
EMIT_INSTRUCTION
combineAddresses(); \
EMIT(MIR_Lea.mutate(P(p), IA32_LEA, BinaryAcc.getResult(P(p)), consumeAddress(DW, null, null)));

r:	INT_ADD_ACC(address1reg, address1scaledreg)
20
EMIT_INSTRUCTION
combineAddresses(); \
EMIT(MIR_Lea.mutate(P(p), IA32_LEA, BinaryAcc.getResult(P(p)), consumeAddress(DW, null, null)));

r:	INT_ADD_ACC(address, INT_CONSTANT)
20
EMIT_INSTRUCTION
augmentAddress(BinaryAcc.getValue(P(p))); \
EMIT(MIR_Lea.mutate(P(p), IA32_LEA, BinaryAcc.getResult(P(p)), consumeAddress(DW, null, null)));

##################################
# Materialization of FP constants
##################################
r:	MATERIALIZE_FP_CONSTANT(riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Binary.getResult(P(p)), MO_MC(P(p))));

fp0:	MATERIALIZE_FP_CONSTANT(riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, D(getFPR(0)), MO_MC(P(p))));

pfp0:	MATERIALIZE_FP_CONSTANT(riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_MC(P(p))));

# Use FLD1/FLDZ to avoid loading from the JTOC
r:	MATERIALIZE_FP_CONSTANT(riv)
isFPC_ONE(P(p), 26)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLD1, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Binary.getResult(P(p)), myFP0()));

fp0:	MATERIALIZE_FP_CONSTANT(riv)
isFPC_ONE(P(p), 26)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLD1, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	MATERIALIZE_FP_CONSTANT(riv)
isFPC_ONE(P(p), 11)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.mutate(P(p), IA32_FLD1, myFP0()));

r:	MATERIALIZE_FP_CONSTANT(riv)
isFPC_ZERO(P(p), 26)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLDZ, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Binary.getResult(P(p)), myFP0()));

fp0:	MATERIALIZE_FP_CONSTANT(riv)
isFPC_ZERO(P(p), 26)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLDZ, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	MATERIALIZE_FP_CONSTANT(riv)
isFPC_ZERO(P(p), 11)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.mutate(P(p), IA32_FLDZ, myFP0()));

# Use FLD1/FLDZ to avoid loading from the JTOC
r:	MATERIALIZE_FP_CONSTANT(GET_JTOC(r))
isFPC_ONE(P(p), 26)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLD1, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Binary.getResult(P(p)), myFP0()));

fp0:	MATERIALIZE_FP_CONSTANT(GET_JTOC(r))
isFPC_ONE(P(p), 26)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLD1, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	MATERIALIZE_FP_CONSTANT(GET_JTOC(r))
isFPC_ONE(P(p), 11)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.mutate(P(p), IA32_FLD1, myFP0()));

r:	MATERIALIZE_FP_CONSTANT(GET_JTOC(r))
isFPC_ZERO(P(p), 26)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLDZ, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Binary.getResult(P(p)), myFP0()));

fp0:	MATERIALIZE_FP_CONSTANT(GET_JTOC(r))
isFPC_ZERO(P(p), 26)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLDZ, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	MATERIALIZE_FP_CONSTANT(GET_JTOC(r))
isFPC_ZERO(P(p), 11)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.mutate(P(p), IA32_FLDZ, myFP0()));

##################################
# A few operators are passed through unchanged
##################################
stm:	IG_PATCH_POINT
10
EMIT_INSTRUCTION
EMIT(InlineGuard.mutate(P(p), IG_PATCH_POINT, null, null, null, InlineGuard.getTarget(P(p)), InlineGuard.getBranchProfile(P(p))));

stm:	UNINT_BEGIN
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	UNINT_END
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	YIELDPOINT_PROLOGUE
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	YIELDPOINT_EPILOGUE
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	YIELDPOINT_BACKEDGE
10
EMIT_INSTRUCTION
EMIT(P(p));

##################################
# 
##################################
stm:	LOWTABLESWITCH(r)
10
EMIT_INSTRUCTION
LOWTABLESWITCH(P(p));

stm:	RESOLVE
10
EMIT_INSTRUCTION
RESOLVE(P(p));

##################################
# NOPs can simply be dropped
##################################
stm:	NOP
10
NOFLAGS
// drop on floor

#####
# GUARD_MOVE
#####
# note: ignoring guard registers, thus no uses
r:	GUARD_MOVE
11
EMIT_INSTRUCTION
EMIT(P(p));

#####
# GUARD_COMBINE
#####
# note: ignoring guard registers, thus no uses
r:	GUARD_COMBINE
11
EMIT_INSTRUCTION
EMIT(P(p));

#####
# NULL_CHECK
#####
stm:	NULL_CHECK(r)
11
EMIT_INSTRUCTION
EMIT(P(p)); 

#####
# IR_PROLOGUE:
#####
stm:	IR_PROLOGUE
11
EMIT_INSTRUCTION
PROLOGUE(P(p));

###########
# Rules for exceptions
###########
r:	GET_CAUGHT_EXCEPTION
11
EMIT_INSTRUCTION
GET_EXCEPTION_OBJECT(P(p));

stm:	SET_CAUGHT_EXCEPTION(r)
11
EMIT_INSTRUCTION
SET_EXCEPTION_OBJECT(P(p));

##################################
# Trap operations
##################################
#####
# TRAP
#####
stm:	TRAP
10
EMIT_INSTRUCTION
EMIT(MIR_Trap.mutate(P(p), IA32_INT, Trap.getGuardResult(P(p)), Trap.getTCode(P(p))));

#####
# TRAP_IF
#####
stm:	TRAP_IF(riv, INT_CONSTANT)
10
EMIT_INSTRUCTION
TRAP_IF_IMM(P(p));

stm:	TRAP_IF(riv, r)
10
EMIT_INSTRUCTION
EMIT(MIR_TrapIf.mutate(P(p), IA32_TRAPIF, \
                       TrapIf.getGuardResult(P(p)), \
		       TrapIf.getVal1(P(p)), \
		       TrapIf.getVal2(P(p)), \
		       COND(TrapIf.getCond(P(p))), \
		       TrapIf.getTCode(P(p))));

### Memory operands ###
stm:	TRAP_IF(load32, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_TrapIf.mutate(P(p), IA32_TRAPIF, \
                       TrapIf.getGuardResult(P(p)), \
		       consumeMO(), \
		       TrapIf.getVal2(P(p)), \
		       COND(TrapIf.getCond(P(p))), \
		       TrapIf.getTCode(P(p))));

stm:	TRAP_IF(riv, load32)
15
EMIT_INSTRUCTION
EMIT(MIR_TrapIf.mutate(P(p), IA32_TRAPIF, \
                       TrapIf.getGuardResult(P(p)), \
		       TrapIf.getVal1(P(p)), \
	               consumeMO(), \
		       COND(TrapIf.getCond(P(p))), \
		       TrapIf.getTCode(P(p))));

##################################
# Basic Boolean ALU operations 
##################################
#####
# BOOLEAN_NOT_ACC
#####
r:	BOOLEAN_NOT_ACC(r)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_XOR, UnaryAcc.getResult(P(p)), IC(1)));

### Memory operands ###
stm:	BYTE_STORE(BOOLEAN_NOT_ACC(UBYTE_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_XOR, MO_S(P(p), B), IC(1)));

stm:	BYTE_ASTORE(BOOLEAN_NOT_ACC(UBYTE_ALOAD(r,riv)),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_XOR, MO_AS(P(p), B_S, B), IC(1)));

#####
# BOOLEAN_CMP_INT
#####
r:	BOOLEAN_CMP_INT(r,riv)
39
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), \
            BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p)), \
	    BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP_INT(r,riv)
13
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p))); \
EMIT(MIR_Compare.mutate(P(p), IA32_CMP, BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p))));

r:	BOOLEAN_CMP_INT(r,INT_CONSTANT)
VR(p) == 0 && EQ_NE(BooleanCmp.getCond(P(p)))?37:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.create(IA32_TEST, BooleanCmp.getVal1(P(p)), BooleanCmp.getVal1(P(p)).copy())); \
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP_INT(r,INT_CONSTANT)
VR(p) == 0 && EQ_NE(BooleanCmp.getCond(P(p)))?11:INFINITE
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p))); \
EMIT(MIR_Test.create(IA32_TEST, BooleanCmp.getVal1(P(p)), BooleanCmp.getVal1(P(p)).copy()));

r:	BOOLEAN_CMP_INT(cz, INT_CONSTANT)
isZERO(VR(p), 26)
EMIT_INSTRUCTION 
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP_INT(cz, INT_CONSTANT)
isZERO(VR(p), 0)
EMIT_INSTRUCTION 
pushCOND(BooleanCmp.getCond(P(p))); 

r:	BOOLEAN_CMP_INT(szp, INT_CONSTANT)
VR(p) == 0 && EQ_NE(BooleanCmp.getCond(P(p)))?26:INFINITE
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP_INT(szp, INT_CONSTANT)
VR(p) == 0 && EQ_NE(BooleanCmp.getCond(P(p)))?0:INFINITE
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p)));

## chaining of boolcmps
r:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
VR(p) == 1 && BooleanCmp.getCond(P(p)).isEQUAL()?26:INFINITE
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), consumeCOND());

boolcmp:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
VR(p) == 1 && BooleanCmp.getCond(P(p)).isEQUAL()?0:INFINITE
NOFLAGS
// use already pushed condition

r:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
VR(p) == 1 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()?26:INFINITE
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), consumeCOND().flipCode());

boolcmp:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
VR(p) == 1 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()?0:INFINITE
EMIT_INSTRUCTION
pushCOND(consumeCOND().flipCode()); // invert already pushed condition

r:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
VR(p) == 0 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()?26:INFINITE
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), consumeCOND());

boolcmp:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
VR(p) == 0 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()?0:INFINITE
NOFLAGS
// use already pushed condition

r:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
VR(p) == 0 && BooleanCmp.getCond(P(p)).isEQUAL()?26:INFINITE
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), consumeCOND().flipCode());

boolcmp: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
VR(p) == 0 && BooleanCmp.getCond(P(p)).isEQUAL()?0:INFINITE
EMIT_INSTRUCTION
pushCOND(consumeCOND().flipCode()); // invert already pushed condition

### Memory operands ###
r:	BOOLEAN_CMP_INT(load32,riv)
41
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(PL(p), BooleanCmp.getResult(P(p)), \
            consumeMO(), BooleanCmp.getVal2(P(p)), \
	    BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP_INT(load32,riv)
15
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p))); \
EMIT(MIR_Compare.mutate(PL(p), IA32_CMP, consumeMO(), BooleanCmp.getVal2(P(p)))); 

r:	BOOLEAN_CMP_INT(r,load32)
41
EMIT_INSTRUCTION
BOOLEAN_CMP_INT(PR(p), BooleanCmp.getResult(P(p)), \
            BooleanCmp.getVal1(P(p)), consumeMO(), \
	    BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP_INT(r,load32)
15
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p))); \
EMIT(MIR_Compare.mutate(PR(p), IA32_CMP, BooleanCmp.getVal1(P(p)), consumeMO()));

stm:	BYTE_STORE(boolcmp, OTHER_OPERAND(riv,riv))
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Set.mutate(P(p), IA32_SET__B, MO_S(P(p),B), COND(consumeCOND())));

stm:	BYTE_ASTORE(boolcmp, OTHER_OPERAND(r,riv))
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Set.mutate(P(p), IA32_SET__B, MO_AS(P(p),B_S,B), COND(consumeCOND())));

#####
# BOOLEAN_CMP_LONG
#####
r:	BOOLEAN_CMP_LONG(rlv,rlv)
8*13
EMIT_INSTRUCTION
BOOLEAN_CMP_LONG(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p)), BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP_LONG(rlv,rlv)
11*13
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p))); \
LONG_CMP(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p))); \
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, BooleanCmp.getResult(P(p)), IC(0))));

#####
# BOOLEAN_CMP_FLOAT
#####
r:	BOOLEAN_CMP_FLOAT(r,r)
39
EMIT_INSTRUCTION
BOOLEAN_CMP_DOUBLE(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)), \
                  BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p)));

boolcmp: BOOLEAN_CMP_FLOAT(r,r)
13
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p))); \
EMIT(CPOS(P(p), MIR_Move.create(IA32_FMOV, D(getFPR(0)), CondMove.getVal1(P(p))))); \
EMIT(CPOS(P(p), MIR_Compare.create(IA32_FCOMI, D(getFPR(0)), CondMove.getVal2(P(p)))));

#####
# BOOLEAN_CMP_DOUBLE
#####
r:	BOOLEAN_CMP_DOUBLE(r,r)
39
EMIT_INSTRUCTION
BOOLEAN_CMP_DOUBLE(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)), \
                  BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p)));

boolcmp: BOOLEAN_CMP_DOUBLE(r,r)
13
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p))); \
EMIT(CPOS(P(p), MIR_Move.create(IA32_FMOV, D(getFPR(0)), CondMove.getVal1(P(p))))); \
EMIT(CPOS(P(p), MIR_Compare.create(IA32_FCOMI, D(getFPR(0)), CondMove.getVal2(P(p)))));

##################################
# Conditional moves
##################################
r: CMP_CMOV(r, OTHER_OPERAND(riv, any))
(13 + 30)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP,  CondMove.getVal1(P(p)), CondMove.getVal2(P(p))))); \
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_CMOV(r, OTHER_OPERAND(INT_CONSTANT, any))
VRL(p) == 0 && EQ_NE(CondMove.getCond(P(p)))?(11 + 30):INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.create(IA32_TEST, CondMove.getVal1(P(p)), CondMove.getVal1(P(p)).copy())); \
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# Because uload is only used for booleans (0/1) we can get away
# with this for both signed and unsigned loads.
r: CMP_CMOV(load8, OTHER_OPERAND(INT_CONSTANT, any))
FITS(CondMove.getVal2(P(p)), 8, (15 + 30))
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal2(P(p))))); \
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# We only use uload8 for boolean values, so if the IR is well-typed,
# then r must contain either 0 or 1 and we can do this.
r: CMP_CMOV(uload8, OTHER_OPERAND(r, any))
(15 + 30)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal2(P(p))))); \
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# We only use uload8 for boolean values, so if the IR is well-typed,
# then r must contain either 0 or 1 and we can do this.
r: CMP_CMOV(r, OTHER_OPERAND(uload8, any))
(15 + 30)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal2(P(p))))); \
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_CMOV(sload16, OTHER_OPERAND(INT_CONSTANT, any))
FITS(CondMove.getVal2(P(p)), 8, (15 + 30))
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal2(P(p))))); \
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_CMOV(load32, OTHER_OPERAND(riv, any))
(15 + 30)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal2(P(p))))); \
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_CMOV(r, OTHER_OPERAND(load32, any))
(15 + 30)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, CondMove.getVal1(P(p)), consumeMO()))); \
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# CMP_CMOV((boolcmp, 0/1), tv, fv)
r: CMP_CMOV(boolcmp, OTHER_OPERAND(INT_CONSTANT, any))
VRL(p) == 0 && (CondMove.getCond(P(p)).isNOT_EQUAL())?(0 + 30):INFINITE
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(P(p), CondMove.getResult(P(p)), consumeCOND(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_CMOV(boolcmp, OTHER_OPERAND(INT_CONSTANT, any))
VRL(p) == 0 && (CondMove.getCond(P(p)).isEQUAL())?(0 + 30):INFINITE
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(P(p), CondMove.getResult(P(p)), consumeCOND().flipCode(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_CMOV(boolcmp, OTHER_OPERAND(INT_CONSTANT, any))
VRL(p) == 1 && (CondMove.getCond(P(p)).isEQUAL())?(0 + 30):INFINITE
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(P(p), CondMove.getResult(P(p)), consumeCOND(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_CMOV(boolcmp, OTHER_OPERAND(INT_CONSTANT, any))
VRL(p) == 1 && (CondMove.getCond(P(p)).isNOT_EQUAL())?(0 + 30):INFINITE
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(P(p), CondMove.getResult(P(p)), consumeCOND().flipCode(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# CMOV((cz, 0), tv ,fv); condition code already set
r: CMP_CMOV(cz, OTHER_OPERAND(INT_CONSTANT, any))
isZERO(VRL(p), 30)
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# CMOV((szp, 0), tv ,fv); condition code already set
r: CMP_CMOV(szp, OTHER_OPERAND(INT_CONSTANT, any))
isZERO(VRL(p), 30)
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

#####
# CMP_FCMOV
#####
r: CMP_FCMOV(r, OTHER_OPERAND(riv, any))
(13 + 30)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP,  CondMove.getVal1(P(p)), CondMove.getVal2(P(p))))); \
CMOV_FMOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_FCMOV(r, OTHER_OPERAND(INT_CONSTANT, any))
VRL(p) == 0 && EQ_NE(CondMove.getCond(P(p)))?(11 + 30):INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.create(IA32_TEST, CondMove.getVal1(P(p)), CondMove.getVal1(P(p)).copy())); \
CMOV_FMOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# Because uload is only used for booleans (0/1) we can get away
# with this for both signed and unsigned loads.
r: CMP_FCMOV(load8, OTHER_OPERAND(INT_CONSTANT, any))
FITS(CondMove.getVal2(P(p)), 8, (15 + 30))
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal2(P(p))))); \
CMOV_FMOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# We only use uload8 for boolean values, so if the IR is well-typed,
# then r must contain either 0 or 1 and we can do this.
r: CMP_FCMOV(uload8, OTHER_OPERAND(r, any))
(15 + 30)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal2(P(p))))); \
CMOV_FMOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# We only use uload8 for boolean values, so if the IR is well-typed,
# then r must contain either 0 or 1 and we can do this.
r: CMP_FCMOV(r, OTHER_OPERAND(uload8, any))
(15 + 30)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal2(P(p))))); \
CMOV_FMOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_FCMOV(sload16, OTHER_OPERAND(INT_CONSTANT, any))
FITS(CondMove.getVal2(P(p)), 8, (15 + 30))
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal2(P(p))))); \
CMOV_FMOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_FCMOV(load32, OTHER_OPERAND(riv, any))
(15 + 30)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal2(P(p))))); \
CMOV_FMOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_FCMOV(r, OTHER_OPERAND(load32, any))
(15 + 30)
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, CondMove.getVal1(P(p)), consumeMO()))); \
CMOV_FMOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# CMP_FCMOV((boolcmp, 0/1), tv, fv)
r: CMP_FCMOV(boolcmp, OTHER_OPERAND(INT_CONSTANT, any))
VRL(p) == 0 && (CondMove.getCond(P(p)).isNOT_EQUAL())?(0 + 30):INFINITE
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_FMOV(P(p), CondMove.getResult(P(p)), consumeCOND(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_FCMOV(boolcmp, OTHER_OPERAND(INT_CONSTANT, any))
VRL(p) == 0 && (CondMove.getCond(P(p)).isEQUAL())?(0 + 30):INFINITE
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_FMOV(P(p), CondMove.getResult(P(p)), consumeCOND().flipCode(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_FCMOV(boolcmp, OTHER_OPERAND(INT_CONSTANT, any))
VRL(p) == 1 && (CondMove.getCond(P(p)).isEQUAL())?(0 + 30):INFINITE
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_FMOV(P(p), CondMove.getResult(P(p)), consumeCOND(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: CMP_FCMOV(boolcmp, OTHER_OPERAND(INT_CONSTANT, any))
VRL(p) == 1 && (CondMove.getCond(P(p)).isNOT_EQUAL())?(0 + 30):INFINITE
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_FMOV(P(p), CondMove.getResult(P(p)), consumeCOND().flipCode(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# CMOV((cz, 0), tv ,fv); condition code already set
r: CMP_FCMOV(cz, OTHER_OPERAND(INT_CONSTANT, any))
isZERO(VRL(p), 30)
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_FMOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# CMOV((szp, 0), tv ,fv); condition code already set
r: CMP_FCMOV(szp, OTHER_OPERAND(INT_CONSTANT, any))
isZERO(VRL(p), 30)
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_FMOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

#####
# FCMP_CMOV
#####
# Optimize for one operand already on the FP stack
r: FCMP_CMOV(fp0, OTHER_OPERAND(r, any))
30
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(CPOS(P(p), MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), CondMove.getVal2(P(p))))); \
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)).translateUNSIGNED(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: FCMP_CMOV(pfp0, OTHER_OPERAND(r, any))
35
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(CPOS(P(p), MIR_Compare.create(IA32_FCOMIP, myFP0(), CondMove.getVal2(P(p))))); \
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)).translateUNSIGNED(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: FCMP_CMOV(r, OTHER_OPERAND(r, any))
p.child1.isREGISTERNode()?60:43
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Move.create(IA32_FMOV, D(getFPR(0)), CondMove.getVal1(P(p))))); \
EMIT(CPOS(P(p), MIR_Compare.create(IA32_FCOMI, D(getFPR(0)), CondMove.getVal2(P(p))))); \
CMOV_MOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)).translateUNSIGNED(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# Can't optimize cases: FCMP_CMOV(r, OTHER_OPERAND(fp0/pfp0, any)) or
# for child2 being a register as flip operands may produce an invalid
# FP comparison
#####
# FCMP_FCMOV
#####
# Optimize for one operand already on the FP stack
r: FCMP_FCMOV(fp0, OTHER_OPERAND(r, any))
30
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(CPOS(P(p), MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), CondMove.getVal2(P(p))))); \
CMOV_FMOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)).translateUNSIGNED(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: FCMP_FCMOV(pfp0, OTHER_OPERAND(r, any))
35
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(CPOS(P(p), MIR_Compare.create(IA32_FCOMIP, myFP0(), CondMove.getVal2(P(p))))); \
CMOV_FMOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)).translateUNSIGNED(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r: FCMP_FCMOV(r, OTHER_OPERAND(r, any))
p.child1.isREGISTERNode()?60:43
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Move.create(IA32_FMOV, D(getFPR(0)), CondMove.getVal1(P(p))))); \
EMIT(CPOS(P(p), MIR_Compare.create(IA32_FCOMI, D(getFPR(0)), CondMove.getVal2(P(p))))); \
CMOV_FMOV(P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)).translateUNSIGNED(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# Can't optimize cases: FCMP_CMOV(r, OTHER_OPERAND(fp0/pfp0, any)) or
# for child2 being a register as flip operands may produce an invalid
# FP comparison
#####
# LCMP_CMOV
#####
r: LCMP_CMOV(r, OTHER_OPERAND(rlv, any))
(8*13 + 30)
EMIT_INSTRUCTION
LCMP_CMOV(P(p), CondMove.getResult(P(p)), CondMove.getVal1(P(p)), CondMove.getVal2(P(p)),\
          CondMove.getCond(P(p)), CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

##################################
# Basic Integer ALU operations 
##################################
#####
# INT_ADD_ACC
#####
czr:	INT_ADD_ACC(r, riv)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p))));

r:	INT_ADD_ACC(r, INT_CONSTANT)
isONE(VR(p),11)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_INC, BinaryAcc.getResult(P(p))));

r:	INT_ADD_ACC(r, INT_CONSTANT)
VR(p) == -1 ? 11 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_DEC, BinaryAcc.getResult(P(p))));

### Memory operands ###
czr:	INT_ADD_ACC(r, load32)
15
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, BinaryAcc.getResult(P(p)), consumeMO()));

stm:	INT_STORE(INT_ADD_ACC(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, MO_S(P(p), DW), BinaryAcc.getValue(PL(p))));

stm:	INT_STORE(INT_ADD_ACC(INT_LOAD(riv,riv),INT_CONSTANT),OTHER_OPERAND(riv, riv))
VLR(p) == 1 ? ADDRESS_EQUAL(P(p), PLL(p), 15) : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_INC, MO_S(P(p), DW)));

stm:	INT_STORE(INT_ADD_ACC(INT_LOAD(riv,riv),INT_CONSTANT),OTHER_OPERAND(riv, riv))
VLR(p) == -1 ? ADDRESS_EQUAL(P(p), PLL(p), 15) : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_DEC, MO_S(P(p), DW)));

stm:	INT_ASTORE(INT_ADD_ACC(INT_ALOAD(r,riv),riv),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, MO_AS(P(p), DW_S, DW), BinaryAcc.getValue(PL(p))));

stm:	INT_ASTORE(INT_ADD_ACC(INT_ALOAD(r,riv),INT_CONSTANT),OTHER_OPERAND(r, riv))
VLR(p) == 1 ? ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 15) : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_INC, MO_AS(P(p), DW_S, DW)));

stm:	INT_ASTORE(INT_ADD_ACC(INT_ALOAD(r,riv),INT_CONSTANT),OTHER_OPERAND(r, riv))
VLR(p) == -1 ? ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 15) : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_DEC, MO_AS(P(p), DW_S, DW)));

#####
# INT_SUB_ACC
#####
czr:	INT_SUB_ACC(r, riv)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SUB, BinaryAcc.getResult(P(p)),         \
			  BinaryAcc.getValue(P(p))));

r:	INT_SUB_ACC(r, INT_CONSTANT)
VR(p) == 1 ? 11 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_DEC, BinaryAcc.getResult(P(p))));

r:	INT_SUB_ACC(r, INT_CONSTANT)
VR(p) == -1 ? 11 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_INC, BinaryAcc.getResult(P(p))));

### Memory operands ###
czr:	INT_SUB_ACC(r, load32)
15
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SUB, BinaryAcc.getResult(P(p)), consumeMO()));

stm:	INT_STORE(INT_SUB_ACC(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SUB, MO_S(P(p), DW), BinaryAcc.getValue(PL(p))));

stm:	INT_STORE(INT_SUB_ACC(INT_LOAD(riv,riv),INT_CONSTANT),OTHER_OPERAND(riv, riv))
VLR(p) == 1 ? ADDRESS_EQUAL(P(p), PLL(p), 15) : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_DEC, MO_S(P(p), DW)));

stm:	INT_STORE(INT_SUB_ACC(INT_LOAD(riv,riv),INT_CONSTANT),OTHER_OPERAND(riv, riv))
VLR(p) == -1 ? ADDRESS_EQUAL(P(p), PLL(p), 15) : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_INC, MO_S(P(p), DW)));

stm:	INT_ASTORE(INT_SUB_ACC(INT_ALOAD(r,riv),riv),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SUB, MO_AS(P(p), DW_S, DW), BinaryAcc.getValue(PL(p))));

stm:	INT_ASTORE(INT_SUB_ACC(INT_ALOAD(r,riv),INT_CONSTANT),OTHER_OPERAND(r, riv))
VLR(p) == 1 ? ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 15) : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_DEC, MO_AS(P(p), DW_S, DW)));

stm:	INT_ASTORE(INT_SUB_ACC(INT_ALOAD(r,riv),INT_CONSTANT),OTHER_OPERAND(r, riv))
VLR(p) == -1 ? ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 15) : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_INC, MO_AS(P(p), DW_S, DW)));

#####
# INT_MUL_ACC
#####
r:	INT_MUL_ACC(r, riv)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_IMUL2, BinaryAcc.getResult(P(p)),         \
			  BinaryAcc.getValue(P(p))));

### Memory operands ### 
# TODO: consider adding rules for memory operands for INT_MUL_ACC
#####
# INT_DIV
#####
r:	INT_DIV(riv, riv)
52
EMIT_INSTRUCTION
INT_DIVIDES(P(p), GuardedBinary.getResult(P(p)), GuardedBinary.getVal1(P(p)), \
	                GuardedBinary.getVal2(P(p)), true);

### Memory operands ### 
# TODO: consider adding rules for memory operands INT_DIV
#####
# INT_REM
#####
r:	INT_REM(riv, riv)
52
EMIT_INSTRUCTION
INT_DIVIDES(P(p), GuardedBinary.getResult(P(p)), GuardedBinary.getVal1(P(p)), \
	                GuardedBinary.getVal2(P(p)), false);

### Memory operands ### 
# TODO: consider adding rules for memory operands for INT_REM
#####
# INT_NEG_ACC
#####
szpr:	INT_NEG_ACC(r)
13
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_NEG, UnaryAcc.getResult(P(p))));

### Memory operands ### 
stm:	INT_STORE(INT_NEG_ACC(INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_NEG, MO_S(P(p), DW)));

stm:	INT_ASTORE(INT_NEG_ACC(INT_ALOAD(r,riv)),OTHER_OPERAND(r,riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_NEG, MO_AS(P(p), DW_S, DW)));

#####
# INT_SHL_ACC
#####
szpr:	INT_SHL_ACC(r, r)
23
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, new OPT_RegisterOperand(getECX(), VM_TypeReference.Int), BinaryAcc.getValue(P(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, BinaryAcc.getResult(P(p)),  new OPT_RegisterOperand(getECX(), VM_TypeReference.Int)));

szpr:	INT_SHL_ACC(r, INT_CONSTANT)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p))));

### Memory operands ### 
stm:	INT_STORE(INT_SHL_ACC(INT_LOAD(riv,riv),r),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 27)
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, new OPT_RegisterOperand(getECX(), VM_TypeReference.Int), BinaryAcc.getValue(PL(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_S(P(p), DW), new OPT_RegisterOperand(getECX(), VM_TypeReference.Int)));

stm:	INT_STORE(INT_SHL_ACC(INT_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_S(P(p), DW), BinaryAcc.getValue(PL(p))));

stm:	INT_ASTORE(INT_SHL_ACC(INT_ALOAD(r,riv),r),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 27)
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, new OPT_RegisterOperand(getECX(), VM_TypeReference.Int), BinaryAcc.getValue(PL(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_AS(P(p), DW_S, DW), new OPT_RegisterOperand(getECX(), VM_TypeReference.Int)));

stm:	INT_ASTORE(INT_SHL_ACC(INT_ALOAD(r,riv), INT_CONSTANT),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_AS(P(p), DW_S, DW), BinaryAcc.getValue(PL(p))));

#####
# INT_SHR_ACC: 
#####
szpr:	INT_SHR_ACC(r, r)
23
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, new OPT_RegisterOperand(getECX(), VM_TypeReference.Int), BinaryAcc.getValue(P(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, BinaryAcc.getResult(P(p)), new OPT_RegisterOperand(getECX(), VM_TypeReference.Int)));

szpr:	INT_SHR_ACC(r, INT_CONSTANT)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p))));

### Memory operands ### 
stm:	INT_STORE(INT_SHR_ACC(INT_LOAD(riv,riv),r),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 27)
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, new OPT_RegisterOperand(getECX(), VM_TypeReference.Int), BinaryAcc.getValue(PL(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_S(P(p), DW), new OPT_RegisterOperand(getECX(), VM_TypeReference.Int)));

stm:	INT_STORE(INT_SHR_ACC(INT_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_S(P(p), DW), BinaryAcc.getValue(PL(p))));

stm:	INT_ASTORE(INT_SHR_ACC(INT_ALOAD(r,riv),r),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 27)
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, new OPT_RegisterOperand(getECX(), VM_TypeReference.Int), BinaryAcc.getValue(PL(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_AS(P(p), DW_S, DW), new OPT_RegisterOperand(getECX(), VM_TypeReference.Int)));

stm:	INT_ASTORE(INT_SHR_ACC(INT_ALOAD(r,riv), INT_CONSTANT),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_AS(P(p), DW_S, DW), BinaryAcc.getValue(PL(p))));

#####
# INT_USHR_ACC
#####
szpr:	INT_USHR_ACC(r, r)
23
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, new OPT_RegisterOperand(getECX(), VM_TypeReference.Int), BinaryAcc.getValue(P(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, BinaryAcc.getResult(P(p)), new OPT_RegisterOperand(getECX(), VM_TypeReference.Int)));

szpr:	INT_USHR_ACC(r, INT_CONSTANT)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p))));

### Memory operands ### 
stm:	INT_STORE(INT_USHR_ACC(INT_LOAD(riv,riv),r),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 27)
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, new OPT_RegisterOperand(getECX(), VM_TypeReference.Int), BinaryAcc.getValue(PL(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_S(P(p), DW), new OPT_RegisterOperand(getECX(), VM_TypeReference.Int)));

stm:	INT_STORE(INT_USHR_ACC(INT_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_S(P(p), DW), BinaryAcc.getValue(PL(p))));

stm:	INT_ASTORE(INT_USHR_ACC(INT_ALOAD(r,riv),r),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 27)
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, new OPT_RegisterOperand(getECX(), VM_TypeReference.Int), BinaryAcc.getValue(PL(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_AS(P(p), DW_S, DW), new OPT_RegisterOperand(getECX(), VM_TypeReference.Int)));

stm:	INT_ASTORE(INT_USHR_ACC(INT_ALOAD(r,riv), INT_CONSTANT),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_AS(P(p), DW_S, DW), BinaryAcc.getValue(PL(p))));

#####
# INT_AND_ACC
#####
szpr:	INT_AND_ACC(r, riv)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, BinaryAcc.getResult(P(p)),         \
			  BinaryAcc.getValue(P(p))));

szp:	INT_AND_ACC(r, r)
11
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(P(p), IA32_TEST, BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p))));

### Memory operands ### 
szpr:	INT_AND_ACC(r, load32)
15
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, BinaryAcc.getResult(P(p)), consumeMO()));

szp:	INT_AND_ACC(riv, load32)
13
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(P(p), IA32_TEST, BinaryAcc.getResult(P(p)), consumeMO()));

szp:	INT_AND_ACC(load32, riv)
13
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(P(p), IA32_TEST, BinaryAcc.getValue(P(p)), consumeMO()));

stm:	INT_STORE(INT_AND_ACC(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, MO_S(P(p), DW), BinaryAcc.getValue(PL(p))));

stm:	INT_ASTORE(INT_AND_ACC(INT_ALOAD(r,riv),riv),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, MO_AS(P(p), DW_S, DW), BinaryAcc.getValue(PL(p))));

#####
# INT_OR_ACC
#####
szpr:	INT_OR_ACC(r, riv)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_OR, BinaryAcc.getResult(P(p)),         \
			  BinaryAcc.getValue(P(p))));

### Memory operands ### 
szpr:	INT_OR_ACC(r, load32)
15
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_OR, BinaryAcc.getResult(P(p)), consumeMO()));

stm:	INT_STORE(INT_OR_ACC(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_OR, MO_S(P(p), DW), BinaryAcc.getValue(PL(p))));

stm:	INT_ASTORE(INT_OR_ACC(INT_ALOAD(r,riv),riv),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_OR, MO_AS(P(p), DW_S, DW), BinaryAcc.getValue(PL(p))));

#####
# INT_XOR_ACC
#####
szpr:	INT_XOR_ACC(r, riv)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_XOR, BinaryAcc.getResult(P(p)),         \
			  BinaryAcc.getValue(P(p))));

### Memory operands ### 
szpr:	INT_XOR_ACC(r, load32)
15
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_XOR, BinaryAcc.getResult(P(p)), consumeMO()));

stm:	INT_STORE(INT_XOR_ACC(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_XOR, MO_S(P(p), DW), BinaryAcc.getValue(PL(p))));

stm:	INT_ASTORE(INT_XOR_ACC(INT_ALOAD(r,riv),riv),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_XOR, MO_AS(P(p), DW_S, DW), BinaryAcc.getValue(PL(p))));

#####
# INT_NOT_ACC
#####
r:	INT_NOT_ACC(r)
13
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_NOT, UnaryAcc.getResult(P(p))));

### Memory operands ### 
stm:	INT_STORE(INT_NOT_ACC(INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_NOT, MO_S(P(p), DW)));

stm:	INT_ASTORE(INT_NOT_ACC(INT_ALOAD(r,riv)),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_NOT, MO_AS(P(p), DW_S, DW)));

##################################
# Basic Floating-Point ALU operations 
##################################
#####
# FP_ADD (handles both float and double; both are 80 bit anyways...)
#####
fp0:	FP_ADD(r, r)
p.child1.isREGISTERNode()?43:26
EMIT_INSTRUCTION
FP_MOV_OP(P(p), IA32_FADD, Binary.getVal1(P(p)), Binary.getVal2(P(p)));

fp0:	FP_ADD(r, r)
p.child2.isREGISTERNode()?43:26
EMIT_INSTRUCTION
FP_MOV_OP(P(p), IA32_FADD, Binary.getVal2(P(p)), Binary.getVal1(P(p)));

fp0:	FP_ADD(r, fpload)
p.child1.isREGISTERNode()?45:28
EMIT_INSTRUCTION
FP_MOV_OP(P(p), IA32_FADD, Binary.getVal1(P(p)), consumeMO());

fp0:	FP_ADD(fpload, r)
p.child2.isREGISTERNode()?45:28
EMIT_INSTRUCTION
FP_MOV_OP(P(p), IA32_FADD, Binary.getVal2(P(p)), consumeMO());

fp0:	FP_ADD(pfp0, r)
p.child2.isREGISTERNode()?48:31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_MOV_OP(P(p), IA32_FADDP, Binary.getVal2(P(p)), myFP0());

fp0:	FP_ADD(r, pfp0)
p.child1.isREGISTERNode()?48:31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_MOV_OP(P(p), IA32_FADDP, Binary.getVal1(P(p)), myFP0());

fp0:	FP_ADD(fp0, r)
13
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(P(p), IA32_FADD, D(getFPR(0)), Binary.getVal2(P(p)));

fp0:	FP_ADD(r, fp0)
13
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(P(p), IA32_FADD, D(getFPR(0)), Binary.getVal1(P(p)));

fp0:	FP_ADD(fp0, fpload)
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(P(p), IA32_FADD, D(getFPR(0)), consumeMO());

fp0:	FP_ADD(fpload, fp0)
15
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(P(p), IA32_FADD, D(getFPR(0)), consumeMO());

pfp0:	FP_ADD(r, r)
31
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FLD, myFP0(), Binary.getVal1(P(p)))); \
FP_OP(P(p), IA32_FADD, myFP0(), Binary.getVal2(P(p)));

pfp0:	FP_ADD(pfp0, r)
13
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(P(p), IA32_FADD, myFP0(), Binary.getVal2(P(p)));

pfp0:	FP_ADD(r, pfp0)
13
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(P(p), IA32_FADD, myFP0(), Binary.getVal1(P(p)));

pfp0:	FP_ADD(pfp0, fpload)
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(P(p), IA32_FADD, myFP0(), consumeMO());

pfp0:	FP_ADD(fpload, pfp0)
15
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(P(p), IA32_FADD, myFP0(), consumeMO());

r:	FP_ADD(r, r)
p.child1.isREGISTERNode()?56:39
EMIT_INSTRUCTION
FP_MOV_OP_MOV(P(p), IA32_FADD, Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

r:	FP_ADD(r, r)
p.child2.isREGISTERNode()?56:39
EMIT_INSTRUCTION
FP_MOV_OP_MOV(P(p), IA32_FADD, Binary.getResult(P(p)), Binary.getVal2(P(p)), Binary.getVal1(P(p)));

r:	FP_ADD(r, fpload)
p.child1.isREGISTERNode()?58:41
EMIT_INSTRUCTION
FP_MOV_OP_MOV(P(p), IA32_FADD, Binary.getResult(P(p)), Binary.getVal1(P(p)), consumeMO());

r:	FP_ADD(fpload, r)
p.child2.isREGISTERNode()?58:41
EMIT_INSTRUCTION
FP_MOV_OP_MOV(P(p), IA32_FADD, Binary.getResult(P(p)), Binary.getVal2(P(p)), consumeMO());

r:	FP_ADD(r, fp0)
26
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FADD, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), Binary.getVal1(P(p)));

r:	FP_ADD(fp0, r)
26
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FADD, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), Binary.getVal2(P(p)));

r:	FP_ADD(fpload, fp0)
28
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FADD, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), consumeMO());

r:	FP_ADD(fp0, fpload)
28
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FADD, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), consumeMO());

r:	FP_ADD(r, pfp0)
31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FADD, IA32_FSTP, Binary.getResult(P(p)), myFP0(), Binary.getVal1(P(p)));

r:	FP_ADD(pfp0, r)
31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FADD, IA32_FSTP, Binary.getResult(P(p)), myFP0(), Binary.getVal2(P(p)));

r:	FP_ADD(fpload, pfp0)
31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FADD, IA32_FSTP, Binary.getResult(P(p)), myFP0(), consumeMO());

r:	FP_ADD(pfp0, fpload)
31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FADD, IA32_FSTP, Binary.getResult(P(p)), myFP0(), consumeMO());

#####
# FP_MUL (handles both float and double; both are 80 bit anyways...)
#####
fp0:	FP_MUL(r, r)
p.child1.isREGISTERNode()?43:26
EMIT_INSTRUCTION
FP_MOV_OP(P(p), IA32_FMUL, Binary.getVal1(P(p)), Binary.getVal2(P(p)));

fp0:	FP_MUL(r, r)
p.child2.isREGISTERNode()?43:26
EMIT_INSTRUCTION
FP_MOV_OP(P(p), IA32_FMUL, Binary.getVal2(P(p)), Binary.getVal1(P(p)));

fp0:	FP_MUL(r, fpload)
p.child1.isREGISTERNode()?45:28
EMIT_INSTRUCTION
FP_MOV_OP(P(p), IA32_FMUL, Binary.getVal1(P(p)), consumeMO());

fp0:	FP_MUL(fpload, r)
p.child2.isREGISTERNode()?45:28
EMIT_INSTRUCTION
FP_MOV_OP(P(p), IA32_FMUL, Binary.getVal2(P(p)), consumeMO());

fp0:	FP_MUL(pfp0, r)
p.child2.isREGISTERNode()?48:31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_MOV_OP(P(p), IA32_FMULP, Binary.getVal2(P(p)), myFP0());

fp0:	FP_MUL(r, pfp0)
p.child1.isREGISTERNode()?48:31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_MOV_OP(P(p), IA32_FMULP, Binary.getVal1(P(p)), myFP0());

fp0:	FP_MUL(fp0, r)
13
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(P(p), IA32_FMUL, D(getFPR(0)), Binary.getVal2(P(p)));

fp0:	FP_MUL(r, fp0)
13
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(P(p), IA32_FMUL, D(getFPR(0)), Binary.getVal1(P(p)));

fp0:	FP_MUL(fp0, fpload)
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(P(p), IA32_FMUL, D(getFPR(0)), consumeMO());

fp0:	FP_MUL(fpload, fp0)
15
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(P(p), IA32_FMUL, D(getFPR(0)), consumeMO());

pfp0:	FP_MUL(r, r)
31
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FLD, myFP0(), Binary.getVal1(P(p)))); \
FP_OP(P(p), IA32_FMUL, myFP0(), Binary.getVal2(P(p)));

pfp0:	FP_MUL(pfp0, r)
13
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(P(p), IA32_FMUL, myFP0(), Binary.getVal2(P(p)));

pfp0:	FP_MUL(r, pfp0)
13
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(P(p), IA32_FMUL, myFP0(), Binary.getVal1(P(p)));

pfp0:	FP_MUL(pfp0, fpload)
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(P(p), IA32_FMUL, myFP0(), consumeMO());

pfp0:	FP_MUL(fpload, pfp0)
15
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(P(p), IA32_FMUL, myFP0(), consumeMO());

r:	FP_MUL(r, r)
p.child1.isREGISTERNode()?56:39
EMIT_INSTRUCTION
FP_MOV_OP_MOV(P(p), IA32_FMUL, Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

r:	FP_MUL(r, r)
p.child2.isREGISTERNode()?56:39
EMIT_INSTRUCTION
FP_MOV_OP_MOV(P(p), IA32_FMUL, Binary.getResult(P(p)), Binary.getVal2(P(p)), Binary.getVal1(P(p)));

r:	FP_MUL(r, fpload)
p.child1.isREGISTERNode()?58:41
EMIT_INSTRUCTION
FP_MOV_OP_MOV(P(p), IA32_FMUL, Binary.getResult(P(p)), Binary.getVal1(P(p)), consumeMO());

r:	FP_MUL(fpload, r)
p.child2.isREGISTERNode()?58:41
EMIT_INSTRUCTION
FP_MOV_OP_MOV(P(p), IA32_FMUL, Binary.getResult(P(p)), Binary.getVal2(P(p)), consumeMO());

r:	FP_MUL(r, fp0)
26
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FMUL, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), Binary.getVal1(P(p)));

r:	FP_MUL(fp0, r)
26
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FMUL, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), Binary.getVal2(P(p)));

r:	FP_MUL(fpload, fp0)
28
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FMUL, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), consumeMO());

r:	FP_MUL(fp0, fpload)
28
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FMUL, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), consumeMO());

r:	FP_MUL(r, pfp0)
31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FMUL, IA32_FSTP, Binary.getResult(P(p)), myFP0(), Binary.getVal1(P(p)));

r:	FP_MUL(pfp0, r)
31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FMUL, IA32_FSTP, Binary.getResult(P(p)), myFP0(), Binary.getVal2(P(p)));

r:	FP_MUL(fpload, pfp0)
31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FMUL, IA32_FSTP, Binary.getResult(P(p)), myFP0(), consumeMO());

r:	FP_MUL(pfp0, fpload)
31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FMUL, IA32_FSTP, Binary.getResult(P(p)), myFP0(), consumeMO());

#####
# FP_SUB (handles both float and double; both are 80 bit anyways...)
#####
fp0:	FP_SUB(r, r)
p.child1.isREGISTERNode()?43:26
EMIT_INSTRUCTION
FP_MOV_OP(P(p), IA32_FSUB, Binary.getVal1(P(p)), Binary.getVal2(P(p)));

fp0:	FP_SUB(r, r)
p.child2.isREGISTERNode()?43:26
EMIT_INSTRUCTION
FP_MOV_OP(P(p), IA32_FSUBR, Binary.getVal2(P(p)), Binary.getVal1(P(p)));

fp0:	FP_SUB(r, fpload)
p.child1.isREGISTERNode()?45:28
EMIT_INSTRUCTION
FP_MOV_OP(P(p), IA32_FSUB, Binary.getVal1(P(p)), consumeMO());

fp0:	FP_SUB(fpload, r)
p.child2.isREGISTERNode()?45:28
EMIT_INSTRUCTION
FP_MOV_OP(P(p), IA32_FSUBR, Binary.getVal2(P(p)), consumeMO());

fp0:	FP_SUB(pfp0, r)
p.child2.isREGISTERNode()?48:31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_MOV_OP(P(p), IA32_FSUBRP, Binary.getVal2(P(p)), myFP0());

fp0:	FP_SUB(r, pfp0)
p.child1.isREGISTERNode()?48:31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_MOV_OP(P(p), IA32_FSUBP, Binary.getVal1(P(p)), myFP0());

fp0:	FP_SUB(fp0, r)
13
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(P(p), IA32_FSUB, D(getFPR(0)), Binary.getVal2(P(p)));

fp0:	FP_SUB(r, fp0)
13
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(P(p), IA32_FSUBR, D(getFPR(0)), Binary.getVal1(P(p)));

fp0:	FP_SUB(fp0, fpload)
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(P(p), IA32_FSUB, D(getFPR(0)), consumeMO());

fp0:	FP_SUB(fpload, fp0)
15
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(P(p), IA32_FSUBR, D(getFPR(0)), consumeMO());

pfp0:	FP_SUB(r, r)
31
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FLD, myFP0(), Binary.getVal1(P(p)))); \
FP_OP(P(p), IA32_FSUB, myFP0(), Binary.getVal2(P(p)));

pfp0:	FP_SUB(pfp0, r)
13
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(P(p), IA32_FSUB, myFP0(), Binary.getVal2(P(p)));

pfp0:	FP_SUB(r, pfp0)
13
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(P(p), IA32_FSUBR, myFP0(), Binary.getVal1(P(p)));

pfp0:	FP_SUB(pfp0, fpload)
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(P(p), IA32_FSUB, myFP0(), consumeMO());

pfp0:	FP_SUB(fpload, pfp0)
15
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(P(p), IA32_FSUBR, myFP0(), consumeMO());

r:	FP_SUB(r, r)
p.child1.isREGISTERNode()?56:39
EMIT_INSTRUCTION
FP_MOV_OP_MOV(P(p), IA32_FSUB, Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

r:	FP_SUB(r, r)
p.child2.isREGISTERNode()?56:39
EMIT_INSTRUCTION
FP_MOV_OP_MOV(P(p), IA32_FSUBR, Binary.getResult(P(p)), Binary.getVal2(P(p)), Binary.getVal1(P(p)));

r:	FP_SUB(r, fpload)
p.child1.isREGISTERNode()?58:41
EMIT_INSTRUCTION
FP_MOV_OP_MOV(P(p), IA32_FSUB, Binary.getResult(P(p)), Binary.getVal1(P(p)), consumeMO());

r:	FP_SUB(fpload, r)
p.child2.isREGISTERNode()?58:41
EMIT_INSTRUCTION
FP_MOV_OP_MOV(P(p), IA32_FSUBR, Binary.getResult(P(p)), Binary.getVal2(P(p)), consumeMO());

r:	FP_SUB(r, fp0)
26
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FSUBR, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), Binary.getVal1(P(p)));

r:	FP_SUB(fp0, r)
26
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FSUB, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), Binary.getVal2(P(p)));

r:	FP_SUB(fpload, fp0)
28
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FSUBR, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), consumeMO());

r:	FP_SUB(fp0, fpload)
28
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FSUB, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), consumeMO());

r:	FP_SUB(r, pfp0)
31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FSUBR, IA32_FSTP, Binary.getResult(P(p)), myFP0(), Binary.getVal1(P(p)));

r:	FP_SUB(pfp0, r)
31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FSUB, IA32_FSTP, Binary.getResult(P(p)), myFP0(), Binary.getVal2(P(p)));

r:	FP_SUB(fpload, pfp0)
31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FSUBR, IA32_FSTP, Binary.getResult(P(p)), myFP0(), consumeMO());

r:	FP_SUB(pfp0, fpload)
31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FSUB, IA32_FSTP, Binary.getResult(P(p)), myFP0(), consumeMO());

#####
# FP_DIV (handles both float and double; both are 80 bit anyways...)
#####
fp0:	FP_DIV(r, r)
p.child1.isREGISTERNode()?43:26
EMIT_INSTRUCTION
FP_MOV_OP(P(p), IA32_FDIV, Binary.getVal1(P(p)), Binary.getVal2(P(p)));

fp0:	FP_DIV(r, r)
p.child2.isREGISTERNode()?43:26
EMIT_INSTRUCTION
FP_MOV_OP(P(p), IA32_FDIVR, Binary.getVal2(P(p)), Binary.getVal1(P(p)));

fp0:	FP_DIV(r, fpload)
p.child1.isREGISTERNode()?45:28
EMIT_INSTRUCTION
FP_MOV_OP(P(p), IA32_FDIV, Binary.getVal1(P(p)), consumeMO());

fp0:	FP_DIV(fpload, r)
p.child2.isREGISTERNode()?45:28
EMIT_INSTRUCTION
FP_MOV_OP(P(p), IA32_FDIVR, Binary.getVal2(P(p)), consumeMO());

fp0:	FP_DIV(pfp0, r)
p.child2.isREGISTERNode()?48:31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_MOV_OP(P(p), IA32_FDIVRP, Binary.getVal2(P(p)), myFP0());

fp0:	FP_DIV(r, pfp0)
p.child1.isREGISTERNode()?48:31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_MOV_OP(P(p), IA32_FDIVP, Binary.getVal1(P(p)), myFP0());

fp0:	FP_DIV(fp0, r)
13
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(P(p), IA32_FDIV, D(getFPR(0)), Binary.getVal2(P(p)));

fp0:	FP_DIV(r, fp0)
13
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(P(p), IA32_FDIVR, D(getFPR(0)), Binary.getVal1(P(p)));

fp0:	FP_DIV(fp0, fpload)
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(P(p), IA32_FDIV, D(getFPR(0)), consumeMO());

fp0:	FP_DIV(fpload, fp0)
15
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(P(p), IA32_FDIVR, D(getFPR(0)), consumeMO());

pfp0:	FP_DIV(r, r)
31
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FLD, myFP0(), Binary.getVal1(P(p)))); \
FP_OP(P(p), IA32_FDIV, myFP0(), Binary.getVal2(P(p)));

pfp0:	FP_DIV(pfp0, r)
13
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(P(p), IA32_FDIV, myFP0(), Binary.getVal2(P(p)));

pfp0:	FP_DIV(r, pfp0)
13
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(P(p), IA32_FDIVR, myFP0(), Binary.getVal1(P(p)));

pfp0:	FP_DIV(pfp0, fpload)
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(P(p), IA32_FDIV, myFP0(), consumeMO());

pfp0:	FP_DIV(fpload, pfp0)
15
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(P(p), IA32_FDIVR, myFP0(), consumeMO());

r:	FP_DIV(r, r)
p.child1.isREGISTERNode()?56:39
EMIT_INSTRUCTION
FP_MOV_OP_MOV(P(p), IA32_FDIV, Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

r:	FP_DIV(r, r)
p.child2.isREGISTERNode()?56:39
EMIT_INSTRUCTION
FP_MOV_OP_MOV(P(p), IA32_FDIVR, Binary.getResult(P(p)), Binary.getVal2(P(p)), Binary.getVal1(P(p)));

r:	FP_DIV(r, fpload)
p.child1.isREGISTERNode()?58:41
EMIT_INSTRUCTION
FP_MOV_OP_MOV(P(p), IA32_FDIV, Binary.getResult(P(p)), Binary.getVal1(P(p)), consumeMO());

r:	FP_DIV(fpload, r)
p.child2.isREGISTERNode()?58:41
EMIT_INSTRUCTION
FP_MOV_OP_MOV(P(p), IA32_FDIVR, Binary.getResult(P(p)), Binary.getVal2(P(p)), consumeMO());

r:	FP_DIV(r, fp0)
26
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FDIVR, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), Binary.getVal1(P(p)));

r:	FP_DIV(fp0, r)
26
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FDIV, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), Binary.getVal2(P(p)));

r:	FP_DIV(fpload, fp0)
28
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FDIVR, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), consumeMO());

r:	FP_DIV(fp0, fpload)
28
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FDIV, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), consumeMO());

r:	FP_DIV(r, pfp0)
31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FDIVR, IA32_FSTP, Binary.getResult(P(p)), myFP0(), Binary.getVal1(P(p)));

r:	FP_DIV(pfp0, r)
31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FDIV, IA32_FSTP, Binary.getResult(P(p)), myFP0(), Binary.getVal2(P(p)));

r:	FP_DIV(fpload, pfp0)
31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FDIVR, IA32_FSTP, Binary.getResult(P(p)), myFP0(), consumeMO());

r:	FP_DIV(pfp0, fpload)
31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(P(p), IA32_FDIV, IA32_FSTP, Binary.getResult(P(p)), myFP0(), consumeMO());

#####
# FP_REM (handles both float and double; both are 80 bit anyways...)
#####
fp0:	FP_REM(r, r)
39
EMIT_INSTRUCTION
FP_REM(P(p), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

fp0:	FP_REM(fp0, r)
26
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_REM(P(p), Binary.getVal2(P(p)));

r:	FP_REM(r, r)
52
EMIT_INSTRUCTION
OPT_RegisterOperand res = Binary.getResult(P(p)); \
FP_REM(P(p), Binary.getVal1(P(p)), Binary.getVal2(P(p))); \
EMIT(MIR_Move.create(IA32_FMOV, res, F(getFPR(0))));

r:	FP_REM(fp0, r)
52
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
OPT_RegisterOperand res = Binary.getResult(P(p)); \
FP_REM(P(p), Binary.getVal2(P(p))); \
EMIT(MIR_Move.create(IA32_FMOV, res, F(getFPR(0))));

#####
# FP_NEG (handles both float and double; both are 80 bit anyways...)
#####
fp0:	FP_NEG(r)
43
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, D(getFPR(0)), Unary.getVal(P(p)))); \
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_FCHS, D(getFPR(0))));

fp0:	FP_NEG(fp0)
13
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_FCHS, D(getFPR(0))));

pfp0:	FP_NEG(r)
29
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FLD, myFP0(), Unary.getVal(P(p)))); \
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_FCHS, myFP0()));

pfp0:	FP_NEG(pfp0)
13
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_FCHS, myFP0()));

r:	FP_NEG(r)
56
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, D(getFPR(0)), Unary.getVal(P(p)))); \
EMIT(MIR_UnaryAcc.create(IA32_FCHS, D(getFPR(0)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Unary.getResult(P(p)), D(getFPR(0))));

r:	FP_NEG(fp0)
26
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.create(IA32_FCHS, D(getFPR(0)))); \
EMIT(MIR_Move.create(IA32_FMOV, Unary.getResult(P(p)), D(getFPR(0))));

r:	FP_NEG(pfp0)
31
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.create(IA32_FCHS, myFP0())); \
EMIT(MIR_Move.create(IA32_FSTP, Unary.getResult(P(p)), myFP0()));

##################################
# Basic Long ALU operations 
##################################
#####
# LONG_ADD_ACC
#####
r:	LONG_ADD_ACC(r, rlv)
23
EMIT_INSTRUCTION
LONG_ADD(P(p), BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p)));

#####
# LONG_SUB_ACC
#####
r:	LONG_SUB_ACC(r, rlv)
23
EMIT_INSTRUCTION
LONG_SUB(P(p), BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p)));

#####
# LONG_MUL_ACC
#####
r:	LONG_MUL_ACC(r, rlv)
23
EMIT_INSTRUCTION
LONG_MUL(P(p), BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p)));

#####
# LONG_NEG_ACC
#####
r:	LONG_NEG_ACC(r)
23
EMIT_INSTRUCTION
LONG_NEG(P(p), UnaryAcc.getResult(P(p)));

#####
# LONG_SHL_ACC
#####
r:	LONG_SHL_ACC(r, riv)
20
EMIT_INSTRUCTION
LONG_SHL(P(p));

#####
# LONG_SHR_ACC
#####
r:	LONG_SHR_ACC(r, riv)
20
EMIT_INSTRUCTION
LONG_SHR(P(p));

#####
# LONG_USHR_ACC
#####
r:	LONG_USHR_ACC(r, riv)
20
EMIT_INSTRUCTION
LONG_USHR(P(p));

#####
# LONG_AND_ACC
#####
r:	LONG_AND_ACC(r, rlv)
23
EMIT_INSTRUCTION
LONG_AND(P(p), BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p)));

#####
# LONG_OR_ACC
#####
r:	LONG_OR_ACC(r, rlv)
23
EMIT_INSTRUCTION
LONG_OR(P(p), BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p)));

#####
# LONG_XOR_ACC
#####
r:	LONG_XOR_ACC(r, rlv)
23
EMIT_INSTRUCTION
LONG_XOR(P(p), BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p)));

#####
# LONG_NOT_ACC
#####
r:	LONG_NOT_ACC(r)
23
EMIT_INSTRUCTION
LONG_NOT(P(p), UnaryAcc.getResult(P(p)));

##################################
# Basic Conversion operations
##################################
#####
# INT_2BYTE
#####
r:	INT_2BYTE(r)
32
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, MO_CONV(DW), Unary.getVal(P(p)))); \
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, Unary.getResult(P(p)), MO_CONV(DW)));

r:	INT_2BYTE(load32)
17
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, Unary.getResult(P(p)), consumeMO()));

stm:	BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), B), Unary.getVal(PL(p))));

stm:	BYTE_ASTORE(INT_2BYTE(r),OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), B_S, B), Unary.getVal(PL(p))));

#####
# INT_2USHORT
#####
szpr:	INT_2USHORT(r)
23
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, Unary.getResult(P(p)), Unary.getVal(P(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, Unary.getResult(P(p)), IC(0xFFFF)));

szpr:	INT_2USHORT(load32)
25
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, Unary.getResult(P(p)), consumeMO())); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, Unary.getResult(P(p)), IC(0xFFFF)));

stm:	SHORT_STORE(INT_2USHORT(r), OTHER_OPERAND(riv,riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), Unary.getVal(PL(p))));

stm:	SHORT_ASTORE(INT_2USHORT(r), OTHER_OPERAND(r,riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), Unary.getVal(PL(p))));

#####
# INT_2SHORT
#####
r:	INT_2SHORT(r)
32
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, MO_CONV(DW), Unary.getVal(P(p)))); \
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__W, Unary.getResult(P(p)), MO_CONV(DW)));

r:	INT_2SHORT(load32)
17
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__W, Unary.getResult(P(p)), consumeMO()));

stm:	SHORT_STORE(INT_2SHORT(r), OTHER_OPERAND(riv,riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), Unary.getVal(PL(p))));

stm:	SHORT_ASTORE(INT_2SHORT(r), OTHER_OPERAND(r,riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), Unary.getVal(PL(p))));

#####
# INT_2LONG
#####
r:	INT_2LONG(r)
33
EMIT_INSTRUCTION
INT_2LONG(P(p), Unary.getResult(P(p)), Unary.getVal(P(p))); 

r:	INT_2LONG(load32)
33
EMIT_INSTRUCTION
INT_2LONG(P(p), Unary.getResult(P(p)), consumeMO());

#####
# INT_2FP (handles both float and double; both are 80 bit anyways...)
#####
r:	INT_2FP(riv)
48
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, MO_CONV(DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.create(IA32_FILD, myFP0(), MO_CONV(DW))); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Unary.getResult(P(p)), myFP0()));

fp0:	INT_2FP(riv)
48
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, MO_CONV(DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.create(IA32_FILD, myFP0(), MO_CONV(DW))); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	INT_2FP(riv)
35
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, MO_CONV(DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.create(IA32_FILD, myFP0(), MO_CONV(DW)));

r:	INT_2FP(load32)
33
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FILD, myFP0(), consumeMO())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Unary.getResult(P(p)), myFP0()));

fp0:	INT_2FP(load32)
33
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FILD, myFP0(), consumeMO())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	INT_2FP(load32)
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FILD, myFP0(), consumeMO()));

r:	INT_2FP(INT_CONSTANT)
isONE(VL(p), 31)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLD1, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Unary.getResult(P(p)), myFP0()));

fp0:	INT_2FP(INT_CONSTANT)
isONE(VL(p),31)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLD1, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	INT_2FP(INT_CONSTANT)
isONE(VL(p), 18)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.mutate(P(p), IA32_FLD1, myFP0()));

r:	INT_2FP(INT_CONSTANT)
isZERO(VL(p), 31)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLDZ, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Unary.getResult(P(p)), myFP0()));

fp0:	INT_2FP(INT_CONSTANT)
isZERO(VL(p), 31)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLDZ, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	INT_2FP(INT_CONSTANT)
isZERO(VL(p), 18)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.mutate(P(p), IA32_FLDZ, myFP0()));

#####
# LONG_2FP (handles both float and double; both are 80 bit anyways...)
#####
r:	LONG_2FP(rlv)
53
EMIT_INSTRUCTION
STORE_LONG_FOR_CONV(Unary.getVal(P(p))); \
EMIT(MIR_Move.create(IA32_FILD, myFP0(), MO_CONV(QW))); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Unary.getResult(P(p)), myFP0()));

fp0:	LONG_2FP(rlv)
53
EMIT_INSTRUCTION
STORE_LONG_FOR_CONV(Unary.getVal(P(p))); \
EMIT(MIR_Move.create(IA32_FILD, myFP0(), MO_CONV(QW))); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	LONG_2FP(rlv)
50
EMIT_INSTRUCTION
STORE_LONG_FOR_CONV(Unary.getVal(P(p))); \
EMIT(MIR_Move.create(IA32_FILD, myFP0(), MO_CONV(QW)));

r:	LONG_2FP(load64)
33
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FILD, myFP0(), consumeMO())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Unary.getResult(P(p)), myFP0()));

fp0:	LONG_2FP(load64)
33
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FILD, myFP0(), consumeMO())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	LONG_2FP(load64)
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FILD, myFP0(), consumeMO()));

#####
# LONG_2INT
#####
r:	LONG_2INT(r)
13
EMIT_INSTRUCTION
OPT_Register lh = regpool.getSecondReg(R(Unary.getVal(P(p))).register); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), new OPT_RegisterOperand(lh, VM_TypeReference.Int)));

stm:	INT_STORE(LONG_2INT(r), OTHER_OPERAND(riv,riv))
15
EMIT_INSTRUCTION
OPT_Register lh = regpool.getSecondReg(R(Unary.getVal(PL(p))).register); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), DW), new OPT_RegisterOperand(lh, VM_TypeReference.Int)));

stm:	INT_ASTORE(LONG_2INT(r), OTHER_OPERAND(r,riv))
15
EMIT_INSTRUCTION
OPT_Register lh = regpool.getSecondReg(R(Unary.getVal(PL(p))).register); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), DW_S, DW), new OPT_RegisterOperand(lh, VM_TypeReference.Int)));

r:	LONG_2INT(load64)
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), consumeMO()));

#####
# FLOAT_2INT
#####
r:	FLOAT_2INT(r)
30
EMIT_INSTRUCTION
FPR_2INT(P(p), Unary.getResult(P(p)), Unary.getVal(P(p)));

r:	FLOAT_2INT(fp0)
30
EMIT_INSTRUCTION
FPR_2INT(P(p), Unary.getResult(P(p)), D(getFPR(0)));

r:	FLOAT_2INT(pfp0)
30
EMIT_INSTRUCTION
FPR_2INT(P(p), Unary.getResult(P(p)), myFP0());

r:	FLOAT_2INT(fpload)
30
EMIT_INSTRUCTION
FPR_2INT(P(p), Unary.getResult(P(p)), consumeMO());

#####
# FLOAT_2DOUBLE
#####
r:	FLOAT_2DOUBLE(r)
p.child1.isREGISTERNode()?30:13
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Unary.getResult(P(p)), Unary.getVal(P(p))));

r:	FLOAT_2DOUBLE(fp0)
13
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Unary.getResult(P(p)), D(getFPR(0))));

r:	FLOAT_2DOUBLE(pfp0)
18
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Unary.getResult(P(p)), myFP0()));

fp0:	FLOAT_2DOUBLE(pfp0)
18
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

fp0:	FLOAT_2DOUBLE(fp0)
0
NOFLAGS
// nothing to do

pfp0:	FLOAT_2DOUBLE(pfp0)
0
NOFLAGS
// nothing to do

#####
# DOUBLE_2INT
#####
r:	DOUBLE_2INT(r)
30
EMIT_INSTRUCTION
FPR_2INT(P(p), Unary.getResult(P(p)), Unary.getVal(P(p)));

r:	DOUBLE_2INT(fp0)
30
EMIT_INSTRUCTION
FPR_2INT(P(p), Unary.getResult(P(p)), D(getFPR(0)));

r:	DOUBLE_2INT(pfp0)
30
EMIT_INSTRUCTION
FPR_2INT(P(p), Unary.getResult(P(p)), myFP0());

r:	DOUBLE_2INT(fpload)
30
EMIT_INSTRUCTION
FPR_2INT(P(p), Unary.getResult(P(p)), consumeMO());

#####
# DOUBLE_2FLOAT
#####
r:	DOUBLE_2FLOAT(r)
45
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, MO_CONV(DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Unary.getResult(P(p)), MO_CONV(DW)));

r:	DOUBLE_2FLOAT(fp0)
45
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, MO_CONV(DW), D(getFPR(0)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Unary.getResult(P(p)), MO_CONV(DW)));

r:	DOUBLE_2FLOAT(pfp0)
50
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FSTP, MO_CONV(DW), myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Unary.getResult(P(p)), MO_CONV(DW)));

fp0:	DOUBLE_2FLOAT(r)
45
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, MO_CONV(DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, F(getFPR(0)), MO_CONV(DW)));

fp0:	DOUBLE_2FLOAT(fp0)
45
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, MO_CONV(DW), F(getFPR(0)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, F(getFPR(0)), MO_CONV(DW)));

fp0:	DOUBLE_2FLOAT(pfp0)
50
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FSTP, MO_CONV(DW), myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, F(getFPR(0)), MO_CONV(DW)));

pfp0:	DOUBLE_2FLOAT(r)
35
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, MO_CONV(DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_CONV(DW)));

pfp0:	DOUBLE_2FLOAT(fp0)
35
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, MO_CONV(DW), F(getFPR(0)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_CONV(DW)));

pfp0:	DOUBLE_2FLOAT(pfp0)
40
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FSTP, MO_CONV(DW), myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_CONV(DW)));

stm:	FLOAT_STORE(DOUBLE_2FLOAT(r), OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, MO_S(P(p), DW), Unary.getVal(PL(p))));

stm:	FLOAT_ASTORE(DOUBLE_2FLOAT(r), OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, MO_AS(P(p), DW_S, DW), Unary.getVal(PL(p))));

stm:	FLOAT_STORE(DOUBLE_2FLOAT(fp0), OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, MO_S(P(p), DW), D(getFPR(0))));

stm:	FLOAT_ASTORE(DOUBLE_2FLOAT(fp0), OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, MO_AS(P(p), DW_S, DW), D(getFPR(0))));

stm:	FLOAT_STORE(DOUBLE_2FLOAT(pfp0), OTHER_OPERAND(riv, riv))
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, MO_S(P(p), DW), myFP0()));

stm:	FLOAT_ASTORE(DOUBLE_2FLOAT(pfp0), OTHER_OPERAND(r, riv))
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, MO_AS(P(p), DW_S, DW), myFP0()));

#####
# FLOAT_AS_INT_BITS
#####
r:	FLOAT_AS_INT_BITS(r)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, MO_CONV(DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), MO_CONV(DW)));

r:	FLOAT_AS_INT_BITS(fp0)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, MO_CONV(DW), F(getFPR(0)))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), MO_CONV(DW)));

r:	FLOAT_AS_INT_BITS(pfp0)
35
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FSTP, MO_CONV(DW), myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), MO_CONV(DW)));

#####
# DOUBLE_AS_LONG_BITS
#####
# TODO: rules to consume fp0, pfp0, fpload
r:	DOUBLE_AS_LONG_BITS(r)
45
EMIT_INSTRUCTION
FPR2GPR_64(P(p));

#####
# INT_BITS_AS_FLOAT
#####
r:	INT_BITS_AS_FLOAT(riv)
45
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, MO_CONV(DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Unary.getResult(P(p)), MO_CONV(DW)));

fp0:	INT_BITS_AS_FLOAT(riv)
45
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, MO_CONV(DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, F(getFPR(0)), MO_CONV(DW)));

pfp0:	INT_BITS_AS_FLOAT(riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, MO_CONV(DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_CONV(DW)));

r:	INT_BITS_AS_FLOAT(load32)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Unary.getResult(P(p)), consumeMO()));

fp0:	INT_BITS_AS_FLOAT(load32)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, F(getFPR(0)), consumeMO()));

pfp0:	INT_BITS_AS_FLOAT(load32)
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), consumeMO()));

#####
# LONG_BITS_AS_DOUBLE
#####
# TODO: rules to produce fp0, pfp0
#       rules to consume long loads
r:	LONG_BITS_AS_DOUBLE(rlv)
60
EMIT_INSTRUCTION
GPR2FPR_64(P(p));

##################################
# Moves (register to register moves)
##################################
######
# INT_MOVE
######
r:	INT_MOVE(riv)
13
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Move.getResult(P(p)), Move.getVal(P(p))));

# INT_MOVEs can also 'preserve' nonterminals other than r
czr:	INT_MOVE(czr)
11
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Move.getResult(P(p)), Move.getVal(P(p))));

cz:	INT_MOVE(cz)
0
NOFLAGS
//nothing to do

szpr:	INT_MOVE(szpr)
11
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Move.getResult(P(p)), Move.getVal(P(p))));

szp:	INT_MOVE(szp)
0
NOFLAGS
//nothing to do

address1reg:	INT_MOVE(address1reg)
0
NOFLAGS
//nothing to do

address1scaledreg:	INT_MOVE(address1scaledreg)
0
NOFLAGS
//nothing to do

address:	INT_MOVE(address)
0
NOFLAGS
//nothing to do

sload8:	INT_MOVE(sload8)
0
NOFLAGS
//nothing to do

uload8:	INT_MOVE(uload8)
0
NOFLAGS
//nothing to do

load8:	INT_MOVE(load8)
0
NOFLAGS
//nothing to do

sload16: INT_MOVE(sload16)
0
NOFLAGS
//nothing to do

uload16: INT_MOVE(uload16)
0
NOFLAGS
//nothing to do

load16:	INT_MOVE(load16)
0
NOFLAGS
//nothing to do

load32:	INT_MOVE(load32)
0
NOFLAGS
// nothing to do

load64:	LONG_MOVE(load64)
0
NOFLAGS
// nothing to do

######
# FLOAT_MOVE
######
r:	FLOAT_MOVE(r)
p.child1.isREGISTERNode()?30:13
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Move.getResult(P(p)), Move.getVal(P(p))));

r:	FLOAT_MOVE(fp0)
13
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Move.getResult(P(p)), F(getFPR(0))));

r:	FLOAT_MOVE(pfp0)
18
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Move.getResult(P(p)), myFP0()));

fpload:	FLOAT_MOVE(fpload)
0
NOFLAGS
// nothing to do

fp0:	FLOAT_MOVE(fp0)
0
NOFLAGS
// nothing to do

pfp0:	FLOAT_MOVE(pfp0)
0
NOFLAGS
// nothing to do

fp0:	FLOAT_MOVE(pfp0)
18
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, F(getFPR(0)), myFP0()));

fpload:	FLOAT_MOVE(fpload)
0
NOFLAGS
// nothing to do

######
# DOUBLE_MOVE
######
r:	DOUBLE_MOVE(r)
p.child1.isREGISTERNode()?30:13
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Move.getResult(P(p)), Move.getVal(P(p))));

r:	DOUBLE_MOVE(fp0)
13
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Move.getResult(P(p)), D(getFPR(0))));

r:	DOUBLE_MOVE(pfp0)
18
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Move.getResult(P(p)), myFP0()));

fpload:	DOUBLE_MOVE(fpload)
0
NOFLAGS
// nothing to do

fp0:	DOUBLE_MOVE(fp0)
13
NOFLAGS
// nothing to do

pfp0:	DOUBLE_MOVE(pfp0)
0
NOFLAGS
// nothing to do

fp0:	DOUBLE_MOVE(pfp0)
18
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

fpload:	DOUBLE_MOVE(fpload)
0
NOFLAGS
// nothing to do

#####
# LONG_MOVE
#####
r:	LONG_MOVE(r)
23
EMIT_INSTRUCTION
OPT_Register res1 = Move.getResult(P(p)).register;           \
OPT_Register res2 = regpool.getSecondReg(res1);              \
OPT_Register val1 = Move.getVal(P(p)).asRegister().register; \
OPT_Register val2 = regpool.getSecondReg(val1);              \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, new OPT_RegisterOperand(res1, VM_TypeReference.Int), \
                     new OPT_RegisterOperand(val1, VM_TypeReference.Int)));               \
EMIT(MIR_Move.create(IA32_MOV, new OPT_RegisterOperand(res2, VM_TypeReference.Int),       \
                     new OPT_RegisterOperand(val2, VM_TypeReference.Int)));

r:	LONG_MOVE(LONG_CONSTANT)
21
EMIT_INSTRUCTION
OPT_Register res1 = Move.getResult(P(p)).register;   \
OPT_Register res2 = regpool.getSecondReg(res1);      \
OPT_LongConstantOperand val = LC(Move.getVal(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, new OPT_RegisterOperand(res1, VM_TypeReference.Int), IC(val.upper32()))); \
EMIT(MIR_Move.create(IA32_MOV, new OPT_RegisterOperand(res2, VM_TypeReference.Int), IC(val.lower32())));

##################################
# Loads (memory to register moves)
##################################
#####
# GET_CURRENT_PROCESSOR (TODO: generalize)
#####
r:	GET_CURRENT_PROCESSOR
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Nullary.getResult(P(p)), new OPT_RegisterOperand(getESI(), VM_TypeReference.Int)));

#####
# GET_JTOC
#####
r:	GET_JTOC(r)
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), \
                     MO_BD(Unary.getVal(P(p)), VM_Entrypoints.jtocField.getOffset(), DW, null, null)));

#####
# BYTE_LOAD
#####
r:	BYTE_LOAD(riv, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, Load.getResult(P(p)), MO_L(P(p), B)));

#####
# BYTE_ALOAD
#####
r:	BYTE_ALOAD(r, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, ALoad.getResult(P(p)), MO_AL(P(p), B_S, B)));

#####
# UBYTE_LOAD
#####
r:	UBYTE_LOAD(riv, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__B, Load.getResult(P(p)), MO_L(P(p), B)));

#####
# UBYTE_ALOAD
#####
r:	UBYTE_ALOAD(r, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__B, ALoad.getResult(P(p)), MO_AL(P(p), B_S, B)));

#####
# other load8 patterns
#####
# load8 & 0xff ===> uload8
r:	INT_AND_ACC(load8, INT_CONSTANT)
VR(p) == 0xff ? 15 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__B, BinaryAcc.getResult(P(p)), consumeMO()));

# load8 & 0x000000ab ===> uload8 & 0x000000ab
r:	INT_AND_ACC(load8, INT_CONSTANT)
IC(BinaryAcc.getValue(P(p))).upper24() == 0?25:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.create(IA32_MOVZX__B, BinaryAcc.getResult(P(p)), consumeMO())); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, BinaryAcc.getResult(P(p)).copyD2D(), BinaryAcc.getValue(P(p))));

# load8 << 24 >>> 24 ===> uload8
r:	INT_USHR_ACC(INT_MOVE(INT_SHL_ACC(load8, INT_CONSTANT)), INT_CONSTANT)
VR(p) == 24 && VLLR(p) == 24 ? 15 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__B, BinaryAcc.getResult(P(p)), consumeMO()));

# load8 << 24 >>> 24 ===> uload8
r:	INT_USHR_ACC(INT_SHL_ACC(load8, INT_CONSTANT), INT_CONSTANT)
VR(p) == 24 && VLR(p) == 24 ? 15 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__B, BinaryAcc.getResult(P(p)), consumeMO()));

# int2byte(load8) ===> sload8
r:	INT_2BYTE(load8)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, Unary.getResult(P(p)), consumeMO()));

#####
# SHORT_LOAD
#####
r:	SHORT_LOAD(riv, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__W, Load.getResult(P(p)), MO_L(P(p), W)));

#####
# SHORT_ALOAD
#####
r:	SHORT_ALOAD(r, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__W, ALoad.getResult(P(p)), MO_AL(P(p), W_S, W)));

#####
# USHORT_LOAD
#####
r:	USHORT_LOAD(riv, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, Load.getResult(P(p)), MO_L(P(p), W)));

#####
# USHORT_ALOAD
#####
r:	USHORT_ALOAD(r, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, ALoad.getResult(P(p)), MO_AL(P(p), W_S, W)));

#####
# other load16 patterns
#####
# load16 & 0xffff ===> uload16
r:	INT_AND_ACC(load16, INT_CONSTANT)
VR(p) == 0xffff ? 15 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, BinaryAcc.getResult(P(p)), consumeMO()));

# load16 & 0x0000abcd ===> uload16 & 0x0000abcd
r:	INT_AND_ACC(load16, INT_CONSTANT)
IC(BinaryAcc.getValue(P(p))).upper16() == 0 ? 25 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.create(IA32_MOVZX__W, BinaryAcc.getResult(P(p)), consumeMO())); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, BinaryAcc.getResult(P(p)).copyD2D(), BinaryAcc.getValue(P(p))));

# load16 << 16 >>> 16 ===> uload16 (_201_compress)
r:	INT_USHR_ACC(INT_MOVE(INT_SHL_ACC(load16, INT_CONSTANT)), INT_CONSTANT)
VR(p) == 16 && VLLR(p) == 16 ? 15 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, BinaryAcc.getResult(P(p)), consumeMO()));

# load16 << 16 >>> 16 ===> uload16 (_201_compress)
r:	INT_USHR_ACC(INT_SHL_ACC(load16, INT_CONSTANT), INT_CONSTANT)
VR(p) == 16 && VLR(p) == 16 ? 15 : INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, BinaryAcc.getResult(P(p)), consumeMO()));

# int2ushort(load16) ===> uload16
r:	INT_2USHORT(load16)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, Unary.getResult(P(p)), consumeMO()));

# int2short(load16) ===> sload16
r:	INT_2USHORT(load16)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__W, Unary.getResult(P(p)), consumeMO()));

#####
# INT_LOAD
# A few more cases than for other load operators to handle pointer arithmetic introduced by use of magic
#####
r:	INT_LOAD(riv, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), MO_L(P(p), DW)));

r:	INT_LOAD(riv, address1scaledreg)
15
EMIT_INSTRUCTION
augmentAddress(Load.getAddress(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), \
		     consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	INT_LOAD(address1scaledreg, riv)
15
EMIT_INSTRUCTION
augmentAddress(Load.getOffset(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), \
	             consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	INT_LOAD(address1scaledreg, address1reg)
15
EMIT_INSTRUCTION
combineAddresses(); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), \
	             consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	INT_LOAD(address1reg, address1scaledreg)
15
EMIT_INSTRUCTION
combineAddresses(); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), \
	             consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	INT_LOAD(address, INT_CONSTANT)
15
EMIT_INSTRUCTION
augmentAddress(Load.getOffset(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), \
	             consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));

#####
#INT_ALOAD
#####
r:	INT_ALOAD(r, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, ALoad.getResult(P(p)), MO_AL(P(p), DW_S, DW)));

#####
# FLOAT_LOAD
#####
r:	FLOAT_LOAD(riv, riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Load.getResult(P(p)), MO_L(P(p), DW)));

fp0:	FLOAT_LOAD(riv, riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, F(getFPR(0)), MO_L(P(p), DW)));

pfp0:	FLOAT_LOAD(riv, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_L(P(p), DW)));

#####
# FLOAT_ALOAD
#####
r:	FLOAT_ALOAD(r, riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, ALoad.getResult(P(p)), MO_AL(P(p), DW_S, DW)));

fp0:	FLOAT_ALOAD(r, riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, F(getFPR(0)), MO_AL(P(p), DW_S, DW)));

pfp0:	FLOAT_ALOAD(r, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_AL(P(p), DW_S, DW)));

#####
# LONG_LOAD
#####
r:	LONG_LOAD(riv, riv)
30
EMIT_INSTRUCTION
OPT_RegisterOperand hres = Load.getResult(P(p)); \
OPT_RegisterOperand lres = new OPT_RegisterOperand(regpool.getSecondReg(hres.register), VM_TypeReference.Int); \
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, hres, MO_L(P(p), DW, DW).copy()))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, lres, MO_L(P(p), DW)));

#####
# LONG_ALOAD
#####
r:	LONG_ALOAD(r, riv)
30
EMIT_INSTRUCTION
OPT_RegisterOperand hres = ALoad.getResult(P(p)); \
OPT_RegisterOperand lres = new OPT_RegisterOperand(regpool.getSecondReg(hres.register), VM_TypeReference.Int); \
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, hres, MO_AL(P(p), QW_S, DW, DW).copy()))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, lres, MO_AL(P(p), QW_S, DW)));

#####
# DOUBLE_LOAD
#####
r:	DOUBLE_LOAD(riv, riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Load.getResult(P(p)), MO_L(P(p), QW)));

fp0:	DOUBLE_LOAD(riv, riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, D(getFPR(0)), MO_L(P(p), QW)));

pfp0:	DOUBLE_LOAD(riv, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_L(P(p), QW)));

#####
# DOUBLE_ALOAD
#####
r:	DOUBLE_ALOAD(r, riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, ALoad.getResult(P(p)), MO_AL(P(p), QW_S, QW)));

fp0:	DOUBLE_ALOAD(r, riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, D(getFPR(0)), MO_AL(P(p), QW_S, QW)));

pfp0:	DOUBLE_ALOAD(r, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_AL(P(p), QW_S, QW)));

#####
# PREPARE_INT (just a normal load on IA32)
#####
r:	PREPARE_INT(riv, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \
	             MO(Prepare.getAddress(P(p)), Prepare.getOffset(P(p)), DW, \
	                Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE_INT(r, address1scaledreg)
15
EMIT_INSTRUCTION
augmentAddress(Prepare.getAddress(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \
		     consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE_INT(address1scaledreg, r)
15
EMIT_INSTRUCTION
augmentAddress(Prepare.getOffset(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \
	             consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE_INT(address1scaledreg, address1reg)
15
EMIT_INSTRUCTION
combineAddresses(); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \
	             consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE_INT(address1reg, address1scaledreg)
15
EMIT_INSTRUCTION
combineAddresses(); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \
	             consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE_INT(address, INT_CONSTANT)
15
EMIT_INSTRUCTION
augmentAddress(Prepare.getOffset(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \
	             consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE_INT(INT_CONSTANT, address)
15
EMIT_INSTRUCTION
augmentAddress(Prepare.getAddress(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \
	             consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

##################################
# Stores (register to memory moves)
##################################
#####
# Attempt (atomic compare-exchange)
#####
r:	ATTEMPT_INT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
ATTEMPT(Attempt.getResult(P(p)), \
              MO(Attempt.getAddress(P(p)), Attempt.getOffset(P(p)), DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT_INT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(P(p))); \
ATTEMPT(Attempt.getResult(P(p)), \
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(P(p))); \
ATTEMPT(Attempt.getResult(P(p)), \
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
combineAddresses(); \
ATTEMPT(Attempt.getResult(P(p)), \
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT_INT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
combineAddresses(); \
ATTEMPT(Attempt.getResult(P(p)), \
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT_INT(address, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(P(p))); \
ATTEMPT(Attempt.getResult(P(p)), \
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT_INT(INT_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(P(p))); \
ATTEMPT(Attempt.getResult(P(p)), \
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isZERO(VR(p), 54)
EMIT_INSTRUCTION
ATTEMPT_IFCMP(MO(Attempt.getAddress(PL(p)), Attempt.getOffset(PL(p)), DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isZERO(VR(p), 54)
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(PL(p))); \
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isZERO(VR(p), 54)
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(PL(p))); \
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isZERO(VR(p),54)
EMIT_INSTRUCTION
combineAddresses(); \
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isZERO(VR(p),54)
EMIT_INSTRUCTION
combineAddresses(); \
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(address, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isZERO(VR(p), 54)
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(PL(p))); \
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(INT_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isZERO(VR(p),54)
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(PL(p))); \
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv,riv))), INT_CONSTANT)
isONE(VR(p), 54)
EMIT_INSTRUCTION
ATTEMPT_IFCMP(MO(Attempt.getAddress(PL(p)), Attempt.getOffset(PL(p)), DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isONE(VR(p), 54)
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(PL(p))); \
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isONE(VR(p), 54)
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(PL(p))); \
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isONE(VR(p), 54)
EMIT_INSTRUCTION
combineAddresses(); \
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isONE(VR(p), 54)
EMIT_INSTRUCTION
combineAddresses(); \
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(address, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isONE(VR(p), 54)
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(PL(p))); \
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT_INT(INT_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
isONE(VR(p), 54)
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(PL(p))); \
ATTEMPT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

#####
# BYTE_STORE
#####
stm:	BYTE_STORE(riv, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), B), Store.getValue(P(p))));

# Can avoid sign/zero extension when we are just doing a transfer of bits 
# from one memory location to another.
stm:	BYTE_STORE(load8, OTHER_OPERAND(riv, riv))
25
EMIT_INSTRUCTION
OPT_Register tmp = regpool.getInteger(); \
EMIT(CPOS(PL(p), MIR_Move.create(IA32_MOV, new OPT_RegisterOperand(tmp, VM_TypeReference.Int), consumeMO()))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), B), new OPT_RegisterOperand(tmp, VM_TypeReference.Int)));

#####
# BYTE_ASTORE
#####
stm:	BYTE_ASTORE(riv, OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), B_S, B), AStore.getValue(P(p))));

# Can avoid sign/zero extension when we are just doing a transfer of bits 
# from one memory location to another.
stm:	BYTE_ASTORE(load8, OTHER_OPERAND(r, riv))
25
EMIT_INSTRUCTION
OPT_Register tmp = regpool.getInteger(); \
EMIT(CPOS(PL(p), MIR_Move.create(IA32_MOV, new OPT_RegisterOperand(tmp, VM_TypeReference.Int), consumeMO()))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), B_S, B), new OPT_RegisterOperand(tmp, VM_TypeReference.Int)));

#####
# SHORT_STORE
#####
stm:	SHORT_STORE(riv, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), Store.getValue(P(p))));

# Can avoid sign/zero extension when we are just doing a transfer of bits 
# from one memory location to another.
stm:	SHORT_STORE(load16, OTHER_OPERAND(riv, riv))
25
EMIT_INSTRUCTION
OPT_Register tmp = regpool.getInteger(); \
EMIT(CPOS(PL(p), MIR_Move.create(IA32_MOV, new OPT_RegisterOperand(tmp, VM_TypeReference.Int), consumeMO()))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), new OPT_RegisterOperand(tmp, VM_TypeReference.Int)));

#####
# SHORT_ASTORE
#####
stm:	SHORT_ASTORE(riv, OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), AStore.getValue(P(p))));

# Can avoid sign/zero extension when we are just doing a transfer of bits 
# from one memory location to another.
stm:	SHORT_ASTORE(load16, OTHER_OPERAND(r, riv))
25
EMIT_INSTRUCTION
OPT_Register tmp = regpool.getInteger(); \
EMIT(CPOS(PL(p), MIR_Move.create(IA32_MOV, new OPT_RegisterOperand(tmp, VM_TypeReference.Int), consumeMO()))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), new OPT_RegisterOperand(tmp, VM_TypeReference.Int)));

#####
# INT_STORE
# A few more cases than for other store operators to handle pointer arithmetic introduced by use of magic
#####
stm:	INT_STORE(riv, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), DW), Store.getValue(P(p))));

stm:	INT_STORE(riv, OTHER_OPERAND(riv, address1scaledreg))
15
EMIT_INSTRUCTION
augmentAddress(Store.getAddress(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, \
                     consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), \
		     Store.getValue(P(p))));

stm:	INT_STORE(riv, OTHER_OPERAND(address1scaledreg, riv))
15
EMIT_INSTRUCTION
augmentAddress(Store.getOffset(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, \
                     consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), \
		     Store.getValue(P(p))));

stm:	INT_STORE(riv, OTHER_OPERAND(address1scaledreg, address1reg))
15
EMIT_INSTRUCTION
combineAddresses(); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV,  \
                    consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), \
                    Store.getValue(P(p))));

stm:	INT_STORE(riv, OTHER_OPERAND(address1reg, address1scaledreg))
15
EMIT_INSTRUCTION
combineAddresses(); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV,  \
                    consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), \
                    Store.getValue(P(p))));

stm:	INT_STORE(riv, OTHER_OPERAND(address, INT_CONSTANT))
15
EMIT_INSTRUCTION
augmentAddress(Store.getOffset(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV,  \
	             consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), \
		     Store.getValue(P(p))));

#####
# INT_ASTORE
#####
stm:	INT_ASTORE(riv, OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p))));

#####
# FLOAT_STORE
#####
stm:	FLOAT_STORE(r, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, MO_S(P(p), DW), Store.getValue(P(p))));

stm:	FLOAT_STORE(fp0, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Move.mutate(P(p), IA32_FST, MO_S(P(p), DW), F(getFPR(0))));

stm:	FLOAT_STORE(pfp0, OTHER_OPERAND(riv, riv))
20
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, MO_S(P(p), DW), myFP0()));

#####
# FLOAT_ASTORE
#####
stm:	FLOAT_ASTORE(r, OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p))));

stm:	FLOAT_ASTORE(fp0, OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Move.mutate(P(p), IA32_FST, MO_AS(P(p), DW_S, DW), F(getFPR(0))));

stm:	FLOAT_ASTORE(pfp0, OTHER_OPERAND(r, riv))
20
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, MO_AS(P(p), DW_S, DW), myFP0()));

#####
# LONG_STORE
#####
stm:	LONG_STORE(r, OTHER_OPERAND(riv, riv))
30
EMIT_INSTRUCTION
OPT_RegisterOperand hval = (OPT_RegisterOperand)Store.getValue(P(p)); \
OPT_RegisterOperand lval = new OPT_RegisterOperand(regpool.getSecondReg(hval.register), VM_TypeReference.Int); \
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_S(P(p), DW, DW).copy(), hval))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), DW), lval));

stm:	LONG_STORE(LONG_CONSTANT, OTHER_OPERAND(riv, riv))
26
EMIT_INSTRUCTION
OPT_LongConstantOperand val = LC(Store.getValue(P(p))); \
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_S(P(p), DW, DW).copy(), IC(val.upper32())))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), DW), IC(val.lower32())));

#####
# LONG_ASTORE
#####
stm:	LONG_ASTORE(r, OTHER_OPERAND(r, riv))
30
EMIT_INSTRUCTION
OPT_RegisterOperand hval = (OPT_RegisterOperand)AStore.getValue(P(p)); \
OPT_RegisterOperand lval = new OPT_RegisterOperand(regpool.getSecondReg(hval.register), VM_TypeReference.Int); \
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_AS(P(p), QW_S, DW, DW).copy(), hval))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), QW_S, DW), lval));

stm:	LONG_ASTORE(LONG_CONSTANT, OTHER_OPERAND(r, riv))
26
EMIT_INSTRUCTION
OPT_LongConstantOperand val = LC(AStore.getValue(P(p))); \
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_AS(P(p), QW_S, DW, DW).copy(), IC(val.upper32())))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), QW_S, DW), IC(val.lower32())));

#####
# DOUBLE_STORE
#####
stm:	DOUBLE_STORE(r, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, MO_S(P(p), QW), Store.getValue(P(p))));

stm:	DOUBLE_STORE(fp0, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Move.mutate(P(p), IA32_FST, MO_S(P(p), QW), D(getFPR(0))));

stm:	DOUBLE_STORE(pfp0, OTHER_OPERAND(riv, riv))
20
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, MO_S(P(p), QW), myFP0()));

#####
# DOUBLE_ASTORE
#####
stm:	DOUBLE_ASTORE(r, OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, MO_AS(P(p), QW_S, QW), AStore.getValue(P(p))));

stm:	DOUBLE_ASTORE(fp0, OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Move.mutate(P(p), IA32_FST, MO_AS(P(p), QW_S, QW), D(getFPR(0))));

stm:	DOUBLE_ASTORE(pfp0, OTHER_OPERAND(r, riv))
20
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, MO_AS(P(p), QW_S, QW), myFP0()));

##################################
# Control flow
##################################
#####
# INT_IFCMP
#####
stm:	INT_IFCMP(r,riv)
26
EMIT_INSTRUCTION
IFCMP(P(p), IfCmp.getVal1(P(p)), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(r, INT_CONSTANT)
VR(p) == 0 && EQ_NE(IfCmp.getCond(P(p)))?24:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.create(IA32_TEST, IfCmp.getVal1(P(p)), IfCmp.getVal1(P(p)).copy())); \
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(IfCmp.getCond(P(p))), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

# Because uload is only used for booleans (0/1) we can get away
# with this for both signed and unsigned loads.
stm:	INT_IFCMP(load8, INT_CONSTANT)
FITS(IfCmp.getVal2(P(p)), 8, 28)
EMIT_INSTRUCTION
IFCMP(P(p), consumeMO(), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)));

# We only use uload8 for boolean values, so if the IR is well-typed,
# then r must contain either 0 or 1 and we can do this.
stm:	INT_IFCMP(uload8, r)
28
EMIT_INSTRUCTION
IFCMP(P(p), consumeMO(), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)));

# We only use uload8 for boolean values, so if the IR is well-typed,
# then r must contain either 0 or 1 and we can do this.
stm:	INT_IFCMP(r, uload8)
28
EMIT_INSTRUCTION
IFCMP(P(p), IfCmp.getVal1(P(p)), consumeMO(), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(sload16, INT_CONSTANT) 
FITS(IfCmp.getVal2(P(p)), 8, 28)
EMIT_INSTRUCTION
IFCMP(P(p), consumeMO(), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(load32, riv)
28
EMIT_INSTRUCTION
IFCMP(P(p), consumeMO(), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(r, load32)
28
EMIT_INSTRUCTION
IFCMP(P(p), IfCmp.getVal1(P(p)), consumeMO(), IfCmp.getCond(P(p)));

# IfCmp(boolcmp, 0/1)
stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
VR(p) == 0 && IfCmp.getCond(P(p)).isNOT_EQUAL()?13:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(consumeCOND()), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
VR(p) == 0 && IfCmp.getCond(P(p)).isEQUAL()?13:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(consumeCOND().flipCode()), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
VR(p) == 1 && IfCmp.getCond(P(p)).isEQUAL()?13:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(consumeCOND()), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
VR(p) == 1 && (IfCmp.getCond(P(p)).isNOT_EQUAL())?26:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(consumeCOND().flipCode()), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

# IfCmp(cz, 0); condition code already set
stm:	INT_IFCMP(cz, INT_CONSTANT)
isZERO(VR(p), 11)
EMIT_INSTRUCTION
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(IfCmp.getCond(P(p))), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

# IfCmp(szp, 0); condition code already set
stm:	INT_IFCMP(szp, INT_CONSTANT)
VR(p) == 0 && EQ_NE(IfCmp.getCond(P(p)))?11:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(IfCmp.getCond(P(p))), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

#####
# INT_IFCMP2: TODO interesting rules
#####
stm:	INT_IFCMP2(r,riv)
26
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, IfCmp2.getVal1(P(p)), IfCmp2.getVal2(P(p))))); \
EMIT(MIR_CondBranch2.mutate(P(p), IA32_JCC2,                                  \
	                    COND(IfCmp2.getCond1(P(p))), IfCmp2.getTarget1(P(p)),IfCmp2.getBranchProfile1(P(p)), \
	                    COND(IfCmp2.getCond2(P(p))), IfCmp2.getTarget2(P(p)), IfCmp2.getBranchProfile2(P(p))));

stm:	INT_IFCMP2(load32,riv)
28
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), IfCmp2.getVal2(P(p))))); \
EMIT(MIR_CondBranch2.mutate(P(p), IA32_JCC2,                                  \
	                    COND(IfCmp2.getCond1(P(p))), IfCmp2.getTarget1(P(p)),IfCmp2.getBranchProfile1(P(p)), \
	                    COND(IfCmp2.getCond2(P(p))), IfCmp2.getTarget2(P(p)), IfCmp2.getBranchProfile2(P(p))));

stm:	INT_IFCMP2(r,load32)
28
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, IfCmp2.getVal1(P(p)), consumeMO()))); \
EMIT(MIR_CondBranch2.mutate(P(p), IA32_JCC2,                                  \
	                    COND(IfCmp2.getCond1(P(p))), IfCmp2.getTarget1(P(p)),IfCmp2.getBranchProfile1(P(p)), \
	                    COND(IfCmp2.getCond2(P(p))), IfCmp2.getTarget2(P(p)), IfCmp2.getBranchProfile2(P(p))));

#####
# LONG_IFCMP
#####
stm:	LONG_IFCMP(rlv,rlv)
30
EMIT_INSTRUCTION
EMIT(P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

#####
# FLOAT_IFCMP
#####
stm:   FLOAT_IFCMP(fp0,r)
30
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:   FLOAT_IFCMP(r,fp0)
30
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:   FLOAT_IFCMP(pfp0,r)
35
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMIP, myFP0(), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:   FLOAT_IFCMP(r,pfp0)
35
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMIP, myFP0(), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:   FLOAT_IFCMP(r,r)
p.child1.isREGISTERNode()?60:43
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:   FLOAT_IFCMP(r,r)
p.child2.isREGISTERNode()?60:43
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

#####
# DOUBLE_IFCMP
#####
stm:   DOUBLE_IFCMP(fp0,r)
30
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:   DOUBLE_IFCMP(r,fp0)
30
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:   DOUBLE_IFCMP(pfp0,r)
35
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMIP, myFP0(), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:   DOUBLE_IFCMP(r,pfp0)
35
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMIP, myFP0(), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:   DOUBLE_IFCMP(r,r)
p.child1.isREGISTERNode()?60:43
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:   DOUBLE_IFCMP(r,r)
p.child2.isREGISTERNode()?60:43
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

#####
# LONG_CMP
#####
r:	LONG_CMP(rlv,rlv)
10*13
EMIT_INSTRUCTION
LONG_CMP(P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

#####
# FLOAT_CMPL
#####
r:	FLOAT_CMPL(r,r)
30
EMIT_INSTRUCTION
threeValueFPCmp(P(p));

#####
# FLOAT_CMPG
#####
r:	FLOAT_CMPG(r,r)
30
EMIT_INSTRUCTION
threeValueFPCmp(P(p));

#####
# DOUBLE_CMPL
#####
r:	DOUBLE_CMPL(r,r)
30
EMIT_INSTRUCTION
threeValueFPCmp(P(p));

#####
# DOUBLE_CMPG
#####
r:	DOUBLE_CMPG(r,r)
30
EMIT_INSTRUCTION
threeValueFPCmp(P(p));

#####
# GOTO
#####
stm:	GOTO
11
EMIT_INSTRUCTION
EMIT(MIR_Branch.mutate(P(p), IA32_JMP, Goto.getTarget(P(p))));

##################################
# Calling convention
##################################
#####
# RET
#####
stm:	RETURN(NULL)
13
EMIT_INSTRUCTION
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, null, null));

stm:	RETURN(INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, Return.getVal(P(p)), null));

stm:	RETURN(r)
13
EMIT_INSTRUCTION
OPT_RegisterOperand ret = R(Return.getVal(P(p)));            \
OPT_RegisterOperand ret2 = null;	                            \
if (ret.type.isLongType()) {                                 \
  ret.type = VM_TypeReference.Int;                           \
  ret2 = new OPT_RegisterOperand(regpool.getSecondReg(ret.register), VM_TypeReference.Int); \
}                                                            \
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, ret, ret2)); 

stm:	RETURN(LONG_CONSTANT)
11
EMIT_INSTRUCTION
OPT_LongConstantOperand val = LC(Return.getVal(P(p))); \
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, IC(val.upper32()), IC(val.lower32())));

stm:	RETURN(fp0)
11
EMIT_INSTRUCTION
OPT_RegisterOperand res = Return.getVal(P(p)).isDouble() ? D(getFPR(0)) : F(getFPR(0)); \
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, res, null));

stm:	RETURN(pfp0)
26
EMIT_INSTRUCTION
OPT_RegisterOperand res = Return.getVal(P(p)).isDouble() ? D(getFPR(0)) : F(getFPR(0)); \
EMIT(MIR_Move.create(IA32_FSTP, res.copy(), myFP0())); \
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, res, null));

#####
# CALL
#####
r:	CALL(r, any)
13
EMIT_INSTRUCTION
CALL(P(p), Call.getAddress(P(p)));

# a recursive call that has been optimized to a branch to entry block
r:	CALL(BRANCH_TARGET, any)
13
EMIT_INSTRUCTION
CALL(P(p), Call.getAddress(P(p)));

r:	CALL(INT_LOAD(riv, riv), any)
11
EMIT_INSTRUCTION
CALL(P(p), MO_L(PL(p), DW));

r:	SYSCALL(r, any)
13
EMIT_INSTRUCTION
SYSCALL(P(p), Call.getAddress(P(p)));

r:	SYSCALL(INT_LOAD(riv, riv), any)
11
EMIT_INSTRUCTION
SYSCALL(P(p), MO_L(PL(p), DW));

###########
# Rules for exceptions
###########
r:      GET_CAUGHT_EXCEPTION
15
EMIT_INSTRUCTION
GET_EXCEPTION_OBJECT(P(p));

stm:      SET_CAUGHT_EXCEPTION(r)
17
EMIT_INSTRUCTION
SET_EXCEPTION_OBJECT(P(p));

###########
# Rules for special registers
###########
stm:      ROUND_TO_ZERO
21
EMIT_INSTRUCTION
ROUND_TO_ZERO(P(p));

stm:      CLEAR_FLOATING_POINT_STATE
1
EMIT_INSTRUCTION
EMIT(MIR_Empty.mutate(P(p), IA32_FNINIT));

#####
# RDTSC
#####
r:      GET_TIME_BASE
15
EMIT_INSTRUCTION
GET_TIME_BASE(P(p), Nullary.getResult(P(p)));

########
# osr instruction
########
stm:	YIELDPOINT_OSR(any, any)
10
EMIT_INSTRUCTION
OSR(burs, P(p));

# Find loads to merge
# merge loads of the form:
# (b[0] & 0xFF) | ((b[1] & 0xFF) << 8) | ((b[2] & 0xFF) << 16 ) | ((b[3] & 0xFF) << 24)
#
#   int_or_acc                              P
#      int_move                             L
#         int_or_acc                        LL
#            int_or_acc                     LLL
#               int_move                    LLLL
#                  int_and_acc              LLLLL
#                     byte_aload            LLLLLL
#                        register           LLLLLLL
#                        INT_CONSTANT 0     LLLLLLR
#                     INT_CONSTANT 255      LLLLLR
#               int_shl_acc                 LLLR
#                  int_move                 LLLRL
#                     int_and_acc           LLLRLL
#                        byte_aload         LLLRLLL
#                           register        LLLRLLLL
#                           INT_CONSTANT 1  LLLRLLLR
#                        INT_CONSTANT 255   LLLRLLR
#                  INT_CONSTANT 8           LLLRR
#            int_shl_acc                    LLR
#               int_move                    LLRL
#                  int_and_acc              LLRLL
#                     byte_aload            LLRLLL
#                        register           LLRLLLL
#                        INT_CONSTANT 2     LLRLLLR
#                     INT_CONSTANT 255      LLRLLR
#               INT_CONSTANT 16             LLRR
#      int_shl_acc                          R
#         int_move                          RL
#            int_and_acc                    RLL
#               byte_aload                  RLLL
#                  register                 RLLLL
#                  INT_CONSTANT 3           RLLLR
#               INT_CONSTANT 255            RLLR
#         INT_CONSTANT 24                   RR
load32: INT_OR_ACC(INT_MOVE(INT_OR_ACC(INT_OR_ACC(INT_MOVE(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT)),INT_SHL_ACC(INT_MOVE(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT)),INT_CONSTANT)),INT_SHL_ACC(INT_MOVE(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT)), INT_CONSTANT))),INT_SHL_ACC(INT_MOVE(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT)),INT_CONSTANT))
(VLLLLLR(p) == 255) && (VLLLRLLR(p) == 255) && (VLLRLLR(p) == 255) && (VLLRLLR(p) == 255) && \
(VRR(p) == 24) && (VLLRR(p) == 16) && (VLLLRR(p) == 8) && \
(VLLLLLLR(p)+1 == VLLLRLLLR(p)) && (VLLLRLLLR(p)+1 == VLLRLLLR(p)) && (VLLRLLLR(p)+1 == VRLLLR(p)) && \
ALoad.getArray(PLLLLLL(p)).similar(ALoad.getArray(PLLLRLLL(p))) && \
ALoad.getArray(PLLLRLLL(p)).similar(ALoad.getArray(PLLRLLL(p))) && \
ALoad.getArray(PLLRLLL(p)).similar(ALoad.getArray(PRLLL(p))) \
? 0:INFINITE
EMIT_INSTRUCTION
pushMO(MO_AL(PLLLLLL(p), B_S, DW));

r: INT_OR_ACC(INT_MOVE(INT_OR_ACC(INT_OR_ACC(INT_MOVE(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT)),INT_SHL_ACC(INT_MOVE(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT)),INT_CONSTANT)),INT_SHL_ACC(INT_MOVE(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT)), INT_CONSTANT))),INT_SHL_ACC(INT_MOVE(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT)),INT_CONSTANT))
(VLLLLLR(p) == 255) && (VLLLRLLR(p) == 255) && (VLLRLLR(p) == 255) && (VLLRLLR(p) == 255) && \
(VRR(p) == 24) && (VLLRR(p) == 16) && (VLLLRR(p) == 8) && \
(VLLLLLLR(p)+1 == VLLLRLLLR(p)) && (VLLLRLLLR(p)+1 == VLLRLLLR(p)) && (VLLRLLLR(p)+1 == VRLLLR(p)) && \
ALoad.getArray(PLLLLLL(p)).similar(ALoad.getArray(PLLLRLLL(p))) && \
ALoad.getArray(PLLLRLLL(p)).similar(ALoad.getArray(PLLRLLL(p))) && \
ALoad.getArray(PLLRLLL(p)).similar(ALoad.getArray(PRLLL(p))) \
? 15:INFINITE
EMIT_INSTRUCTION
pushMO(MO_AL(PLLLLLL(p), B_S, DW)); \
EMIT(MIR_Move.create(IA32_MOV, BinaryAcc.getResult(P(p)), consumeMO()));

# merge loads of the form:
# (b[0] & 0xFF) | ((b[1] & 0xFF) << 8) | ((b[2] & 0xFF) | ((b[3] & 0xFF) << 8)) << 16
#
#   int_or_acc                             P
#      int_move                            L
#         int_or_acc                       LL
#            int_and_acc                   LLL
#               byte_aload                 LLLL
#                  register                LLLLL
#                  INT_CONSTANT 0          LLLLR
#               INT_CONSTANT 255           LLLR
#            int_shl_acc                   LLR
#               int_move                   LLRL
#                  int_and_acc             LLRLL
#                     byte_aload           LLRLLL
#                        register          LLRLLLL
#                        INT_CONSTANT 1    LLRLLLR
#                     INT_CONSTANT 255     LLRLLR
#               INT_CONSTANT 8             LLRR
#      int_shl_acc                         R
#         int_move                         RL
#            int_or_acc                    RLL
#               int_and_acc                RLLL
#                  byte_aload              RLLLL
#                     register             RLLLLL
#                     INT_CONSTANT 2       RLLLLR
#                  INT_CONSTANT 255        RLLLR
#               int_shl_acc                RLLR
#                  int_move                RLLRL
#                     int_and_acc          RLLRLL
#                        byte_aload        RLLRLLL
#                           register       RLLRLLLL
#                           INT_CONSTANT 3 RLLRLLLR
#                        INT_CONSTANT 255  RLLRLLR
#                  INT_CONSTANT 8          RLLRR
#         INT_CONSTANT 16                  RR
load32: INT_OR_ACC(INT_MOVE(INT_OR_ACC(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT),INT_SHL_ACC(INT_MOVE(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT)),INT_CONSTANT))),INT_SHL_ACC(INT_MOVE(INT_OR_ACC(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT),INT_SHL_ACC(INT_MOVE(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT)),INT_CONSTANT))),INT_CONSTANT))
(VLLLR(p) == 255) && (VLLRLLR(p) == 255) && (VRLLLR(p) == 255) && (VRLLRLLR(p) == 255) && \
(VLLRR(p) == 8) && (VRLLRR(p) == 8) && (VRR(p) == 16) && \
(VLLLLR(p)+1 == VLLRLLLR(p)) && (VLLRLLLR(p)+1 == VRLLLLR(p)) && (VRLLLLR(p)+1 == VRLLRLLLR(p)) && \
ALoad.getArray(PLLLL(p)).similar(ALoad.getArray(PLLRLLL(p))) && \
ALoad.getArray(PLLRLLL(p)).similar(ALoad.getArray(PRLLLL(p))) && \
ALoad.getArray(PRLLLL(p)).similar(ALoad.getArray(PRLLRLLL(p))) \
? 28:INFINITE
EMIT_INSTRUCTION
pushMO(MO_AL(PLLLL(p), B_S, DW));

r: INT_OR_ACC(INT_MOVE(INT_OR_ACC(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT),INT_SHL_ACC(INT_MOVE(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT)),INT_CONSTANT))),INT_SHL_ACC(INT_MOVE(INT_OR_ACC(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT),INT_SHL_ACC(INT_MOVE(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT)),INT_CONSTANT))),INT_CONSTANT))
(VLLLR(p) == 255) && (VLLRLLR(p) == 255) && (VRLLLR(p) == 255) && (VRLLRLLR(p) == 255) && \
(VLLRR(p) == 8) && (VRLLRR(p) == 8) && (VRR(p) == 16) && \
(VLLLLR(p)+1 == VLLRLLLR(p)) && (VLLRLLLR(p)+1 == VRLLLLR(p)) && (VRLLLLR(p)+1 == VRLLRLLLR(p)) && \
ALoad.getArray(PLLLL(p)).similar(ALoad.getArray(PLLRLLL(p))) && \
ALoad.getArray(PLLRLLL(p)).similar(ALoad.getArray(PRLLLL(p))) && \
ALoad.getArray(PRLLLL(p)).similar(ALoad.getArray(PRLLRLLL(p))) \
? 28:INFINITE
EMIT_INSTRUCTION
pushMO(MO_AL(PLLLL(p), B_S, DW)); \
EMIT(MIR_Move.create(IA32_MOV, BinaryAcc.getResult(P(p)), consumeMO()));

# Find byte swaps:
# byteswap of the form:
# ((b[0] & 0xFF) << 24) | ((b[1] & 0xFF) << 16) | ((b[2] & 0xFF) << 8 ) | (b[3] & 0xFF)
#
#   int_or_acc
#      int_move                              L
#         int_or_acc                         LL
#            int_or_acc                      LLL
#               int_move                     LLLL
#                  int_shl_acc               LLLLL
#                     int_and_acc            LLLLLL
#                        byte_aload          LLLLLLL
#                           register         LLLLLLLL
#                           INT_CONSTANT 0   LLLLLLLR
#                        INT_CONSTANT 255    LLLLLLR
#                     INT_CONSTANT 24        LLLLLR
#               int_shl_acc                  LLLR
#                  int_move                  LLLRL
#                     int_and_acc            LLLRLL
#                        byte_aload          LLLRLLL
#                           register         LLLRLLLL
#                           INT_CONSTANT 1   LLLRLLLR
#                        INT_CONSTANT 255    LLLRLLR
#                  INT_CONSTANT 16           LLLRR
#            int_shl_acc                     LLR
#               int_move                     LLRL
#                  int_and_acc               LLRLL
#                     byte_aload             LLRLLL
#                        register            LLRLLLL
#                        INT_CONSTANT 2      LLRLLLR
#                     INT_CONSTANT 255       LLRLLR
#               INT_CONSTANT 8               LLRR
#      int_and_acc                           R
#         byte_aload                         RL
#            register                        RLL
#            INT_CONSTANT 3                  RLR
#         INT_CONSTANT 255                   RR
r: INT_OR_ACC(INT_MOVE(INT_OR_ACC(INT_OR_ACC(INT_MOVE(INT_SHL_ACC(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT),INT_CONSTANT)),INT_SHL_ACC(INT_MOVE(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT)),INT_CONSTANT)),INT_SHL_ACC(INT_MOVE(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT)),INT_CONSTANT))),INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT))
(VLLLLLLR(p) == 255) && (VLLLRLLR(p) == 255) && (VLLRLLR(p) == 255) && (VRR(p) == 255) && \
(VLLLLLR(p) == 24) && (VLLLRR(p) == 16) && (VLLRR(p) == 8) && \
(VLLLLLLLR(p)+1 == VLLLRLLLR(p)) && (VLLLRLLLR(p)+1 == VLLRLLLR(p)) && (VLLRLLLR(p)+1 == VRLR(p)) && \
ALoad.getArray(PLLLLLLL(p)).similar(ALoad.getArray(PLLLRLLL(p))) && \
ALoad.getArray(PLLLRLLL(p)).similar(ALoad.getArray(PLLRLLL(p))) && \
ALoad.getArray(PLLRLLL(p)).similar(ALoad.getArray(PRL(p))) \
? 28:INFINITE
EMIT_INSTRUCTION
pushMO(MO_AL(PLLLLLLL(p), B_S, DW)); \
EMIT(MIR_Move.create(IA32_MOV, BinaryAcc.getResult(P(p)), consumeMO())); \
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_BSWAP, BinaryAcc.getResult(P(p))));

# byteswap of the form:
# ((((b[0] & 0xFF) << 8) | (b[1] & 0xFF)) << 16) | ((b[2] & 0xFF) << 8 ) | (b[3] & 0xFF)
#
#   int_or_acc                              P
#      int_move                             L
#         int_shl_acc                       LL
#            int_or_acc                     LLL
#               int_move                    LLLL
#                  int_shl_acc              LLLLL
#                     int_and_acc           LLLLLL
#                        byte_aload         LLLLLLL
#                           register        LLLLLLLL
#                           INT_CONSTANT 0  LLLLLLLR
#                        INT_CONSTANT 255   LLLLLLR
#                     INT_CONSTANT 8        LLLLLR
#               int_and_acc                 LLLR
#                  byte_aload               LLLRL
#                     register              LLLRLL
#                     INT_CONSTANT 1        LLLRLR
#                  INT_CONSTANT 255         LLLRR
#            INT_CONSTANT 16                LLR
#      int_or_acc                           R
#         int_move                          RL
#            int_shl_acc                    RLL
#               int_and_acc                 RLLL
#                  byte_aload               RLLLL
#                     register              RLLLLL
#                     INT_CONSTANT 2        RLLLLR
#                  INT_CONSTANT 255         RLLLR
#               INT_CONSTANT 8              RLLR
#         int_and_acc                       RR
#            byte_aload                     RRL
#               register                    RRLL
#               INT_CONSTANT 3              RRLR
#            INT_CONSTANT 255               RRR
r: INT_OR_ACC(INT_MOVE(INT_SHL_ACC(INT_OR_ACC(INT_MOVE(INT_SHL_ACC(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT),INT_CONSTANT)),INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT)),INT_CONSTANT)),INT_OR_ACC(INT_MOVE(INT_SHL_ACC(INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT),INT_CONSTANT)),INT_AND_ACC(BYTE_ALOAD(r,INT_CONSTANT),INT_CONSTANT)))
(VLLLLLLR(p) == 255) && (VLLLRR(p) == 255) && (VRLLLR(p) == 255) && (VRRR(p) == 255) && \
(VLLLLLR(p) == 8) && (VLLR(p) == 16) && (VRLLR(p) == 8) && \
(VLLLLLLLR(p)+1 == VLLLRLR(p)) && (VLLLRLR(p)+1 == VRLLLLR(p)) && (VRLLLLR(p)+1 == VRRLR(p)) && \
ALoad.getArray(PLLLLLLL(p)).similar(ALoad.getArray(PLLLRL(p))) && \
ALoad.getArray(PLLLRL(p)).similar(ALoad.getArray(PRLLLL(p))) && \
ALoad.getArray(PRLLLL(p)).similar(ALoad.getArray(PRRL(p))) \
? 28:INFINITE
EMIT_INSTRUCTION
pushMO(MO_AL(PLLLLLLL(p), B_S, DW)); \
EMIT(MIR_Move.create(IA32_MOV, BinaryAcc.getResult(P(p)), consumeMO())); \
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_BSWAP, BinaryAcc.getResult(P(p))));

# byteswap of the form:
# ((x & 0xFF) << 24) | ((x & 0xFF00) << 8) | ((x & 0xFF0000) >> 8) | (x >>> 24)
#
#   int_or_acc                              P
#      int_move                             L
#         int_or_acc                        LL
#            int_or_acc                     LLL
#               int_move                    LLLL
#                  int_shl_acc              LLLLL
#                     int_and_acc           LLLLLL
#                        register           LLLLLLL
#                        INT_CONSTANT 255   LLLLLLR
#                     INT_CONSTANT 24       LLLLLR
#               int_shl_acc                 LLLR
#                  int_and_acc              LLLRL
#                     register              LLLRLL
#                     INT_CONSTANT 65280    LLLRLR
#                  INT_CONSTANT 8           LLLRR
#            int_shr_acc                    LLR
#               int_and_acc                 LLRL
#                  register                 LLRLL
#                  INT_CONSTANT 16711680    LLRLR
#               INT_CONSTANT 8              LLRR
#      int_ushr_acc                         R
#         register                          RL
#         INT_CONSTANT 24                   RR
r: INT_OR_ACC(INT_MOVE(INT_OR_ACC(INT_OR_ACC(INT_MOVE(INT_SHL_ACC(INT_AND_ACC(r,INT_CONSTANT),INT_CONSTANT)),INT_SHL_ACC(INT_AND_ACC(r,INT_CONSTANT),INT_CONSTANT)),INT_SHR_ACC(INT_AND_ACC(r,INT_CONSTANT),INT_CONSTANT))),INT_USHR_ACC(r,INT_CONSTANT))
(VLLLLLLR(p) == 0xFF) && (VLLLRLR(p) == 0xFF00) && (VLLRLR(p) == 0xFF0000) && \
(VLLLLLR(p) == 24) && (VLLLRR(p) == 8) && (VLLRR(p) == 8) && (VRR(p) == 24) && \
follow(BinaryAcc.getResult(PLLLLLL(p))).similar(follow(BinaryAcc.getResult(PLLLRL(p)))) && \
follow(BinaryAcc.getResult(PLLLLLL(p))).similar(follow(BinaryAcc.getResult(PLLRL(p)))) && \
follow(BinaryAcc.getResult(PLLLLLL(p))).similar(follow(BinaryAcc.getResult(PR(p)))) \
? 26:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, BinaryAcc.getResult(P(p)), BinaryAcc.getClearValue(PLLLLLL(p)))); \
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_BSWAP, BinaryAcc.getResult(P(p)).copyRO()));

# Find bit test instructions - bt base, offset
# NB bit test sets the carry flag not the zero flag
#   boolean_cmp_int
#      int_and_acc             L
#         register             LL <-- base
#         int_shl_acc          LR
#            int_move          LRL
#               INT_CONSTANT 1 LRLL
#            register          LRR  <-- offset
#      INT_CONSTANT 0          R
r:	BOOLEAN_CMP_INT(INT_AND_ACC(r,INT_SHL_ACC(INT_MOVE(INT_CONSTANT),riv)), INT_CONSTANT)
(VR(p) == 0) && (VLRLL(p) == 1) && EQ_NE(BooleanCmp.getCond(P(p)))? 39:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(PL(p),IA32_BT, BinaryAcc.getResult(PL(p)), BinaryAcc.getValue(PLR(p)))); \
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)).value == OPT_ConditionOperand.EQUAL ? \
                                                  OPT_ConditionOperand.HIGHER_EQUAL() : OPT_ConditionOperand.LOWER());

boolcmp:	BOOLEAN_CMP_INT(INT_AND_ACC(r,INT_SHL_ACC(INT_MOVE(INT_CONSTANT),riv)), INT_CONSTANT)
(VR(p) == 0) && (VLRLL(p) == 1) && EQ_NE(BooleanCmp.getCond(P(p)))? 13:INFINITE
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p)).value == OPT_ConditionOperand.EQUAL ? \
         OPT_ConditionOperand.HIGHER_EQUAL() : OPT_ConditionOperand.LOWER()); \
EMIT(MIR_Test.mutate(PL(p),IA32_BT, BinaryAcc.getResult(PL(p)), BinaryAcc.getValue(PLR(p))));

#   boolean_cmp_int
#      int_and_acc             L
#         int_shl_acc          LL
#            int_move          LLL
#               INT_CONSTANT 1 LLLL
#            register          LLR <-- offset
#         register             LR <-- base
#      INT_CONSTANT 0          R
r:	BOOLEAN_CMP_INT(INT_AND_ACC(INT_SHL_ACC(INT_MOVE(INT_CONSTANT),riv),r), INT_CONSTANT)
(VR(p) == 0) && (VLLLL(p) == 1) && EQ_NE(BooleanCmp.getCond(P(p)))? 39:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(PL(p),IA32_BT, BinaryAcc.getValue(PL(p)), BinaryAcc.getValue(PLL(p)))); \
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)).value == OPT_ConditionOperand.EQUAL ? \
                                                  OPT_ConditionOperand.HIGHER_EQUAL() : OPT_ConditionOperand.LOWER());

boolcmp:	BOOLEAN_CMP_INT(INT_AND_ACC(INT_SHL_ACC(INT_MOVE(INT_CONSTANT),riv),r), INT_CONSTANT)
(VR(p) == 0) && (VLLLL(p) == 1) && EQ_NE(BooleanCmp.getCond(P(p)))? 13:INFINITE
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p)).value == OPT_ConditionOperand.EQUAL ? \
         OPT_ConditionOperand.HIGHER_EQUAL() : OPT_ConditionOperand.LOWER()); \
EMIT(MIR_Test.mutate(PL(p),IA32_BT, BinaryAcc.getValue(PL(p)), BinaryAcc.getValue(PLL(p))));

#   boolean_cmp_int
#      int_and_acc       L
#         int_move       LL
#            int_shr_acc LLL
#               register LLLL <-- base
#               register LLLR <-- offset
#         INT_CONSTANT 1 LR
#      INT_CONSTANT 0    R
r:	BOOLEAN_CMP_INT(INT_AND_ACC(INT_MOVE(INT_SHR_ACC(r,riv)),INT_CONSTANT),INT_CONSTANT)
(VR(p) == 0) && (VLR(p) == 1) && EQ_NE(BooleanCmp.getCond(P(p)))? 39:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(PL(p),IA32_BT, BinaryAcc.getResult(PLLL(p)), BinaryAcc.getValue(PLLL(p)))); \
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)).value == OPT_ConditionOperand.EQUAL ? \
                                                  OPT_ConditionOperand.HIGHER_EQUAL() : OPT_ConditionOperand.LOWER());

boolcmp:	BOOLEAN_CMP_INT(INT_AND_ACC(INT_MOVE(INT_SHR_ACC(r,riv)),INT_CONSTANT),INT_CONSTANT)
(VR(p) == 0) && (VLR(p) == 1) && EQ_NE(BooleanCmp.getCond(P(p)))? 13:INFINITE
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p)).value == OPT_ConditionOperand.EQUAL ? \
         OPT_ConditionOperand.HIGHER_EQUAL() : OPT_ConditionOperand.LOWER()); \
EMIT(MIR_Test.mutate(PL(p),IA32_BT, BinaryAcc.getResult(PLLL(p)), BinaryAcc.getValue(PLLL(p))));

#   boolean_cmp_int
#      int_and_acc       L
#         int_move       LL
#            int_shr_acc LLL
#               register LLLL <-- base
#               register LLLR <-- offset
#         INT_CONSTANT 1 LR
#      INT_CONSTANT 1    R
r:	BOOLEAN_CMP_INT(INT_AND_ACC(INT_MOVE(INT_SHR_ACC(r,riv)),INT_CONSTANT),INT_CONSTANT)
(VR(p) == 1) && (VLR(p) == 1) && EQ_NE(BooleanCmp.getCond(P(p)))? 39:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(PL(p),IA32_BT, BinaryAcc.getResult(PLLL(p)), BinaryAcc.getValue(PLLL(p)))); \
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)).value == OPT_ConditionOperand.NOT_EQUAL ? \
                                                  OPT_ConditionOperand.HIGHER_EQUAL() : OPT_ConditionOperand.LOWER());

boolcmp:	BOOLEAN_CMP_INT(INT_AND_ACC(INT_MOVE(INT_SHR_ACC(r,riv)),INT_CONSTANT),INT_CONSTANT)
(VR(p) == 1) && (VLR(p) == 1) && EQ_NE(BooleanCmp.getCond(P(p)))? 13:INFINITE
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p)).value == OPT_ConditionOperand.NOT_EQUAL ? \
         OPT_ConditionOperand.HIGHER_EQUAL() : OPT_ConditionOperand.LOWER()); \
EMIT(MIR_Test.mutate(PL(p),IA32_BT, BinaryAcc.getResult(PLLL(p)), BinaryAcc.getValue(PLLL(p))));

#   boolean_cmp_int
#      int_and_acc        L
#         int_move        LL
#            int_ushr_acc LLL
#               register  LLLL <-- base
#               register  LLLR <-- offset
#         INT_CONSTANT 1  LR
#      INT_CONSTANT 0     R
r:	BOOLEAN_CMP_INT(INT_AND_ACC(INT_MOVE(INT_USHR_ACC(r,riv)),INT_CONSTANT),INT_CONSTANT)
(VR(p) == 0) && (VLR(p) == 1) && EQ_NE(BooleanCmp.getCond(P(p)))? 39:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(PL(p),IA32_BT, BinaryAcc.getResult(PLLL(p)), BinaryAcc.getValue(PLLL(p)))); \
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)).value == OPT_ConditionOperand.EQUAL ? \
                                                  OPT_ConditionOperand.HIGHER_EQUAL() : OPT_ConditionOperand.LOWER());

boolcmp:	BOOLEAN_CMP_INT(INT_AND_ACC(INT_MOVE(INT_USHR_ACC(r,riv)),INT_CONSTANT),INT_CONSTANT)
(VR(p) == 0) && (VLR(p) == 1) && EQ_NE(BooleanCmp.getCond(P(p)))? 13:INFINITE
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p)).value == OPT_ConditionOperand.EQUAL ? \
         OPT_ConditionOperand.HIGHER_EQUAL() : OPT_ConditionOperand.LOWER()); \
EMIT(MIR_Test.mutate(PL(p),IA32_BT, BinaryAcc.getResult(PLLL(p)), BinaryAcc.getValue(PLLL(p))));

#   boolean_cmp_int
#      int_and_acc        L
#         int_move        LL
#            int_ushr_acc LLL
#               register  LLLL <-- base
#               register  LLLR <-- offset
#         INT_CONSTANT 1  LR
#      INT_CONSTANT 1     R
r:	BOOLEAN_CMP_INT(INT_AND_ACC(INT_MOVE(INT_USHR_ACC(r,riv)),INT_CONSTANT),INT_CONSTANT)
(VR(p) == 1) && (VLR(p) == 1) && EQ_NE(BooleanCmp.getCond(P(p)))? 39:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(PL(p),IA32_BT, BinaryAcc.getResult(PLLL(p)), BinaryAcc.getValue(PLLL(p)))); \
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)).value == OPT_ConditionOperand.NOT_EQUAL ? \
                                                  OPT_ConditionOperand.HIGHER_EQUAL() : OPT_ConditionOperand.LOWER());

boolcmp:	BOOLEAN_CMP_INT(INT_AND_ACC(INT_MOVE(INT_USHR_ACC(r,riv)),INT_CONSTANT),INT_CONSTANT)
(VR(p) == 1) && (VLR(p) == 1) && EQ_NE(BooleanCmp.getCond(P(p)))? 13:INFINITE
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p)).value == OPT_ConditionOperand.NOT_EQUAL ? \
         OPT_ConditionOperand.HIGHER_EQUAL() : OPT_ConditionOperand.LOWER()); \
EMIT(MIR_Test.mutate(PL(p),IA32_BT, BinaryAcc.getResult(PLLL(p)), BinaryAcc.getValue(PLLL(p))));
