/*
 * (C) Copyright IBM Corp. 2001
 */

/**
 * Template for a dictionary of key/value pairs.
 *
 * Key/value pairs may be objects or primitives.
 * They are identified by unique integer id's.
 * A dictionary id of 0 corresponds to a key of null (for objects)
 * or zero (for primitives).
 *
 * The use of integer id's allows us to embed dictionary references 
 * in the machine instructions generated by the compiler.
 * (Embedding direct object references would make it hard for the garbage
 * collector to find and update those references in the machine code,
 * as objects are moved around in memory).
 *
 * Two static methods must be provided external to the dictionary:
 *
 * static int 
 * dictionaryHash(KKK key)
 *    {
 *    return a hashing code for "key"
 *    }
 *
 * static int 
 * dictionaryCompare(KKK leftKey, KKK rightKey)
 *    { 
 *    return  0 iff "leftKey" is null (for objects) or zero (for primitives)
 *    return  1 iff "leftKey" is to be considered a duplicate of "rightKey"
 *    return -1 otherwise
 *    }
 *
 * In this template: 
 *    CCC stands for classname of dictionary
 *    KKK stands for typename of dictionary's keys
 *    VVV stands for typename of dictionary's values
 *    DDD stands for name of class providing dictionaryHash() and dictionaryCompare() methods
 *
 * @author Derek Lieber
 *
 */
class CCC {
  //-----------//
  // interface //
  //-----------//
   
  // Find or create a dictionary key.
  // Taken:    key sought
  //           value to associate with key, if key isn't already in dictionary
  // Returned: id for use by getKey(), setValue(), and getValue()
  //
  static synchronized int findOrCreateId(KKK key, VVV value) {
    // check for null/zero first, so we can later use null/zero as an end of chain sentinal
    if (key == keys[0])
      return 0;
         
    int chainIndex = (DDD.dictionaryHash(key) & 0x7fffffff) % chains.length;
    int[] chain = chains[chainIndex];

    if (chain == null) { 
      // no chain - key not present in dictionary
      if (nextId == keys.length)    // make more
	growDictionary();          // ...space
      keys[nextId] = key;           // add...
      values[nextId] = value;       // ...to dictionary
      chain = new int[50];          // allocate...
      chains[chainIndex] = chain;   // ...hash chain
      chain[0] = nextId;            // add id to hash table
      if (VM.TraceDictionaries) VM.sysWrite("CCC[" + nextId + "]: new key=" + key + " value=" + value + "\n");
      return nextId++;
    }

    for (int i = 0, n = chain.length; i < n; ++i) {
      int candidateId  = chain[i];
      KKK candidateKey = keys[candidateId];
      int rc = DDD.dictionaryCompare(candidateKey, key);
      if (rc == 0) { 
	// candidateKey is end of chain sentinal (null/zero) - key not present in dictionary
	if (nextId == keys.length) // make more
	  growDictionary();       // ...space
	keys[nextId] = key;        // add...
	values[nextId] = value;    // ...to dictionary
	chain[i] = nextId;         // add id to hash table
	if (VM.TraceDictionaries) VM.sysWrite("CCC[" + nextId + "]: new key=" + key + " value=" + value + "\n");
	return nextId++;
      }
      if (rc == 1) { 
	// key already present in dictionary
	if (VM.TraceDictionaries) VM.sysWrite("CCC[" + candidateId + "]: old key=" + key + " value=" + values[candidateId] + "\n");
	return candidateId;
      }
    }
         
    // end of chain - key not present in dictionary
    //
    int n = chain.length;
    int[] newchain = new int[n << 1]; // double size of chain
    for (int i = 0; i < n; ++i)
      newchain[i] = chain[i];
    chains[chainIndex] = newchain;
      
    if (nextId == keys.length) // make more
      growDictionary();       // ...space
    keys[nextId] = key;        // add...
    values[nextId] = value;    // ...to dictionary
    newchain[n] = nextId;      // add id to hash table
    if (VM.TraceDictionaries) VM.sysWrite("CCC[" + nextId + "]: new key=" + key + " value=" + value + "\n");
    return nextId++;
  }
   
  // Find id associated with key, if any
  // Taken:    key sought
  // Returned: id for use by getKey(), setValue(), and getValue(), or 0 if not found
  //
  static synchronized int findId(KKK key) {
    // check for null/zero first, so we can later use null/zero as an end of chain sentinal
    if (key == keys[0])
      return -1;
         
    int chainIndex = (DDD.dictionaryHash(key) & 0x7fffffff) % chains.length;
    int[] chain = chains[chainIndex];

    if (chain == null) return -1; // not found

    for (int i = 0, n = chain.length; i < n; ++i) {
      int candidateId  = chain[i];
      KKK candidateKey = keys[candidateId];
      int rc = DDD.dictionaryCompare(candidateKey, key);
      if (rc == 0) return -1;	// not found
      if (rc == 1) { 
	// key already present in dictionary
	if (VM.TraceDictionaries) VM.sysWrite("CCC[" + candidateId + "]: old key=" + key + " value=" + values[candidateId] + "\n");
	return candidateId;
      }
    }
         
    // end of chain - key not present in dictionary
    //
    return -1;		// not found
  }

  // Retrieve key associated with id.
  // Taken:    id obtained from findOrCreateId()
  // Returned: key
  //
  static KKK getKey(int id) throws VM_PragmaUninterruptible {
    return keys[id];
  }
   
  // Associate a new value with an id.
  // Taken:    id obtained from findOrCreateId()
  // Returned: value
  //
  static synchronized void setValue(int id, VVV value) {
    values[id] = value;
  }
   
  // Retrieve value associated with an id.
  // Taken:    id obtained from findOrCreateId()
  // Returned: value
  //
  static VVV getValue(int id)  throws VM_PragmaUninterruptible {
    return values[id];
  }
   
  // Retrieve all keys currently stored in the dictionary.
  //
  static synchronized KKK[] getKeys() {
    KKK[] tmp = new KKK[nextId];
    for (int i = 0; i < nextId; ++i)
      tmp[i] = keys[i];
    return tmp;
  }
      
  // Retrieve all values currently stored in the dictionary.
  //
  static synchronized VVV[] getValues() {
    VVV[] tmp = new VVV[nextId];
    for (int i = 0; i < nextId; ++i)
      tmp[i] = values[i];
    return tmp;
  }

  // Report how many values are currently stored in the dictionary.
  //
  static int getNumValues()  throws VM_PragmaUninterruptible {
    return nextId;
  }

  // Retrieve pointer to keys currently stored in the dictionary.
  // (Note: this is intended for the debugger only)
  static KKK[] getKeysPointer() {
    return keys;
  }
      
  // Retrieve pointer to values currently stored in the dictionary.
  // (Note: this is intended for the debugger only)
  static VVV[] getValuesPointer() {
    return values;
  }

  // Retrieve pointer to the hash chains
  // (Note: this is intended for the debugger only)
  static int[][] getChainsPointer() {
    return chains;
  }

  //----------------//
  // implementation //
  //----------------//

  private static KKK[]   keys;    // dictionary keys
  private static VVV[]   values;  // dictionary values
  private static int     nextId;  // index of next free slot in keys[]/values[]
  private static int[][] chains;  // hash table for quickly determining presence of key in dictionary
  // - chains[i] is initial hash probe
  // - chains[][j] is index into keys[]/values[]
  static void init()      {
    int space = 20; // !!TODO: pick a reasonable estimate for initial space
    keys   = new KKK[space];
    values = new VVV[space];
    nextId = 1;              // id 0 corresponds to key of null/zero
    chains = new int[201][]; // a prime number is best
  }
   
  private static void growDictionary()    {
    int n = keys.length;
    int space = n << 1; // double size of dictionary
      
    KKK[] newkeys = new KKK[space];
    for (int i = 0; i < n; ++i)
      newkeys[i] = keys[i];
    keys = newkeys;
      
    VVV[] newvalues = new VVV[space];
    for (int i = 0; i < n; ++i)
      newvalues[i] = values[i];
    values = newvalues;
  }
   
  // // Dump hash table to see if we got a nice distribution.
  // //
  // static void
  // dump()
  //    {
  //    int totalCnt = 1; // +1 because key for null/zero is not stored in hash table
  //
  //    for (int i = 0, n = chains.length; i < n; ++i)
  //       {
  //       VM.sysWrite(i + ": ");
  //
  //       int[] chain = chains[i];
  //       if (chain == null)
  //          {
  //          VM.sysWrite("empty\n");
  //          continue;
  //          }
  //
  //       int cnt = 0;
  //       for (int j = 0, m = chain.length; j < m; ++j)
  //          {
  //          if (chain[j] == 0)
  //             break;
  //          ++cnt;
  //          }
  //
  //       VM.sysWrite(cnt + " of " + chain.length + "\n");
  //       totalCnt += cnt;
  //       }
  //
  //    if (totalCnt != nextId)
  //       VM.sysWrite("hash table inconsistent: expected " + nextId + " keys but found " + totalCnt + "\n");
  //    }
}
