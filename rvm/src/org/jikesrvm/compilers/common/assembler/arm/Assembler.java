/*
 *  This file is part of the Jikes RVM project (http://jikesrvm.org).
 *
 *  This file is licensed to You under the Eclipse Public License (EPL);
 *  You may not use this file except in compliance with the License. You
 *  may obtain a copy of the License at
 *
 *      http://www.opensource.org/licenses/eclipse-1.0.php
 *
 *  See the COPYRIGHT.txt file distributed with this work for information
 *  regarding copyright ownership.
 */
package org.jikesrvm.compilers.common.assembler.arm;

import static org.jikesrvm.compilers.common.assembler.arm.AssemblerConstants.COND.EQ;
import static org.jikesrvm.compilers.common.assembler.arm.AssemblerConstants.COND.NE;
import static org.jikesrvm.compilers.common.assembler.arm.AssemblerConstants.COND.LS;
import static org.jikesrvm.compilers.common.assembler.arm.AssemblerConstants.COND.GE;
import static org.jikesrvm.compilers.common.assembler.arm.AssemblerConstants.COND.LE;
import static org.jikesrvm.compilers.common.assembler.arm.AssemblerConstants.COND.ALWAYS;
import static org.jikesrvm.compilers.common.assembler.arm.AssemblerConstants.COND.NOCOND;
import static org.jikesrvm.arm.RegisterConstants.GPR.R0;
import static org.jikesrvm.arm.RegisterConstants.GPR.R5;
import static org.jikesrvm.arm.RegisterConstants.GPR.R6;
import static org.jikesrvm.arm.RegisterConstants.TR;
import static org.jikesrvm.arm.RegisterConstants.R12;
import static org.jikesrvm.arm.RegisterConstants.SP;
import static org.jikesrvm.arm.RegisterConstants.PC;
import static org.jikesrvm.arm.RegisterConstants.LG_INSTRUCTION_WIDTH;
import static org.jikesrvm.arm.StackframeLayoutConstants.STACK_SIZE_JNINATIVE;

import org.jikesrvm.VM;
import org.jikesrvm.util.Services;
import org.jikesrvm.runtime.Entrypoints;
import org.jikesrvm.architecture.MachineRegister;
import org.jikesrvm.compilers.baseline.arm.BaselineCompilerImpl;
import org.jikesrvm.compilers.common.CodeArray;
import org.jikesrvm.compilers.common.assembler.AbstractAssembler;
import org.jikesrvm.compilers.common.assembler.ForwardReference;
import org.jikesrvm.objectmodel.JavaHeader;
import org.jikesrvm.arm.RegisterConstants.GPR;
import org.jikesrvm.arm.RegisterConstants.FPR;
import org.jikesrvm.arm.RegisterConstants.DPR;
import org.jikesrvm.arm.RegisterConstants.QPR;
import org.jikesrvm.compilers.common.assembler.arm.AssemblerConstants.COND;
import org.vmmagic.pragma.Inline;
import org.vmmagic.unboxed.Offset;

/**
 * Machine code generators:
 * <p>
 * Corresponding to a ARM assembler instruction of the form
 * <pre>
 *    xx.cond A,B,C
 * </pre>
 * there will be a method
 * <pre>
 *    void emitXX (COND cond, GPR A, GPR B, GPR C).
 * </pre>
 * <p>
 * The emitXX method appends this instruction to an MachineCode object.
 * <p>
 * mIP will be incremented to point to the next machine instruction.
 * <p>
 * Machine code generators:
 */
public class Assembler extends AbstractAssembler {

 /**
   * The array holding the generated binary code.
   */
  private int[] machineCodes;
  /** Debug output? */
  private final boolean shouldPrint;
  /**  Baseline compiler instance for this assembler.  May be null. */
  private final BaselineCompilerImpl compiler;
  /** current machine code instruction */
  private int mIP;
  /** Should the generated code be regarded as hot? */
  private final boolean isHot = false;
  /**
   * Heuristic constant used to calculate initial size of the machine
   * code buffer.  This is an average of how many bytes of generated
   * code come from a given bytecode in the baseline compiler.
   */
  private static final int CODE_EXPANSION_FACTOR =  4;
  /**
   * Heuristic constant used to calculate initial size of the machine
   * code buffer.  This is an estimate of the fixed method overhead
   * code generated by the baseline compiler, such as method
   * prologue.
   */
  private static final int CODE_OVERHEAD_TERM    = 30;

  public Assembler(int length) {
    this(length, false, null);
  }

  public Assembler(int length, boolean sp) {
    this(length, sp, null);
  }

  public Assembler(int bytecodeSize, boolean sp, BaselineCompilerImpl comp) {
    machineCodes = new int[bytecodeSize * CODE_EXPANSION_FACTOR + CODE_OVERHEAD_TERM];
    shouldPrint = sp;
    compiler = comp;
    mIP = 0;
  }

  @Inline
  private static boolean fits_unsigned(int val, int bits) {
    return (val >>> bits) == 0;
  }

  @Inline
  private static boolean fits_signed(int val, int bits) {
    val = val >> (bits - 1);
    return (val == 0 || val == -1);
  }

  @Inline
  private static boolean fits_B(int val) {
    return fits_signed(val, 24); // Note val is instructions rather than bytes
  }

  @Inline
  private static boolean fits_VLDR_VSTR(int val) {
    return fits_unsigned(val, 10) && ((val & b11) == 0);
  }

  @Override
  public void noteBytecode(int i, String bcode) {
    String s1 = Services.getHexString(mIP << LG_INSTRUCTION_WIDTH, true);
    VM.sysWrite(s1 + ": [" + i + "] " + bcode + "\n");
  }

  /**
   * Return a copy of the generated code as a CodeArray.
   * @return a copy of the generated code as a CodeArray.
   */
  @Override
  public CodeArray getMachineCodes() {
    int len = getMachineCodeIndex();
    CodeArray trimmed = CodeArray.Factory.create(len, isHot);
    for (int i = 0; i < len; i++) {
      trimmed.set(i, machineCodes[i]);
    }
    return trimmed;
  }

  @Override
  public int getMachineCodeIndex() {
    return mIP;
  }

  private void appendInstruction(int instr) {
    if (mIP < machineCodes.length) {
      machineCodes[mIP] = instr;
    } else {
      growMachineCodes(mIP, instr);
    }
    mIP++;
  }

  private void growMachineCodes(int index, int instr) {
    int [] old = machineCodes;
    machineCodes = new int [2 * old.length];
    System.arraycopy(old, 0, machineCodes, 0, old.length);
    machineCodes[index] = instr;
  }

  private static final int b0010100  = 0x14;
  private static final int b0000100  = 0x4;
  private static final int b0010000  = 0x10;
  private static final int b1010     = 0xA;
  private static final int b00010010_111111111111_0001 = 0x12FFF1;
  private static final int b00010010_111111111111_0011 = 0x12FFF3;
  private static final int b00110101 = 0x35;
  private static final int b00010101 = 0x15;
  private static final int b0010001  = 0x11;
  private static final int b0000001  = 0x1;
  private static final int b01010001 = 0x51;
  private static final int b01111001 = 0x79;
  private static final int b0001101  = 0xD;
  private static final int b00110000 = 0x30;
  private static final int b00110100 = 0x34;
  private static final int b00011010 = 0x1A;
  private static final int b0000000  = 0x0;
  private static final int b1001     = 0x9;
  private static final int b0001111  = 0xF;
  private static final int b00100110 = 0x26;
  private static final int b00110010 = 0x32;
  private static final int b1111     = 0xF;
  private static final int b1110     = 0xE;
  private static final int b0001100  = 0xC;
  private static final int b010010011101 = 0x49D;
  private static final int b010100101101 = 0x52D;
  private static final int b100      = 0x4;
  private static final int b01110001 = 0x71;
  private static final int b0001     = 0x1;
  private static final int b01010000 = 0x50;
  private static final int b01111000 = 0x78;
  private static final int b00000100 = 0x4;
  private static final int b11       = 0x3;
  private static final int b1011     = 0xB;
  private static final int b0011     = 0x3;
  private static final int b0101     = 0x5;
  private static final int b0000010  = 0x2;
  private static final int b0010010  = 0x12;
  private static final int b010110011111 = 0x59F;
  private static final int b11010001 = 0xD1;
  private static final int b11111    = 0x1F;
  private static final int b00011001 = 0x19;
  private static final int b00011011 = 0x1B;
  private static final int b1101     = 0xD;
  private static final int b00111110 = 0x3E;
  private static final int b01111100 = 0x7C;
  private static final int b00011000 = 0x18;
  private static final int b11110    = 0x1E;
  private static final int b11101011 = 0xEB;
  private static final int b10100000 = 0xA0;
  private static final int b10110000 = 0xB0;
  private static final int b110010111101 = 0xCBD;
  private static final int b110100101101 = 0xD2D;
  private static final int b11010000 = 0xD0;
  private static final int b00100011 = 0x23;
  private static final int b1000     = 0x8;
  private static final int b11100011 = 0xE3;
  private static final int b00100000 = 0x20;
  private static final int b11101000 = 0xE8;
  private static final int b11100010 = 0xE2;
  private static final int b111010110001 = 0xEB1;
  private static final int b00100010 = 0x22;
  private static final int b00110011 = 0x33;
  private static final int b0100     = 0x4;
  private static final int b010      = 0x2;
  private static final int b111010110100 = 0xEB4;
  private static final int b1110111100011111101000010000 = 0xEF1FA10;
  private static final int b111010111000 = 0xEB8;
  private static final int b101011   = 0x2B;
  private static final int b101111   = 0x2F;
  private static final int b111010111101 = 0xEBD;
  private static final int b111010110111 = 0xEB7;
  private static final int b00010000 = 0x10;
  private static final int b11000100 = 0xC4;
  private static final int b001110110000 = 0x3B0;
  private static final int b11100000 = 0xE0;
  private static final int b11100001 = 0xE1;
  private static final int b01111101 = 0x7D;
  private static final int b01010101 = 0x55;
  private static final int b01010100 = 0x54;
  private static final int b00010100 = 0x14;
  private static final int b010101111111111100000101 = 0x57FF05;
  private static final int b010101111111111100000110 = 0x57FF06;
  private static final int b10100100 = 0xA4;
  private static final int b10110100 = 0xB4;
  private static final int b00101010 = 0x2A;
  private static final int b00111010 = 0x3A;
  private static final int b11000101 = 0xC5;
  private static final int b11111001 = 0xF9;
  private static final int b111110011111 = 0xF9F;
  private static final int b01111111 = 0x7F;
  private static final int b00000110 = 0x06;
  private static final int b00101000 = 0x28;
  private static final int b00101110 = 0x2E;
  private static final int b00001110 = 0x0E;


  /* Machine Instructions */

  public void emitADDimm(COND cond, GPR Rd, GPR Rn, int V) { // Could use the rotation option for larger numbers
    if (VM.VerifyAssertions && !fits_unsigned(V, 8)) {
      String message = "emitADDimm: !fits_unsigned(" + V + ", 8)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b0010100 << 21 | Rn.value() << 16 | Rd.value() << 12 | (V & 0xFF);
    appendInstruction(mi);
  }

  public void emitADD(COND cond, GPR Rd, GPR Rn, GPR Rm) {
    int mi = cond.value() | b0000100 << 21 | Rn.value() << 16 | Rd.value() << 12 | Rm.value();
    appendInstruction(mi);
  }

  public void emitADDshift(COND cond, GPR Rt, GPR Rn, GPR Rm, int shift) {
    if (VM.VerifyAssertions && !fits_unsigned(shift, 5)) {
      String message = "emitADDshift: !fits_unsigned(" + shift + ", 5)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b0000100 << 21 | Rn.value() << 16 | Rt.value() << 12 | Rm.value() | (shift & b11111) << 7;
    appendInstruction(mi);
  }

  public void emitANDimm(COND cond, GPR Rd, GPR Rn, int V) { // Could use the rotation option for larger numbers
    if (VM.VerifyAssertions && !fits_unsigned(V, 8)) {
      String message = "emitANDimm: !fits_unsigned(" + V + ", 8)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b0010000 << 21 | Rn.value() << 16 | Rd.value() << 12 | (V & 0xFF);
    appendInstruction(mi);
  }

  public void emitAND(COND cond, GPR Rd, GPR Rn, GPR Rm) {
    int mi = cond.value() | b0000000 << 21 | Rn.value() << 16 | Rd.value() << 12 | Rm.value();
    appendInstruction(mi);
  }

  public void emitANDSimm(COND cond, GPR Rd, GPR Rn, int V) { // Could use the rotation option for larger numbers
    if (VM.VerifyAssertions && !fits_unsigned(V, 8)) {
      String message = "emitANDSimm: !fits_unsigned(" + V + ", 8)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b0010000 << 21 | 1 << 20 | Rn.value() << 16 | Rd.value() << 12 | (V & 0xFF);
    appendInstruction(mi);
  }

  public void emitANDS(COND cond, GPR Rd, GPR Rn, GPR Rm) {
    int mi = cond.value() | b0000000 << 21 | 1 << 20 | Rn.value() << 16 | Rd.value() << 12 | Rm.value();
    appendInstruction(mi);
  }

  private void _emitB(COND cond, int relative_address) {
    if (VM.VerifyAssertions && !fits_B(relative_address)) {
      String message = "_emitB: !fits_B(" + relative_address + ")";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b1010 << 24 | (relative_address & 0xFFFFFF);
    appendInstruction(mi);
  }

  private void emitB(COND cond, int instruction_index) {       // Only for backwards branches; all others use the Forward Reference Macros
    if (VM.VerifyAssertions && !(instruction_index <= mIP)) {  // Note: special case infinite loop is allowed to compile as branch to itself, hence <= instead of <
      String message = "emitB: !" + instruction_index + " <= " + mIP;
      VM._assert(VM.NOT_REACHED, message);
    }
    _emitB(cond, instruction_index - mIP - 2); // ARM branches are relative to PC and the PC is 2 instructions ahead of the current one
  }

  public void emitBX(COND cond, GPR Rm) {
    int mi = cond.value() | b00010010_111111111111_0001 << 4 | Rm.value();
    appendInstruction(mi);
  }

  public void emitBLX(COND cond, GPR Rm) {
    int mi = cond.value() | b00010010_111111111111_0011 << 4 | Rm.value();
    appendInstruction(mi);
  }

  public void emitCMPimm(COND cond, GPR Rn, int V) { // Could use the rotation option for larger numbers
    if (VM.VerifyAssertions && !fits_unsigned(V, 8)) {
      String message = "emitCMPimm: !fits_unsigned(" + V + ", 8)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b00110101 << 20 | Rn.value() << 16 | (V & 0xFF);
    appendInstruction(mi);
  }

  public void emitCMP(COND cond, GPR Rn, GPR Rm) {
    int mi = cond.value() | b00010101 << 20 | Rn.value() << 16 | Rm.value();
    appendInstruction(mi);
  }

  public void emitDMB() {
    int mi = NOCOND.value() | b010101111111111100000101 << 4 | b1111;
    appendInstruction(mi);
  }

  public void emitDMBst() {
    int mi = NOCOND.value() | b010101111111111100000101 << 4 | b1110;
    appendInstruction(mi);
  }

  public void emitEORimm(COND cond, GPR Rd, GPR Rn, int V) { // Could use the rotation option for larger numbers
    if (VM.VerifyAssertions && !fits_unsigned(V, 8)) {
      String message = "emitEORimm: !fits_unsigned(" + V + ", 8)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b0010001 << 21 | Rn.value() << 16 | Rd.value() << 12 | (V & 0xFF);
    appendInstruction(mi);
  }

  public void emitEOR(COND cond, GPR Rd, GPR Rn, GPR Rm) {
    int mi = cond.value() | b0000001 << 21 | Rn.value() << 16 | Rd.value() << 12 | Rm.value();
    appendInstruction(mi);
  }

  public void emitISB() {
    int mi = NOCOND.value() | b010101111111111100000110 << 4 | b1111;
    appendInstruction(mi);
  }

  public void emitLDRimm(COND cond, GPR Rt, GPR Rn, int V) {
    boolean neg = (V < 0);
    if (neg) V = -V;
    if (VM.VerifyAssertions && !fits_unsigned(V, 12)) {
      String message = "emitLDRimm: !fits_unsigned(" + V + ", 12)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b01010001 << 20 | (neg ? 0 : 1) << 23 | Rn.value() << 16 | Rt.value() << 12 | (V & 0xFFF);
    appendInstruction(mi);
  }

  public void emitLDR(COND cond, GPR Rt, GPR Rn, GPR Rm) {
    int mi = cond.value() | b01111001 << 20 | Rn.value() << 16 | Rt.value() << 12 | Rm.value();
    appendInstruction(mi);
  }

  public void emitLDRshift(COND cond, GPR Rt, GPR Rn, GPR Rm, int shift) {
    if (VM.VerifyAssertions && !fits_unsigned(shift, 5)) {
      String message = "emitLDRshift: !fits_unsigned(" + shift + ", 5)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b01111001 << 20 | Rn.value() << 16 | Rt.value() << 12 | Rm.value() | (shift & b11111) << 7;
    appendInstruction(mi);
  }

  public void emitLDREX(COND cond, GPR Rt, GPR Rn) {
    int mi = cond.value() | b00011001 << 20 | Rn.value() << 16 | Rt.value() << 12 | b111110011111;
    appendInstruction(mi);
  }

  public void emitLDREXD(COND cond, GPR Rt, GPR Rt2, GPR Rn) {
    if (VM.VerifyAssertions && !((Rt.value() & 1) == 0 && Rt2.value() == Rt.value() + 1)) {
      String message = "emitLDREXD: " + Rt.value() + " not even or " + Rt2.value() + " not consecutive";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b00011011 << 20 | Rn.value() << 16 | Rt.value() << 12 | b111110011111;
    appendInstruction(mi);
  }

  public void emitLDRBimm(COND cond, GPR Rt, GPR Rn, int V) {
    boolean neg = (V < 0);
    if (neg) V = -V;
    if (VM.VerifyAssertions && !fits_unsigned(V, 12)) {
      String message = "emitLDRBimm: !fits_unsigned(" + V + ", 12)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b01010101 << 20 | (neg ? 0 : 1) << 23 | Rn.value() << 16 | Rt.value() << 12 | (V & 0xFFF);
    appendInstruction(mi);
  }

  public void emitLDRB(COND cond, GPR Rt, GPR Rn, GPR Rm) {
    int mi = cond.value() | b01111101 << 20 | Rn.value() << 16 | Rt.value() << 12 | Rm.value();
    appendInstruction(mi);
  }

  public void emitLDRSBimm(COND cond, GPR Rt, GPR Rn, int V) {
    boolean neg = (V < 0);
    if (neg) V = -V;
    if (VM.VerifyAssertions && !fits_unsigned(V, 8)) {
      String message = "emitLDRSBimm: !fits_unsigned(" + V + ", 8)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b00010101 << 20 | (neg ? 0 : 1) << 23 | Rn.value() << 16 | Rt.value() << 12 | b1101 << 4 | (V & 0xF0) << 4 | (V & 0xF);
    appendInstruction(mi);
  }

  public void emitLDRSB(COND cond, GPR Rt, GPR Rn, GPR Rm) {
    int mi = cond.value() | b00011001 << 20 | Rn.value() << 16 | Rt.value() << 12 | b1101 << 4 | Rm.value();
    appendInstruction(mi);
  }

  public void emitLDRHimm(COND cond, GPR Rt, GPR Rn, int V) {
    boolean neg = (V < 0);
    if (neg) V = -V;
    if (VM.VerifyAssertions && !fits_unsigned(V, 8)) {
      String message = "emitLDRHimm: !fits_unsigned(" + V + ", 8)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b00010101 << 20 | (neg ? 0 : 1) << 23 | Rn.value() << 16 | Rt.value() << 12 | b1011 << 4 | (V & 0xF0) << 4 | (V & 0xF);
    appendInstruction(mi);
  }

  public void emitLDRH(COND cond, GPR Rt, GPR Rn, GPR Rm) {
    int mi = cond.value() | b00011001 << 20 | Rn.value() << 16 | Rt.value() << 12 | b1011 << 4 | Rm.value();
    appendInstruction(mi);
  }

  public void emitLDRSHimm(COND cond, GPR Rt, GPR Rn, int V) {
    boolean neg = (V < 0);
    if (neg) V = -V;
    if (VM.VerifyAssertions && !fits_unsigned(V, 8)) {
      String message = "emitLDRSHimm: !fits_unsigned(" + V + ", 8)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b00010101 << 20 | (neg ? 0 : 1) << 23 | Rn.value() << 16 | Rt.value() << 12 | b1111 << 4 | (V & 0xF0) << 4 | (V & 0xF);
    appendInstruction(mi);
  }

  public void emitLDRSH(COND cond, GPR Rt, GPR Rn, GPR Rm) {
    int mi = cond.value() | b00011001 << 20 | Rn.value() << 16 | Rt.value() << 12 | b1111 << 4 | Rm.value();
    appendInstruction(mi);
  }

  public void emitLSLimm(COND cond, boolean setFlags, GPR Rd, GPR Rm, int V) { // Could also allow V = 32, but then it needs to be encoded as 0
    if (VM.VerifyAssertions && !(fits_unsigned(V, 5) && V != 0)) {
      String message = "emitLSLimm: !fits_unsigned(" + V + ", 5) || !" + V + " != 0";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b0001101 << 21 | Rd.value() << 12 | Rm.value() | (V & b11111) << 7;
    appendInstruction(mi);
  }

  public void emitLSL(COND cond, GPR Rd, GPR Rn, GPR Rm) {
    int mi = cond.value() | b0001101 << 21 | Rd.value() << 12 | Rm.value() << 8 | b0001 << 4 | Rn.value();
    appendInstruction(mi);
  }

  public void emitLSRimm(COND cond, GPR Rd, GPR Rm, int V) { // Could also allow V = 32, but then it needs to be encoded as 0
    if (VM.VerifyAssertions && !(fits_unsigned(V, 5) && V != 0)) {
      String message = "emitLSRimm: !fits_unsigned(" + V + ", 5) || !" + V + " != 0";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b0001101 << 21 | Rd.value() << 12 | b010 << 4 | Rm.value() | (V & b11111) << 7;
    appendInstruction(mi);
  }

  public void emitLSR(COND cond, GPR Rd, GPR Rn, GPR Rm) {
    int mi = cond.value() | b0001101 << 21 | Rd.value() << 12 | Rm.value() << 8 | b0011 << 4 | Rn.value();
    appendInstruction(mi);
  }

  public void emitASRimm(COND cond, GPR Rd, GPR Rm, int V) { // Could also allow V = 32, but then it needs to be encoded as 0
    if (VM.VerifyAssertions && !(fits_unsigned(V, 5) && V != 0)) {
      String message = "emitASRimm: !fits_unsigned(" + V + ", 5) || !" + V + " != 0";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b0001101 << 21 | Rd.value() << 12 | b100 << 4 | Rm.value() | (V & b11111) << 7;
    appendInstruction(mi);
  }

  public void emitASR(COND cond, GPR Rd, GPR Rn, GPR Rm) {
    int mi = cond.value() | b0001101 << 21 | Rd.value() << 12 | Rm.value() << 8 | b0101 << 4 | Rn.value();
    appendInstruction(mi);
  }

  public void emitMVNimm(COND cond, GPR Rd, int V) { // Could use the rotation option for larger numbers
    if (VM.VerifyAssertions && !fits_unsigned(~V, 8)) {
      String message = "emitMVNimm: !fits_unsigned(~" + V + ", 8)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b00111110 << 20 | Rd.value() << 12 | (~V & 0xFF);
    appendInstruction(mi);
  }

  public void emitMOVimm(COND cond, GPR Rd, int V) { // Technically this is MOVW
    if (VM.VerifyAssertions && !fits_unsigned(V, 12)) {
      String message = "emitMOVimm: !fits_unsigned(" + V + ", 12)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b00110000 << 20 | Rd.value() << 12 | (V & 0xFFF);
    appendInstruction(mi);
  }

  public void emitMOV(COND cond, GPR Rd, GPR Rm) {
    int mi = cond.value() | b00011010 << 20 | Rd.value() << 12 | Rm.value();
    appendInstruction(mi);
  }

  public void emitMOVW(COND cond, GPR Rd, int V) {
    if (VM.VerifyAssertions && !fits_unsigned(V, 16)) {
      String message = "emitMOVW: !fits_unsigned(" + V + ", 16)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b00110000 << 20 | ((V >>> 12) & 0xF) << 16 | Rd.value() << 12 | (V & 0xFFF);
    appendInstruction(mi);
  }

  public void emitMOVT(COND cond, GPR Rd, int V) {
    if (VM.VerifyAssertions && !fits_unsigned(V, 16)) {
      String message = "emitMOVT: !fits_unsigned(" + V + ", 16)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b00110100 << 20 | ((V >>> 12) & 0xF) << 16 | Rd.value() << 12 | (V & 0xFFF);
    appendInstruction(mi);
  }

  public void emitMRRC(COND cond, int coproc, int opc, GPR Rlow, GPR Rhigh, int CRm) {
    int mi = cond.value() | b11000101 << 20 | Rhigh.value() << 16 | Rlow.value() << 12 | coproc << 8 | opc << 4 | CRm;
    appendInstruction(mi);
  }

  public void emitMUL(COND cond, GPR Rd, GPR Rn, GPR Rm) {
    int mi = cond.value() | b0000000 << 21 | Rd.value() << 16 | Rm.value() << 8 | b1001 << 4 | Rn.value();
    appendInstruction(mi);
  }

  public void emitNOT(COND cond, GPR Rd, GPR Rm) { // alias for MVN
    int mi = cond.value() | b0001111 << 21 | Rd.value() << 12 | Rm.value();
    appendInstruction(mi);
  }

  public void emitNOP() {
    int mi = ALWAYS.value() | b00110010 << 20 | b1111 << 12;
    appendInstruction(mi);
  }

  private void emitNOP(COND cond) {
    int mi = cond.value() | b00110010 << 20 | b1111 << 12;
    appendInstruction(mi);
  }

  public void emitORR(COND cond, GPR Rd, GPR Rn, GPR Rm) {
    int mi = cond.value() | b0001100 << 21 | Rd.value() << 12 | Rn.value() << 16 | Rm.value();
    appendInstruction(mi);
  }

  public void emitPLDimm(GPR Rn, int V) {
    boolean neg = (V < 0);
    if (neg) V = -V;
    if (VM.VerifyAssertions && !fits_unsigned(V, 12)) {
      String message = "emitPLDimm: !fits_unsigned(" + V + ", 12)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = NOCOND.value() | b01010101 << 20 | (neg ? 0 : 1) << 23 | Rn.value() << 16 | b1111 << 12 | (V & 0xFFF);
    appendInstruction(mi);
  }

  public void emitPOP(COND cond, GPR Rt) {
    int mi = cond.value() | b010010011101 << 16 | Rt.value() << 12 | b100;
    appendInstruction(mi);
  }

  public void emitPUSH(COND cond, GPR Rt) {
    int mi = cond.value() | b010100101101 << 16 | Rt.value() << 12 | b100;
    appendInstruction(mi);
  }

  public void emitQADD(COND cond, GPR Rd, GPR Rn, GPR Rm) {
    int mi = cond.value() | b00010000 << 20 | Rn.value() << 16 | Rd.value() << 12 | b0101 << 4 | Rm.value();
    appendInstruction(mi);
  }

  public void emitRSB(COND cond, GPR Rd, GPR Rn, GPR Rm) {
    int mi = cond.value() | b00000110 << 20 | Rd.value() << 12 | Rn.value() << 16 | Rm.value();
    appendInstruction(mi);
  }

  public void emitRSBimm(COND cond, GPR Rd, GPR Rn, int V) { // Could use the rotation option for larger numbers
    if (VM.VerifyAssertions && !fits_unsigned(V, 8)) {
      String message = "emitRSBimm: !fits_unsigned(" + V + ", 8)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b00100110 << 20 | Rd.value() << 12 | Rn.value() << 16 | V & 0xFF;
    appendInstruction(mi);
  }

  public void emitRSBS(COND cond, GPR Rd, GPR Rn, GPR Rm) {
    int mi = cond.value() | b00000110 << 20 | 1 << 20 | Rd.value() << 12 | Rn.value() << 16 | Rm.value();
    appendInstruction(mi);
  }

  public void emitRSBSimm(COND cond, GPR Rd, GPR Rn, int V) { // Could use the rotation option for larger numbers
    if (VM.VerifyAssertions && !fits_unsigned(V, 8)) {
      String message = "emitRSBSimm: !fits_unsigned(" + V + ", 8)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b00100110 << 20 | 1 << 20 | Rd.value() << 12 | Rn.value() << 16 | V & 0xFF;
    appendInstruction(mi);
  }

  public void emitRSC(COND cond, GPR Rd, GPR Rn, GPR Rm) {
    int mi = cond.value() | b00001110 << 20 | Rd.value() << 12 | Rn.value() << 16 | Rm.value();
    appendInstruction(mi);
  }

  public void emitRSCimm(COND cond, GPR Rd, GPR Rn, int V) { // Could use the rotation option for larger numbers
    if (VM.VerifyAssertions && !fits_unsigned(V, 8)) {
      String message = "emitRSCimm: !fits_unsigned(" + V + ", 8)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b00101110 << 20 | Rd.value() << 12 | Rn.value() << 16 | V & 0xFF;
    appendInstruction(mi);
  }

  public void emitSDIV(COND cond, GPR Rd, GPR Rn, GPR Rm) {
    int mi = cond.value() | b01110001 << 20 | Rd.value() << 16 | b1111 << 12 | Rm.value() << 8 | b0001 << 4 | Rn.value();
    appendInstruction(mi);
  }

  public void emitSTRimm(COND cond, GPR Rt, GPR Rn, int V) {
    boolean neg = (V < 0);
    if (neg) V = -V;
    if (VM.VerifyAssertions && !fits_unsigned(V, 12)) {
      String message = "emitSTRimm: !fits_unsigned(" + V + ", 12)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b01010000 << 20 | (neg ? 0 : 1) << 23 | Rn.value() << 16 | Rt.value() << 12 | (V & 0xFFF);
    appendInstruction(mi);
  }

  public void emitSTR(COND cond, GPR Rt, GPR Rn, GPR Rm) {
    int mi = cond.value() | b01111000 << 20 | Rn.value() << 16 | Rt.value() << 12 | Rm.value();
    appendInstruction(mi);
  }

  public void emitSTRshift(COND cond, GPR Rt, GPR Rn, GPR Rm, int shift) {
    if (VM.VerifyAssertions && !fits_unsigned(shift, 5)) {
      String message = "emitSTRshift: !fits_unsigned(" + shift + ", 5)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b01111000 << 20 | Rn.value() << 16 | Rt.value() << 12 | Rm.value() | (shift & b11111) << 7;
    appendInstruction(mi);
  }

  public void emitSTREX(COND cond, GPR Rd, GPR Rt, GPR Rn) {
    if (VM.VerifyAssertions && !(Rd.value() != Rt.value())) {
      String message = "emitSTREX: " + Rd.value() + " == " + Rt.value();
      VM._assert(VM.NOT_REACHED, message);
    }
    if (VM.VerifyAssertions && !(Rd.value() != Rn.value())) {
      String message = "emitSTREX: " + Rd.value() + " == " + Rn.value();
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b00011000 << 20 | Rn.value() << 16 | Rd.value() << 12 | b11111001 << 4 | Rt.value();
    appendInstruction(mi);
  }

  public void emitSTREXD(COND cond, GPR Rd, GPR Rt, GPR Rt2, GPR Rn) {
    if (VM.VerifyAssertions && !((Rt.value() & 1) == 0 && Rt2.value() == Rt.value() + 1)) {
      String message = "emitSTREXD: " + Rt.value() + " not even or " + Rt2.value() + " not consecutive";
      VM._assert(VM.NOT_REACHED, message);
    }
    if (VM.VerifyAssertions && !(Rd.value() != Rt.value() && Rd.value() != Rt2.value() && Rd.value() != Rn.value())) {
      String message = "emitSTREXD: " + Rd.value() + " equals " + Rt.value() + " or " + Rt2.value() + " or " + Rn.value();
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b00011010 << 20 | Rn.value() << 16 | Rd.value() << 12 | b11111001 << 4 | Rt.value();
    appendInstruction(mi);
  }

 public void emitSTRBimm(COND cond, GPR Rt, GPR Rn, int V) {
    boolean neg = (V < 0);
    if (neg) V = -V;
    if (VM.VerifyAssertions && !fits_unsigned(V, 12)) {
      String message = "emitSTRBimm: !fits_unsigned(" + V + ", 12)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b01010100 << 20 | (neg ? 0 : 1) << 23 | Rn.value() << 16 | Rt.value() << 12 | (V & 0xFFF);
    appendInstruction(mi);
  }

 public void emitSTRB(COND cond, GPR Rt, GPR Rn, GPR Rm) {
    int mi = cond.value() | b01111100 << 20 | Rn.value() << 16 | Rt.value() << 12 | Rm.value();
    appendInstruction(mi);
  }

  public void emitSTRHimm(COND cond, GPR Rt, GPR Rn, int V) {
    boolean neg = (V < 0);
    if (neg) V = -V;
    if (VM.VerifyAssertions && !fits_unsigned(V, 8)) {
      String message = "emitSTRHimm: !fits_unsigned(" + V + ", 8)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b00010100 << 20 | (neg ? 0 : 1) << 23 | Rn.value() << 16 | Rt.value() << 12 | b1011 << 4 | (V & 0xF0) << 4 | (V & 0xF);
    appendInstruction(mi);
  }

  public void emitSTRH(COND cond, GPR Rt, GPR Rn, GPR Rm) {
    int mi = cond.value() | b00011000 << 20 | Rn.value() << 16 | Rt.value() << 12 | b1011 << 4 | Rm.value();
    appendInstruction(mi);
  }

  public void emitSUBimm(COND cond, GPR Rd, GPR Rn, int V) { // Could use the rotation option for larger numbers
    if (VM.VerifyAssertions && !fits_unsigned(V, 8)) {
      String message = "emitSUBimm: !fits_unsigned(" + V + ", 8)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b0010010 << 21 | Rn.value() << 16 | Rd.value() << 12 | (V & 0xFF);
    appendInstruction(mi);
  }

  public void emitSUB(COND cond, GPR Rd, GPR Rn, GPR Rm) {
    int mi = cond.value() | b0000010 << 21 | Rn.value() << 16 | Rd.value() << 12 | Rm.value();
    appendInstruction(mi);
  }

  public void emitUDF(int V) {
    if (VM.VerifyAssertions) VM._assert(fits_unsigned(V, 4));
    int mi = ALWAYS.value() | b01111111 << 20 | b1111 << 4 | V & 0xF;
    appendInstruction(mi);
  }

  public void emitYIELD(COND cond) {
    int mi = cond.value() | b00110010 << 20 | b1111 << 12 | 1;
    appendInstruction(mi);
  }

  /*
   * Floating point and advanced SIMD (64-bit int) instructions
   */

  @Inline
  private static float decodeFloat32Imm(int enc) {
    int sign = (enc >>> 19) << 31;
    int exponentSign = (((~enc) >>> 18) & 1) << 31;
    int exponentSignNot = (~exponentSign) & (1 << 31);
    int exponent = (exponentSign >>> 1) | ((exponentSignNot >> 4) >>> 2) | ((enc >>> 16) & b11) << 23;
    int mantissa = (enc & b1111) << 19;
    return Float.intBitsToFloat(sign | exponent | mantissa);
  }

  @Inline
  private static double decodeFloat64Imm(int enc) {
    long sign = (enc >>> 19) << 63;
    long exponentSign = (((~enc) >>> 18) & 1L) << 63;
    long exponentSignNot = (~exponentSign) & (1L << 63);
    long exponent = (exponentSign >>> 1) | ((exponentSignNot >> 7) >>> 2) | ((enc >>> 16) & (long)b11) << 52;
    long mantissa = (enc & (long)b1111) << 48;
    return Double.longBitsToDouble(sign | exponent | mantissa);
  }

  @Inline
  private static int encodeFloat32Imm(float V) {
    int bits = Float.floatToIntBits(V);
    int result = 0;
    result |= ((bits >>> 31) & 1) << 19;    // sign bit
    result |= (((~bits) >>> 30) & 1) << 18; // exponent sign
    result |= ((bits >>> 23) & b11) << 16;  // exponent
    result |= (bits >>> 19) & b1111;        // mantissa
    if (VM.VerifyAssertions && !(V == decodeFloat32Imm(result))) {
      String message = "encodeFloat32Imm() failed round trip test with " + V;
      VM._assert(VM.NOT_REACHED, message);
    }
    return result;
  }

  @Inline
  private static int encodeFloat64Imm(double V) {
    long bits = Double.doubleToLongBits(V);
    int result = 0;
    result |= ((bits >>> 63) & 1) << 19;    // sign bit
    result |= (((~bits) >>> 62) & 1) << 18; // exponent sign
    result |= ((bits >>> 52) & b11) << 16;  // exponent
    result |= (bits >>> 48) & b1111;        // mantissa
    if (VM.VerifyAssertions && !(V == decodeFloat64Imm(result))) {
      String message = "encodeFloat64Imm() failed round trip test with " + V;
      VM._assert(VM.NOT_REACHED, message);
    }
    return result;
  }

  @Inline
  private static int encodeVd32(FPR Vd) {
    return (Vd.value() & 0x1) << 22 | (Vd.value() & b11110) << (12 - 1);
  }

  @Inline
  private static int encodeVd64(DPR Vd) {
    if (VM.VerifyAssertions && !((Vd.value() & 1) == 0)) {
      String message = "encodeVd64: " + Vd.value() + " % 2 != 0";
      VM._assert(VM.NOT_REACHED, message);
    }
    return (Vd.value() & 0x20) << (22 - 5) | (Vd.value() & b11110) << (12 - 1);
  }

  @Inline
  private static int encodeVn32(FPR Vn) {
    return (Vn.value() & 0x1) << 7 | (Vn.value() & b11110) << (16 - 1);
  }

  @Inline
  private static int encodeVn64(DPR Vn) {
    if (VM.VerifyAssertions && !((Vn.value() & 1) == 0)) {
      String message = "encodeVn64: " + Vn.value() + " % 2 != 0";
      VM._assert(VM.NOT_REACHED, message);
    }
    return (Vn.value() & 0x20) << (7 - 5) | (Vn.value() & b11110) << (16 - 1);
  }

  @Inline
  private static int encodeVm32(FPR Vm) {
    return (Vm.value() & 0x1) << 5 | (Vm.value() & b11110) >> 1;
  }

  @Inline
  private static int encodeVm64(DPR Vm) {
    if (VM.VerifyAssertions && !((Vm.value() & 1) == 0)) {
      String message = "encodeVm64: " + Vm.value() + " % 2 != 0";
      VM._assert(VM.NOT_REACHED, message);
    }
    return (Vm.value() & 0x20) << (5 - 5) | (Vm.value() & b11110) >> 1;
  }

  public void emitVADDint64(DPR Vd, DPR Vn, DPR Vm) {
    int mi = NOCOND.value() | b00100011 << 20 | encodeVd64(Vd) | b1000 << 8 | encodeVn64(Vn) | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVADD32(COND cond, FPR Vd, FPR Vn, FPR Vm) {
    int mi = cond.value() | b11100011 << 20 | encodeVd32(Vd) | b1010 << 8 | encodeVn32(Vn) | encodeVm32(Vm);
    appendInstruction(mi);
  }

  public void emitVADD64(COND cond, DPR Vd, DPR Vn, DPR Vm) {
    int mi = cond.value() | b11100011 << 20 | encodeVd64(Vd) | b1011 << 8 | encodeVn64(Vn) | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVAND64(DPR Vd, DPR Vn, DPR Vm) {
    int mi = NOCOND.value() | b00100000 << 20 | encodeVd64(Vd) | b0001 << 8 | 1 << 4 | encodeVn64(Vn) | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVCMP32(COND cond, FPR Vd, FPR Vm) {
    int mi = cond.value() | b111010110100 << 16 | encodeVd32(Vd) | b1010 << 8 | 1 << 6 | encodeVm32(Vm);
    appendInstruction(mi);
  }

  public void emitVCMP64(COND cond, DPR Vd, DPR Vm) {
    int mi = cond.value() | b111010110100 << 16 | encodeVd64(Vd) | b1011 << 8 | 1 << 6 | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVCVT_int32_to_float32(COND cond, FPR Vd, FPR Vm) {
    int mi = cond.value() | b111010111000 << 16 | encodeVd32(Vd) | b101011 << 6 | encodeVm32(Vm);
    appendInstruction(mi);
  }

  public void emitVCVT_int32_to_float64(COND cond, DPR Vd, FPR Vm) {
    int mi = cond.value() | b111010111000 << 16 | encodeVd64(Vd) | b101111 << 6 | encodeVm32(Vm);
    appendInstruction(mi);
  }

  public void emitVCVT_float64_to_int32(COND cond, FPR Vd, DPR Vm) {
    int mi = cond.value() | b111010111101 << 16 | encodeVd32(Vd) | b101111 << 6 | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVCVT_float32_to_int32(COND cond, FPR Vd, FPR Vm) {
    int mi = cond.value() | b111010111101 << 16 | encodeVd32(Vd) | b101011 << 6 | encodeVm32(Vm);
    appendInstruction(mi);
  }

  public void emitVCVT_float32_to_float64(COND cond, DPR Vd, FPR Vm) {
    int mi = cond.value() | b111010110111 << 16 | encodeVd64(Vd) | b101011 << 6 | encodeVm32(Vm);
    appendInstruction(mi);
  }

  public void emitVCVT_float64_to_float32(COND cond, FPR Vd, DPR Vm) {
    int mi = cond.value() | b111010110111 << 16 | encodeVd32(Vd) | b101111 << 6 | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVDIV32(COND cond, FPR Vd, FPR Vn, FPR Vm) {
    int mi = cond.value() | b11101000 << 20 | encodeVd32(Vd) | b1010 << 8 | encodeVn32(Vn) | encodeVm32(Vm);
    appendInstruction(mi);
  }

  public void emitVDIV64(COND cond, DPR Vd, DPR Vn, DPR Vm) {
    int mi = cond.value() | b11101000 << 20 | encodeVd64(Vd) | b1011 << 8 | encodeVn64(Vn) | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVEOR64(DPR Vd, DPR Vn, DPR Vm) {
    int mi = NOCOND.value() | b00110000 << 20 | encodeVd64(Vd) | b0001 << 8 | 1 << 4 | encodeVn64(Vn) | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVLDR32(COND cond, FPR Vd, GPR Rn, int V) {
    boolean neg = (V < 0);
    if (neg) V = -V;
    if (VM.VerifyAssertions && !fits_VLDR_VSTR(V)) {
      String message = "emitVLDR32: !fits_VLDR_VSTR(" + V + ")";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b11010001 << 20 | (neg ? 0 : 1) << 23 | Rn.value() << 16 | encodeVd32(Vd) | b1010 << 8 | ((V >>> 2) & 0xFF);
    appendInstruction(mi);
  }

  public void emitVLDR64(COND cond, DPR Vd, GPR Rn, int V) {
    boolean neg = (V < 0);
    if (neg) V = -V;
    if (VM.VerifyAssertions && !fits_VLDR_VSTR(V)) {
      String message = "emitVLDR64: !fits_VLDR_VSTR(" + V + ")";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b11010001 << 20 | (neg ? 0 : 1) << 23 | Rn.value() << 16 | encodeVd64(Vd) | b1011 << 8 | ((V >>> 2) & 0xFF);
    appendInstruction(mi);
  }

  public void emitVMOV32imm(COND cond, FPR Vd, float V) {
    int mi = cond.value() | b11101011 << 20 | encodeVd32(Vd) | b10100000 << 4 | encodeFloat32Imm(V);
    appendInstruction(mi);
  }

  public void emitVMOV32(COND cond, FPR Vd, FPR Vm) {
    int mi = cond.value() | b11101011 << 20 | encodeVd32(Vd) | b10100100 << 4 | encodeVm32(Vm);
    appendInstruction(mi);
  }

  public void emitVMOV64imm(COND cond, DPR Vd, double V) {
    int mi = cond.value() | b11101011 << 20 | encodeVd64(Vd) | b10110000 << 4 | encodeFloat64Imm(V);
    appendInstruction(mi);
  }

  public void emitVMOV64(COND cond, DPR Vd, DPR Vm) {
    int mi = cond.value() | b11101011 << 20 | encodeVd64(Vd) | b10110100 << 4 | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVMOV_core_to_extension64lower(COND cond, DPR Vd, GPR Rt) { // Effectively the same as core_to_extension32
    // NOTE: "encodeVn64 instead of Vd is not an error but a weird special case (or inconsistency in the letters used by the ARM manual)"
    int mi = cond.value() | b11100000 << 20 | encodeVn64(Vd) | b1011 << 8 | 1 << 4 | Rt.value() << 12;
    appendInstruction(mi);
  }

  public void emitVMOV_core_to_extension64(COND cond, DPR Vm, GPR Rt, GPR Rt2) {
    int mi = cond.value() | b11000100 << 20 | encodeVm64(Vm) | b1011 << 8 | 1 << 4 | Rt.value() << 12 | Rt2.value() << 16;
    appendInstruction(mi);
  }

  public void emitVMOV_extension64_to_core(COND cond, GPR Rt, GPR Rt2, DPR Vm) {
    int mi = cond.value() | b11000101 << 20 | encodeVm64(Vm) | b1011 << 8 | 1 << 4 | Rt.value() << 12 | Rt2.value() << 16;
    appendInstruction(mi);
  }

  public void emitVMOV_core_to_extension32(COND cond, FPR Vn, GPR Rt) {
    int mi = cond.value() | b11100000 << 20 | encodeVn32(Vn) | b1010 << 8 | 1 << 4 | Rt.value() << 12;
    appendInstruction(mi);
  }

  public void emitVMOV_extension32_to_core(COND cond, GPR Rt, FPR Vn) {
    int mi = cond.value() | b11100001 << 20 | encodeVn32(Vn) | b1010 << 8 | 1 << 4 | Rt.value() << 12;
    appendInstruction(mi);
  }

  public void emitVMRS() {
    int mi = ALWAYS.value() | b1110111100011111101000010000;
    appendInstruction(mi);
  }

  public void emitVMUL32(COND cond, FPR Vd, FPR Vn, FPR Vm) {
    int mi = cond.value() | b11100010 << 20 | encodeVd32(Vd) | b1010 << 8 | encodeVn32(Vn) | encodeVm32(Vm);
    appendInstruction(mi);
  }

  public void emitVMUL64(COND cond, DPR Vd, DPR Vn, DPR Vm) {
    int mi = cond.value() | b11100010 << 20 | encodeVd64(Vd) | b1011 << 8 | encodeVn64(Vn) | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVMULint32_scalar(DPR Vd, DPR Vn, DPR Vm) {
    if (VM.VerifyAssertions) VM._assert(Vm.value() <= 0xF << 1); // Could allow any 32 bit register instead of only 64 bit aligned ones
    int mi = NOCOND.value() | b00101010 << 20 | encodeVd64(Vd) | b1000 << 8 | 1 << 6 | encodeVn64(Vn) | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVMULLint32_scalar(QPR Vd, DPR Vn, DPR Vm) { // Unsigned multiplication
    if (VM.VerifyAssertions) VM._assert(Vm.value() <= 0xF << 1);  // Could allow any 32 bit register instead of only 64 bit aligned ones
    if (VM.VerifyAssertions) VM._assert((Vd.value() & b11) == 0); // Quadword register, check last two bits
    int mi = NOCOND.value() | b00111010 << 20 | encodeVd64(DPR.lookup(Vd.value())) | b1010 << 8 | 1 << 6 | encodeVn64(Vn) | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVNEG32(COND cond, FPR Vd, FPR Vm) {
    int mi = cond.value() | b111010110001 << 16 | encodeVd32(Vd) | b1010 << 8 | 1 << 6 | encodeVm32(Vm);
    appendInstruction(mi);
  }

  public void emitVNEG64(COND cond, DPR Vd, DPR Vm) {
    int mi = cond.value() | b111010110001 << 16 | encodeVd64(Vd) | b1011 << 8 | 1 << 6 | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVNOT64(DPR Vd, DPR Vm) { // alias for VMVN
    int mi = NOCOND.value() | b001110110000 << 16 | encodeVd64(Vd) | b1011 << 7 | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVORR64(DPR Vd, DPR Vn, DPR Vm) {
    int mi = NOCOND.value() | b00100010 << 20 | encodeVd64(Vd) | b0001 << 8 | 1 << 4 | encodeVn64(Vn) | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVPOP32(COND cond, FPR Vd) {
    int mi = cond.value() | b110010111101 << 16 | encodeVd32(Vd) | b1010 << 8 | 1;
    appendInstruction(mi);
  }

  public void emitVPOP64(COND cond, DPR Vd) {
    int mi = cond.value() | b110010111101 << 16 | encodeVd64(Vd) | b1011 << 8 | 2;
    appendInstruction(mi);
  }

  public void emitVPUSH32(COND cond, FPR Vd) {
    int mi = cond.value() | b110100101101 << 16 | encodeVd32(Vd) | b1010 << 8 | 1;
    appendInstruction(mi);
  }

  public void emitVPUSH64(COND cond, DPR Vd) {
    int mi = cond.value() | b110100101101 << 16 | encodeVd64(Vd) | b1011 << 8 | 2;
    appendInstruction(mi);
  }

  public void emitVSHL64imm(DPR Vd, DPR Vm, int V) {
    if (VM.VerifyAssertions && !fits_unsigned(V, 6)) {
      String message = "emitVSHL64imm: !fits_unsigned(" + V + ", 6)";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = NOCOND.value() | b00101000 << 20 | V << 16 | encodeVd64(Vd) | b0101 << 8 | 1 << 7 | 1 << 4 | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVSHL64(DPR Vd, DPR Vm, DPR Vn) {
    int mi = NOCOND.value() | b00110011 << 20 | encodeVd64(Vd) | b0100 << 8 | encodeVn64(Vn) | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVSHL64signed(DPR Vd, DPR Vm, DPR Vn) {
    int mi = NOCOND.value() | b00100011 << 20 | encodeVd64(Vd) | b0100 << 8 | encodeVn64(Vn) | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVSQRT32(COND cond, FPR Vd, FPR Vm) {
    int mi = cond.value() | b111010110001 << 16 | encodeVd32(Vd) | b1010 << 8 | 1 << 7 | 1 << 6 | encodeVm32(Vm);
    appendInstruction(mi);
  }

  public void emitVSQRT64(COND cond, DPR Vd, DPR Vm) {
    int mi = cond.value() | b111010110001 << 16 | encodeVd64(Vd) | b1011 << 8 | 1 << 7 | 1 << 6 | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVSTR32(COND cond, FPR Vd, GPR Rn, int V) {
    boolean neg = (V < 0);
    if (neg) V = -V;
    if (VM.VerifyAssertions && !fits_VLDR_VSTR(V)) {
      String message = "emitVSTR32: !fits_VLDR_VSTR(" + V + ")";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b11010000 << 20 | (neg ? 0 : 1) << 23 | Rn.value() << 16 | encodeVd32(Vd) | b1010 << 8 | ((V >>> 2) & 0xFF);
    appendInstruction(mi);
  }

  public void emitVSTR64(COND cond, DPR Vd, GPR Rn, int V) {
    boolean neg = (V < 0);
    if (neg) V = -V;
    if (VM.VerifyAssertions && !fits_VLDR_VSTR(V)) {
      String message = "emitVSTR64: !fits_VLDR_VSTR(" + V + ")";
      VM._assert(VM.NOT_REACHED, message);
    }
    int mi = cond.value() | b11010000 << 20 | (neg ? 0 : 1) << 23 | Rn.value() << 16 | encodeVd64(Vd) | b1011 << 8 | ((V >>> 2) & 0xFF);
    appendInstruction(mi);
  }

  public void emitVSUBint64(DPR Vd, DPR Vn, DPR Vm) {
    int mi = NOCOND.value() | b00110011 << 20 | encodeVd64(Vd) | b1000 << 8 | encodeVn64(Vn) | encodeVm64(Vm);
    appendInstruction(mi);
  }

  public void emitVSUB32(COND cond, FPR Vd, FPR Vn, FPR Vm) {
    int mi = cond.value() | b11100011 << 20 | encodeVd32(Vd) | b1010 << 8 | 1 << 6 | encodeVn32(Vn) | encodeVm32(Vm);
    appendInstruction(mi);
  }

  public void emitVSUB64(COND cond, DPR Vd, DPR Vn, DPR Vm) {
    int mi = cond.value() | b11100011 << 20 | encodeVd64(Vd) | b1011 << 8 | 1 << 6 | encodeVn64(Vn) | encodeVm64(Vm);
    appendInstruction(mi);
  }

  /*
   * Macros
   */
  public void generateImmediateLoad(COND cond, GPR reg, int val) {
    if (fits_unsigned(val, 16))
      emitMOVW(cond, reg, val);
    else if (fits_unsigned(~val, 8)) {
      emitMVNimm(cond, reg, val);
    } else {
      emitMOVW(cond, reg, val & 0xFFFF);
      emitMOVT(cond, reg, (val >>> 16) & 0xFFFF);
    }
  }

  public void generateOffsetLoad(COND cond, GPR Rdest, GPR Rbase, Offset offset) {
    if (VM.VerifyAssertions && !(Rbase.value() != R12.value())) {
      String message = "generateOffsetLoad: Rbase == R12";
      VM._assert(VM.NOT_REACHED, message);
    }
    if (fits_unsigned(offset.toInt(), 12) || fits_unsigned(-offset.toInt(), 12))
      emitLDRimm(cond, Rdest, Rbase, offset.toInt());
    else {
      generateImmediateLoad(cond, R12, offset.toInt());
      emitLDR(cond, Rdest, Rbase, R12);
    }
  }

  public void generateOffsetLoad64(COND cond, DPR Vdest, GPR Rbase, Offset offset) {
    if (VM.VerifyAssertions && !(Rbase.value() != R12.value())) {
      String message = "generateOffsetLoad64: Rbase == R12";
      VM._assert(VM.NOT_REACHED, message);
    }
    if (fits_VLDR_VSTR(offset.toInt()))
      emitVLDR64(cond, Vdest, Rbase, offset.toInt());
    else {
      generateImmediateLoad(cond, R12, offset.toInt());
      emitADD(cond, R12, Rbase, R12);
      emitVLDR64(cond, Vdest, R12, 0);
    }
  }

  public void generateOffsetStore(COND cond, GPR Rsource, GPR Rbase, Offset offset) {
    if (VM.VerifyAssertions && !(Rbase.value() != R12.value())) {
      String message = "generateOffsetStore: Rbase == R12";
      VM._assert(VM.NOT_REACHED, message);
    }
    if (fits_unsigned(offset.toInt(), 12))
      emitSTRimm(cond, Rsource, Rbase, offset.toInt());
    else {
      generateImmediateLoad(cond, R12, offset.toInt());
      emitSTR(cond, Rsource, Rbase, R12);
    }
  }

  public void generateOffsetStore64(COND cond, DPR Vsource, GPR Rbase, Offset offset) {
    if (VM.VerifyAssertions && !(Rbase.value() != R12.value())) {
      String message = "generateOffsetStore64: Rbase == R12";
      VM._assert(VM.NOT_REACHED, message);
    }
    if (fits_VLDR_VSTR(offset.toInt()))
      emitVSTR64(cond, Vsource, Rbase, offset.toInt());
    else {
      generateImmediateLoad(cond, R12, offset.toInt());
      emitADD(cond, R12, Rbase, R12);
      emitVSTR64(cond, Vsource, R12, 0);
    }
  }

  public void generateImmediateSubtract(COND cond, GPR Rdest, GPR Rsource, int V) {
    if (VM.VerifyAssertions && !(Rsource.value() != R12.value())) {
      String message = "generateImmediateSubtract: Rsource == R12";
      VM._assert(VM.NOT_REACHED, message);
    }
    generateImmediateAdd(cond, Rdest, Rsource, -V);
  }

  public void generateImmediateAdd(COND cond, GPR Rdest, GPR Rsource, int V) {
    if (VM.VerifyAssertions && !(Rsource.value() != R12.value())) {
      String message = "generateImmediateAdd: Rsource == R12";
      VM._assert(VM.NOT_REACHED, message);
    }
    if      (fits_unsigned(V, 8))
      emitADDimm(cond, Rdest, Rsource, V);
    else if (fits_unsigned(-V, 8))
      emitSUBimm(cond, Rdest, Rsource, -V);
    else {
      generateImmediateLoad(cond, R12, V);
      emitADD(cond, Rdest, Rsource, R12);
    }
  }

  public void generateImmediateCompare(COND cond, GPR R, int V) {
    if (VM.VerifyAssertions && !(R.value() != R12.value())) {
      String message = "generateImmediateCompare: Rsource == R12";
      VM._assert(VM.NOT_REACHED, message);
    }
    if (fits_unsigned(V, 8))
      emitCMPimm(cond, R, V);
    else {
      generateImmediateLoad(cond, R12, V);
      emitCMP(cond, R, R12);
    }
  }

  public void generateCheckBitsSet(COND cond, GPR Rsource, int mask) {
    if (VM.VerifyAssertions && !(Rsource.value() != R12.value())) {
      String message = "generateCheckBitsSet: Rsource == R12";
      VM._assert(VM.NOT_REACHED, message);
    }
    if (fits_unsigned(mask, 8)) {
      emitANDSimm(cond, R12, Rsource, mask); // Sets condition flags
    } else {
      generateImmediateLoad(cond, R12, mask);
      emitANDS(cond, R12, Rsource, R12);   // Sets condition flags
    }
  }

  // MRRC p15, 0, Rlow, Rhigh, c14
  public void generateGetTimer(COND cond, GPR Rlow, GPR Rhigh) {
    emitMRRC(cond, 15, 0, Rlow, Rhigh, 14); // Note: this will not work in user mode
  }

  // Emit a permanently undefined opcode to produce an immediate fatal error
  public void generateUndefined() {
    emitUDF(0);
  }

  /*
   * Exception handling
   * The baseline compiler checks for some exceptions by producing OS signals
   * Specifically, null pointer dereferences are caught with no overhead because they produce a SIGSEGV
   * Some other conditions produce traps that are interpreted by the signal handler in the bootloader
   * (See sysSignal_arm.c)
   * The signal handler reads the instruction that produced the trap (in the ARM port, it is the instruction before it)
   * to determine what exception to hand back to the java code
   * (See also tools.header_gen.GenArch_arm.java)
   */

  // Gen bounds check for array load/store
  // Uses an unsigned comparison so negative indexes look like very large ones
  @Inline
  public void generateBoundsCheck(GPR Rindex, GPR Rlength) {
    emitCMP(ALWAYS, Rlength, Rindex);
    emitMOVimm(LS, R12, 0);
    emitLDRimm(LS, R12, R12, 0);     // Produces SIGSEGV iff index < 0 or length <= index
  }

  @Inline
  public void generateDivideByZeroCheck(GPR reg) {
    emitCMPimm(ALWAYS, reg, 0);
    emitMOVimm(EQ, R12, 0);
    emitLDRimm(EQ, R12, R12, 0);     // Produces SIGSEGV iff reg == 0
  }

  // This could just be a direct load from the register ...
  @Inline
  public void generateNullCheck(GPR reg) {
    emitCMPimm(ALWAYS, reg, 0);
    emitMOVimm(EQ, R12, 1);
    emitLDRimm(EQ, R12, R12, 0);     // Produces SIGSEGV iff reg == 0
  }

  @Inline
  public void generateInterfaceImplementCheck(COND cond) {
    emitMOVimm(cond, R12, 2);
    emitLDRimm(cond, R12, R12, 0); // Produces SIGSEGV iff cond is true
  }

  @Inline
  public void generateCheckCast(COND cond) {
    emitMOVimm(cond, R12, 3);
    emitLDRimm(cond, R12, R12, 0); // Produces SIGSEGV iff cond is true
  }

  @Inline
  public void generateStackOverflowCheck(int frameSize) {
    emitPUSH(ALWAYS, R0); // Yuck! But I don't know how to do this with only one register, and everything besides R12 is taken!
    generateOffsetLoad(ALWAYS, R0, TR, Entrypoints.stackLimitField.getOffset()); // R0  := stack guard
    generateImmediateAdd(ALWAYS, R12, R0, frameSize);                            // R12 := position of SP if pushing the frame would just reach the guard
    emitPOP(ALWAYS, R0);
    emitCMP(ALWAYS, R12, SP);                                                    // Want R12 to be below SP, meaning there is still room
    emitMOVimm(GE, R12, 0);
    emitLDRimm(GE, R12, R12, 0);                                                 // Produces SIGSEGV iff R12 >= SP
  }

  /**
   * Stack overflow check for native methods. For the first Java to C transition frame in the stack,
   * check that there is space of STACK_SIZE_NATIVE words available on the stack.
   * For subsequent Java to C transition frames, check for the requested size.
   *
   * On entry, register R7 holds a pointer to the JNIEnv
   * R5 holds a pointer to JNIRefsTop
   * TR is still valid
   * FP points to the mini-frame (see diagram in JNICompiler.java)
   * R6 and R8 have been saved and can be used
   * R12 can also be used
   */
  public void generateNativeStackOverflowCheck(int frameSize) {
    generateOffsetLoad(ALWAYS, R6, TR, Entrypoints.stackLimitField.getOffset()); // R6 := stack guard
    emitCMPimm(ALWAYS, R5, 0);                                                   // check if JNIRefsTop == 0 -> first native frame on stack
    generateImmediateAdd(EQ, R12, R6, STACK_SIZE_JNINATIVE);                     // R12 := position of SP if pushing the frame would just reach the guard
    generateImmediateAdd(NE, R12, R6, frameSize);                                // If first frame, need STACK_SIZE_JNINATIVE space, otherwise, frameSize
    emitCMP(ALWAYS, SP, R12);                                                    // Want R12 to be below SP, meaning there is still room
    emitMOVimm(LE, R12, 0);
    emitLDRimm(LE, R12, R12, 0);                                                 // Produces SIGSEGV iff SP <= R12
  }


  /*
   * Forward Reference Macros (forward branches have to be patched later once the machine code offset is known)
   */

  ForwardReference forwardRefs = null; // link to queue of Forward References

  // Branch somewhere that may be a fixed machine code or a known future bytecode
  public void generateUnknownBranch(COND cond, int mTarget, int bTarget) {
    if (mTarget == 0) // If a forward branch, mTarget will be 0 and we have to use a ForwardReference
      generateForwardBranch(cond, bTarget);
    else              // If a backward branch, mTarget refers to a machine code location
      generateBackwardBranch(cond, mTarget);
  }

  public void generateBackwardBranch(COND cond, int mTarget) {
    emitB(cond, mTarget); // This version of emitB adjusts mTarget to get the correct number to put into the instruction
  }

  // Branch to an unknown address. Is resolved later by calling fr.resolve()
  public ForwardReference generateForwardBranch(COND cond) {
    ForwardReference fr = new ForwardReference.ConditionalBranch(mIP);
    _emitB(cond, 0);      // This version of emitB uses the zero value without any adjustments
    return fr;
  }

  // Branch to a known bytecode. Is queued up so the compiler can call resolveForwardReferences() once it reaches that bytecode
  public void generateForwardBranch(COND cond, int label) {
    ForwardReference fr = new ForwardReference.ConditionalBranch(mIP, label);
    forwardRefs = ForwardReference.enqueue(forwardRefs, fr);
    _emitB(cond, 0);
  }

  // Write the literal offset to branch to for a tableswitch case
  // Offsets need to be generated relative to baseIP rather than mIP
  public void generateSwitchCase(int baseIP, int instruction_index, int bTarget) {
    int data;

    if (instruction_index == 0) { // Forward branch, use a ForwardReference
      ForwardReference fr = new ForwardReference.SwitchCase(mIP, bTarget);
      forwardRefs = ForwardReference.enqueue(forwardRefs, fr);
      data = baseIP;              // Save the baseIP so we can read it and use it when patching
    } else {
      if (VM.VerifyAssertions) VM._assert(instruction_index < baseIP);
      data = (instruction_index - baseIP - 2) << 2; // -2 because the ARM PC points 2 instructions ahead
    }

    appendInstruction(data);
  }

  // Push the (absolute) address of a known future bytecode on the stack
  public void generateLoadReturnAddress(int bReturn) {
    emitMOV(ALWAYS, R12, PC); // Since the ARM PC is (current instr + 8), R12 now points to the PUSH instruction below

    ForwardReference fr = new ForwardReference.LoadReturnAddress(mIP, bReturn);
    forwardRefs = ForwardReference.enqueue(forwardRefs, fr);

    emitADDimm(ALWAYS, R12, R12, 0); // To be patched later with the relative offset
    emitPUSH(ALWAYS, R12);
  }

  // Calls the resolve() method on all ForwardReferences that reference the current bytecode (and hence the current machine code)
  @Override
  public void resolveForwardReferences(int label) {
    if (forwardRefs != null)
      forwardRefs = ForwardReference.resolveMatching(this, forwardRefs, label);
  }

  @Override
  public void patchUnconditionalBranch(int sourceMachinecodeIndex) {
    if (VM.VerifyAssertions) VM._assert(VM.NOT_REACHED); // All ARM branches are conditional
  }

  @Override
  public void patchConditionalBranch(int sourceMachinecodeIndex) {
    int delta = mIP - sourceMachinecodeIndex - 2; // ARM branches are relative to PC, and PC is 2 instructions ahead
    if (VM.VerifyAssertions && !fits_B(delta)) {
      String message = "patchConditionalBranch: !fits_B(" + delta + ")";
      VM._assert(VM.NOT_REACHED, message);
    }

    machineCodes[sourceMachinecodeIndex] = machineCodes[sourceMachinecodeIndex] | (delta & 0xFFFFFF);
  }

  @Override
  public void patchShortBranch(int sourceMachinecodeIndex) {
    if (VM.VerifyAssertions) VM._assert(VM.NOT_REACHED); // This method is for PPC only
  }

  @Override
  public void patchSwitchCase(int sourceMachinecodeIndex) {
    int baseIP = machineCodes[sourceMachinecodeIndex];
    machineCodes[sourceMachinecodeIndex] = (mIP - baseIP - 2) << 2; // -2 because the ARM PC points 2 instructions ahead
  }

  @Override // TODO check if (-1) is the right value to add
  public void patchLoadReturnAddress(int sourceMachinecodeIndex) {
    int offset = (mIP - sourceMachinecodeIndex - 1) << 2; // offset in words
    if (VM.VerifyAssertions && !fits_unsigned(offset, 8)) {
      String message = "patchLoadReturnAddress: !fits_unsigned(" + offset + ",8)";
      VM._assert(VM.NOT_REACHED, message);
    }
    machineCodes[sourceMachinecodeIndex] = machineCodes[sourceMachinecodeIndex] | (offset & 0xFF);
  }

  /**
   * Append a CodeArray to the current machine code
   */
  public void appendInstructions(CodeArray instructionSegment) {
    for (int i = 0; i < instructionSegment.length(); i++) {
      appendInstruction(instructionSegment.get(i));
    }
  }

  @Override
  public void baselineEmitLoadTIB(MachineRegister dest, MachineRegister object) {
    Offset tibOffset = JavaHeader.getTibOffset();
    emitLDRimm(ALWAYS, (GPR)dest, (GPR)object, tibOffset.toInt()); // This must not ever modify R12 because InterfaceMethodConflictResolver needs R12 unchanged
  }

  /************************************************************************
   * Stub/s added for IA32 compatability
   */
  public static void patchCode(CodeArray code, int indexa, int indexb) {
    if (VM.VerifyAssertions) VM._assert(VM.NOT_REACHED);
  }
}
